<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>clingox.reify API documentation</title>
<meta name="description" content="This module provides functions to reify programs â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clingox.reify</code></h1>
</header>
<section id="section-intro">
<p>This module provides functions to reify programs.</p>
<p>This includes a <code><a title="clingox.reify.Reifier" href="#clingox.reify.Reifier">Reifier</a></code> implementing clingo's <code><a title="clingo.backend.Observer" href="../clingo/backend.html#clingo.backend.Observer">Observer</a></code>
interface that can be registered with a <code><a title="clingo.control.Control" href="../clingo/control.html#clingo.control.Control">Control</a></code> object.</p>
<p>Additionally, the module provides a <code><a title="clingox.reify.ReifiedTheory" href="#clingox.reify.ReifiedTheory">ReifiedTheory</a></code> class that provides a
similar interface as clingo's theory atoms but uses the reified symbols.</p>
<h2 id="examples">Examples</h2>
<p>The following example uses the <code><a title="clingox.reify.reify_program" href="#clingox.reify.reify_program">reify_program()</a></code> function to reify a program:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from clingox.reify import reify_program
&gt;&gt;&gt; prg = 'b :- a. {a}.'
&gt;&gt;&gt; symbols = reify_program(prg)
&gt;&gt;&gt; print([str(sym) for sym in symbols])
['tag(incremental)', 'atom_tuple(0)', 'atom_tuple(0,1)', 'literal_tuple(0)',
'rule(choice(0),normal(0))', 'atom_tuple(1)', 'atom_tuple(1,2)',
'literal_tuple(1)', 'literal_tuple(1,1)', 'rule(disjunction(1),normal(1))',
'output(a,1)', 'literal_tuple(2)', 'literal_tuple(2,2)', 'output(b,2)']
</code></pre>
<p>The last example shows how to use the <code><a title="clingox.reify.ReifiedTheory" href="#clingox.reify.ReifiedTheory">ReifiedTheory</a></code> class.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from clingox.reify import ReifiedTheory, reify_program
&gt;&gt;&gt; prg = '#theory theory { t { }; &amp;p/0 : t, any }. &amp;p { t }.'
&gt;&gt;&gt; thy = ReifiedTheory(reify_program(prg))
&gt;&gt;&gt; print([str(atm) for atm in thy])
['&amp;p { t: literal_tuple(0) }']
&gt;&gt;&gt; from clingox.theory import evaluate
&gt;&gt;&gt; evaluate(next(iter(thy)).term)
Function('p', [], True)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides functions to reify programs.

This includes a `Reifier` implementing clingo&#39;s `clingo.backend.Observer`
interface that can be registered with a `clingo.control.Control` object.

Additionally, the module provides a `ReifiedTheory` class that provides a
similar interface as clingo&#39;s theory atoms but uses the reified symbols.

Examples
--------

The following example uses the `reify_program` function to reify a program:

```python-repl
&gt;&gt;&gt; from clingox.reify import reify_program
&gt;&gt;&gt; prg = &#39;b :- a. {a}.&#39;
&gt;&gt;&gt; symbols = reify_program(prg)
&gt;&gt;&gt; print([str(sym) for sym in symbols])
[&#39;tag(incremental)&#39;, &#39;atom_tuple(0)&#39;, &#39;atom_tuple(0,1)&#39;, &#39;literal_tuple(0)&#39;,
&#39;rule(choice(0),normal(0))&#39;, &#39;atom_tuple(1)&#39;, &#39;atom_tuple(1,2)&#39;,
&#39;literal_tuple(1)&#39;, &#39;literal_tuple(1,1)&#39;, &#39;rule(disjunction(1),normal(1))&#39;,
&#39;output(a,1)&#39;, &#39;literal_tuple(2)&#39;, &#39;literal_tuple(2,2)&#39;, &#39;output(b,2)&#39;]
```

The last example shows how to use the `ReifiedTheory` class.

```python-repl
&gt;&gt;&gt; from clingox.reify import ReifiedTheory, reify_program
&gt;&gt;&gt; prg = &#39;#theory theory { t { }; &amp;p/0 : t, any }. &amp;p { t }.&#39;
&gt;&gt;&gt; thy = ReifiedTheory(reify_program(prg))
&gt;&gt;&gt; print([str(atm) for atm in thy])
[&#39;&amp;p { t: literal_tuple(0) }&#39;]
&gt;&gt;&gt; from clingox.theory import evaluate
&gt;&gt;&gt; evaluate(next(iter(thy)).term)
Function(&#39;p&#39;, [], True)
```
&#34;&#34;&#34;

from dataclasses import dataclass, field
from typing import (
    Callable,
    Dict,
    Generic,
    Iterator,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    TypeVar,
)

from clingo.backend import HeuristicType, Observer, TruthValue
from clingo.control import Control
from clingo.symbol import Function, Number, String, Symbol
from clingo.theory_atoms import TheoryTermType

from .theory import is_operator

__all__ = [
    &#34;Reifier&#34;,
    &#34;ReifiedTheory&#34;,
    &#34;ReifiedTheoryAtom&#34;,
    &#34;ReifiedTheoryElement&#34;,
    &#34;ReifiedTheoryTerm&#34;,
    &#34;ReifiedTheory&#34;,
    &#34;reify_program&#34;,
]

T = TypeVar(&#34;T&#34;)  # pylint: disable=invalid-name
U = TypeVar(&#34;U&#34;, int, Tuple[int, int])  # pylint: disable=invalid-name


@dataclass
class _Vertex(Generic[T]):
    &#34;&#34;&#34;
    Vertex data to calculate SCCs of a graph.
    &#34;&#34;&#34;

    name: T
    visited: int
    index: int = 0
    edges: List[int] = field(default_factory=list)


class _Graph(Generic[T]):
    &#34;&#34;&#34;
    Simple class to compute strongly connected components using Tarjan&#39;s
    algorithm.
    &#34;&#34;&#34;

    _names: Dict[T, int]
    _vertices: List[_Vertex]
    _phase: bool

    def __init__(self):
        self._names = {}
        self._vertices = []
        self._phase = True

    def _visited(self, key_u: int) -&gt; bool:
        return self._vertices[key_u].visited != int(not self._phase)

    def _active(self, key_u: int) -&gt; bool:
        return self._vertices[key_u].visited != int(self._phase)

    def _add_vertex(self, val_u: T) -&gt; int:
        n = len(self._vertices)
        key_u = self._names.setdefault(val_u, n)
        if n == key_u:
            self._vertices.append(_Vertex(val_u, int(not self._phase)))
        return key_u

    def add_edge(self, val_u: T, val_v: T) -&gt; None:
        &#34;&#34;&#34;
        Add an edge to the graph.
        &#34;&#34;&#34;
        key_u = self._add_vertex(val_u)
        key_v = self._add_vertex(val_v)
        self._vertices[key_u].edges.append(key_v)

    def tarjan(self) -&gt; List[List[T]]:
        &#34;&#34;&#34;
        Returns the strictly connected components of the graph.
        &#34;&#34;&#34;
        sccs: List[List[T]] = []
        stack = []
        trail = []
        index = 1

        def push(key_u: int):
            nonlocal index
            index += 1
            vtx_u = self._vertices[key_u]
            vtx_u.visited = index
            vtx_u.index = 0
            stack.append(key_u)
            trail.append(key_u)

        for key_u in range(len(self._vertices)):
            if self._visited(key_u):
                continue
            index = 1
            push(key_u)
            while stack:
                key_v = stack[-1]
                vtx_v = self._vertices[key_v]
                len_v = len(vtx_v.edges)
                while vtx_v.index &lt; len_v:
                    key_w = vtx_v.edges[vtx_v.index]
                    vtx_v.index += 1
                    if not self._visited(key_w):
                        push(key_w)
                        break
                else:
                    stack.pop()
                    root = True
                    for key_w in vtx_v.edges:
                        vtx_w = self._vertices[key_w]
                        if self._active(key_w) and vtx_w.visited &lt; vtx_v.visited:
                            root = False
                            vtx_v.visited = vtx_w.visited
                    if root:
                        key_last = None
                        sccs.append([])
                        while key_last != key_v:
                            key_last = trail[-1]
                            vtx_last = self._vertices[key_last]
                            sccs[-1].append(vtx_last.name)
                            vtx_last.visited = int(self._phase)
                            trail.pop()
                        if len(sccs[-1]) == 1:
                            sccs.pop()

        self._phase = not self._phase
        return sccs


@dataclass
class _StepData:
    atom_tuples: Dict[Sequence[int], int] = field(default_factory=dict)
    lit_tuples: Dict[Sequence[int], int] = field(default_factory=dict)
    wlit_tuples: Dict[Sequence[Tuple[int, int]], int] = field(default_factory=dict)
    theory_tuples: Dict[Sequence[int], int] = field(default_factory=dict)
    theory_element_tuples: Dict[Sequence[int], int] = field(default_factory=dict)
    graph: _Graph = field(default_factory=_Graph)


def _theory(i: Symbol, pos: int, lit: int) -&gt; Sequence[Symbol]:
    return [i, Number(pos), Number(lit)]


def _lit(i: Symbol, pos: int, lit: int) -&gt; Sequence[Symbol]:
    # pylint: disable=unused-argument
    return [i, Number(lit)]


def _wlit(i: Symbol, pos: int, wlit: Tuple[int, int]) -&gt; Sequence[Symbol]:
    # pylint: disable=unused-argument
    return [i, Number(wlit[0]), Number(wlit[1])]


class Reifier(Observer):
    &#34;&#34;&#34;
    An observer that will gather the symbols of the reification, in the same way as `clingo --output=reify`.

    Parameters
    ----------
    cb
        A callback function that will be called with each symbol of the reification
    calculate_sccs
        Flag to calculate the SCCs
    reify_steps
        Flag to add a number as the last argument of all reification symbols for the corresponding step

    &#34;&#34;&#34;

    # pylint:disable=too-many-public-methods
    _step: int
    # Bug in mypy???
    # _cb: Callable[[Symbol], None]
    _calculate_sccs: bool
    _reify_steps: bool
    _step_data: _StepData

    def __init__(
        self,
        cb: Callable[[Symbol], None],
        calculate_sccs: bool = False,
        reify_steps: bool = False,
    ):
        self._step = 0
        self._cb = cb
        self._calculate_sccs = calculate_sccs
        self._reify_steps = reify_steps
        self._step_data = _StepData()

    def calculate_sccs(self) -&gt; None:
        &#34;&#34;&#34;
        Trigger computation of SCCs.

        SCCs can only be computed if the Reifier has been initialized with
        `calculate_sccs=True`, This function is called automatically if
        `reify_steps=True` has been set when initializing the Reifier.
        &#34;&#34;&#34;
        for idx, scc in enumerate(self._step_data.graph.tarjan()):
            for atm in scc:
                self._output(&#34;scc&#34;, [Number(idx), Number(atm)])

    def _add_edges(self, head: Sequence[int], body: Sequence[int]):
        if self._calculate_sccs:
            for u in head:
                for v in body:
                    if v &gt; 0:
                        self._step_data.graph.add_edge(u, v)

    def _output(self, name: str, args: Sequence[Symbol]):
        if self._reify_steps:
            args = list(args) + [Number(self._step)]
        self._cb(Function(name, args))

    def _tuple(
        self,
        name: str,
        snmap: Dict[Sequence[U], int],
        elems: Sequence[U],
        afun: Callable[[Symbol, int, U], Sequence[Symbol]],
        ordered: bool = False,
    ) -&gt; Symbol:
        pruned: Sequence[U]
        if ordered:
            pruned = elems
            ident = tuple(elems)
        else:
            seen: Set[U] = set()
            pruned = []
            for elem in elems:
                if elem not in seen:
                    seen.add(elem)
                    pruned.append(elem)
            ident = tuple(sorted(pruned))

        n = len(snmap)
        i = Number(snmap.setdefault(ident, n))
        if n == i.number:
            self._output(name, [i])
            for idx, atm in enumerate(pruned):
                self._output(name, afun(i, idx, atm))
        return i

    def _atom_tuple(self, atoms: Sequence[int]):
        return self._tuple(&#34;atom_tuple&#34;, self._step_data.atom_tuples, atoms, _lit)

    def _lit_tuple(self, lits: Sequence[int]):
        return self._tuple(&#34;literal_tuple&#34;, self._step_data.lit_tuples, lits, _lit)

    def _wlit_tuple(self, wlits: Sequence[Tuple[int, int]]):
        return self._tuple(
            &#34;weighted_literal_tuple&#34;, self._step_data.wlit_tuples, wlits, _wlit
        )

    def init_program(self, incremental: bool) -&gt; None:
        if incremental:
            self._cb(Function(&#34;tag&#34;, [Function(&#34;incremental&#34;)]))

    def begin_step(self) -&gt; None:
        pass

    def rule(self, choice: bool, head: Sequence[int], body: Sequence[int]) -&gt; None:
        hn = &#34;choice&#34; if choice else &#34;disjunction&#34;
        hd = Function(hn, [self._atom_tuple(head)])
        bd = Function(&#34;normal&#34;, [self._lit_tuple(body)])
        self._output(&#34;rule&#34;, [hd, bd])
        self._add_edges(head, body)

    def weight_rule(
        self,
        choice: bool,
        head: Sequence[int],
        lower_bound: int,
        body: Sequence[Tuple[int, int]],
    ) -&gt; None:
        hn = &#34;choice&#34; if choice else &#34;disjunction&#34;
        hd = Function(hn, [self._atom_tuple(head)])
        bd = Function(&#34;sum&#34;, [self._wlit_tuple(body), Number(lower_bound)])
        self._output(&#34;rule&#34;, [hd, bd])
        self._add_edges(head, [lit for lit, w in body])

    def minimize(self, priority: int, literals: Sequence[Tuple[int, int]]) -&gt; None:
        self._output(&#34;minimize&#34;, [Number(priority), self._wlit_tuple(literals)])

    def project(self, atoms: Sequence[int]) -&gt; None:
        for atom in atoms:
            self._output(&#34;project&#34;, [Number(atom)])

    def output_atom(self, symbol: Symbol, atom: int) -&gt; None:
        self._output(&#34;output&#34;, [symbol, self._lit_tuple([] if atom == 0 else [atom])])

    def output_term(self, symbol: Symbol, condition: Sequence[int]) -&gt; None:
        self._output(&#34;output&#34;, [symbol, self._lit_tuple(condition)])

    def external(self, atom: int, value: TruthValue) -&gt; None:
        value_name = str(value).replace(&#34;TruthValue.&#34;, &#34;&#34;).lower().rstrip(&#34;_&#34;)
        self._output(&#34;external&#34;, [Number(atom), Function(value_name)])

    def assume(self, literals: Sequence[int]) -&gt; None:
        for lit in literals:
            self._output(&#34;assume&#34;, [Number(lit)])

    def heuristic(
        self,
        atom: int,
        type_: HeuristicType,
        bias: int,
        priority: int,
        condition: Sequence[int],
    ) -&gt; None:
        type_name = str(type_).replace(&#34;HeuristicType.&#34;, &#34;&#34;).lower().rstrip(&#34;_&#34;)
        condition_lit = self._lit_tuple(condition)
        self._output(
            &#34;heuristic&#34;,
            [
                Number(atom),
                Function(type_name),
                Number(bias),
                Number(priority),
                condition_lit,
            ],
        )

    def acyc_edge(self, node_u: int, node_v: int, condition: Sequence[int]) -&gt; None:
        self._output(
            &#34;edge&#34;, [Number(node_u), Number(node_v), self._lit_tuple(condition)]
        )

    def theory_term_number(self, term_id: int, number: int) -&gt; None:
        self._output(&#34;theory_number&#34;, [Number(term_id), Number(number)])

    def theory_term_string(self, term_id: int, name: str) -&gt; None:
        self._output(&#34;theory_string&#34;, [Number(term_id), String(name)])

    def theory_term_compound(
        self, term_id: int, name_id_or_type: int, arguments: Sequence[int]
    ) -&gt; None:
        names = {-1: &#34;tuple&#34;, -2: &#34;set&#34;, -3: &#34;list&#34;}
        if name_id_or_type in names:
            name = &#34;theory_sequence&#34;
            value = Function(names[name_id_or_type])
        else:
            name = &#34;theory_function&#34;
            value = Number(name_id_or_type)
        tuple_id = self._tuple(
            &#34;theory_tuple&#34;, self._step_data.theory_tuples, arguments, _theory, True
        )
        self._output(name, [Number(term_id), value, tuple_id])

    def theory_element(
        self, element_id: int, terms: Sequence[int], condition: Sequence[int]
    ) -&gt; None:
        tuple_id = self._tuple(
            &#34;theory_tuple&#34;, self._step_data.theory_tuples, terms, _theory, True
        )
        condition_id = self._tuple(
            &#34;literal_tuple&#34;, self._step_data.lit_tuples, condition, _lit
        )
        self._output(&#34;theory_element&#34;, [Number(element_id), tuple_id, condition_id])

    def theory_atom(
        self, atom_id_or_zero: int, term_id: int, elements: Sequence[int]
    ) -&gt; None:
        tuple_e_id = self._tuple(
            &#34;theory_element_tuple&#34;,
            self._step_data.theory_element_tuples,
            elements,
            _lit,
        )
        self._output(
            &#34;theory_atom&#34;, [Number(atom_id_or_zero), Number(term_id), tuple_e_id]
        )

    def theory_atom_with_guard(
        self,
        atom_id_or_zero: int,
        term_id: int,
        elements: Sequence[int],
        operator_id: int,
        right_hand_side_id: int,
    ) -&gt; None:
        tuple_id = self._tuple(
            &#34;theory_element_tuple&#34;,
            self._step_data.theory_element_tuples,
            elements,
            _lit,
        )
        self._output(
            &#34;theory_atom&#34;,
            [
                Number(atom_id_or_zero),
                Number(term_id),
                tuple_id,
                Number(operator_id),
                Number(right_hand_side_id),
            ],
        )

    def end_step(self) -&gt; None:
        if self._reify_steps:
            self.calculate_sccs()
            self._step += 1
            self._step_data = _StepData()


def _set(
    matches: Sequence[Tuple[str, int]],
    lst: List[Symbol],
    sym,
    append: bool = False,
    default: Symbol = Number(0),
) -&gt; bool:
    for match in matches:
        if not sym.match(*match):
            continue
        idx = len(lst) if append else sym.arguments[0].number
        while len(lst) &lt;= idx:
            lst.append(default)
        lst[idx] = sym
        return True
    return False


def _ensure(name: str, lst: List[List[int]], sym: Symbol, ordered=False) -&gt; bool:
    empty = sym.match(name, 1)
    if empty or sym.match(name, 3 if ordered else 2):
        idx = sym.arguments[0].number
        while len(lst) &lt;= idx:
            lst.append([])
        if not empty:
            if ordered:
                tup = lst[idx]
                jdx = sym.arguments[1].number
                while len(tup) &lt;= jdx:
                    tup.append(0)
                tup[jdx] = sym.arguments[2].number
            else:
                lst[idx].append(sym.arguments[1].number)
        return True
    return False


class ReifiedTheory:
    &#34;&#34;&#34;
    Class indexing the symbols related to a theory.

    The `ReifiedTheoryTerm`, `ReifiedTheoryElement`, and `ReifiedTheoryElement`
    classes provide views on this data that behave as the corresponding classes
    in clingo&#39;s `clingo.theory_atoms` module.
    &#34;&#34;&#34;

    terms: List[Symbol]
    elements: List[Symbol]
    atoms: List[Symbol]
    term_tuples: List[List[int]]
    element_tuples: List[List[int]]

    def __init__(self, symbols: Sequence[Symbol]):
        self.terms = []
        self.elements = []
        self.atoms = []
        self.term_tuples = []
        self.element_tuples = []

        for sym in symbols:
            _ = (
                _set(((&#34;theory_atom&#34;, 3), (&#34;theory_atom&#34;, 5)), self.atoms, sym, True)
                or _set(((&#34;theory_element&#34;, 3),), self.elements, sym)
                or _set(
                    (
                        (&#34;theory_sequence&#34;, 3),
                        (&#34;theory_string&#34;, 2),
                        (&#34;theory_number&#34;, 2),
                        (&#34;theory_function&#34;, 3),
                    ),
                    self.terms,
                    sym,
                )
                or _ensure(&#34;theory_tuple&#34;, self.term_tuples, sym, True)
                or _ensure(&#34;theory_element_tuple&#34;, self.element_tuples, sym)
            )

    def __iter__(self) -&gt; Iterator[&#34;ReifiedTheoryAtom&#34;]:
        for idx in range(len(self.atoms)):
            yield ReifiedTheoryAtom(idx, self)


class ReifiedTheoryTerm:
    &#34;&#34;&#34;
    Class to represent theory terms.

    ReifiedTheory terms have a readable string representation, implement Python&#39;s rich
    comparison operators, and can be used as dictionary keys.
    &#34;&#34;&#34;

    _idx: int
    _theory: ReifiedTheory

    def __init__(self, idx: int, theory: ReifiedTheory):
        self._idx = idx
        self._theory = theory
        assert self.index &lt; len(theory.terms)

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;
        The index of the corresponding reified fact.
        &#34;&#34;&#34;
        return self._idx

    @property
    def _args(self) -&gt; Sequence[Symbol]:
        return self._theory.terms[self._idx].arguments

    @property
    def arguments(self) -&gt; List[&#34;ReifiedTheoryTerm&#34;]:
        &#34;&#34;&#34;
        The arguments of the term (for functions, tuples, list, and sets).
        &#34;&#34;&#34;
        assert self.type in (
            TheoryTermType.List,
            TheoryTermType.Set,
            TheoryTermType.Tuple,
            TheoryTermType.Function,
        )
        term_ids = self._theory.term_tuples[self._args[2].number]
        return [ReifiedTheoryTerm(term_id, self._theory) for term_id in term_ids]

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the term (for symbols and functions).
        &#34;&#34;&#34;
        assert self.type in (TheoryTermType.Symbol, TheoryTermType.Function)
        if self.type == TheoryTermType.Function:
            return self._theory.terms[self._args[1].number].arguments[1].string
        return self._args[1].string

    @property
    def number(self) -&gt; int:
        &#34;&#34;&#34;
        The numeric representation of the term (for numbers).
        &#34;&#34;&#34;
        assert self.type == TheoryTermType.Number
        return self._args[1].number

    @property
    def type(self) -&gt; TheoryTermType:
        &#34;&#34;&#34;
        The type of the theory term.
        &#34;&#34;&#34;
        name = self._theory.terms[self._idx].name
        if name == &#34;theory_number&#34;:
            return TheoryTermType.Number
        if name == &#34;theory_string&#34;:
            return TheoryTermType.Symbol
        if name == &#34;theory_function&#34;:
            return TheoryTermType.Function
        assert name == &#34;theory_sequence&#34;
        type_ = self._args[1].name
        if type_ == &#34;tuple&#34;:
            return TheoryTermType.Tuple
        if type_ == &#34;set&#34;:
            return TheoryTermType.Set
        assert type_ == &#34;list&#34;
        return TheoryTermType.List

    def __hash__(self):
        return self._idx

    def __eq__(self, other):
        return self._idx == other._idx

    def __lt__(self, other):
        return self._idx &lt; other._idx

    def __str__(self):
        type_ = self.type

        if type_ == TheoryTermType.Number:
            return f&#34;{self.number}&#34;

        if type_ == TheoryTermType.Symbol:
            return f&#34;{self.name}&#34;

        if type_ == TheoryTermType.Function:
            args = self.arguments
            name = self.name
            if len(args) == 1 and is_operator(name):
                return f&#34;{name}({args[0]})&#34;
            if len(args) == 2 and is_operator(name):
                return f&#34;({args[0]}){name}({args[1]})&#34;
            return f&#39;{name}({&#34;,&#34;.join(str(arg) for arg in args)})&#39;

        if type_ == TheoryTermType.Tuple:
            lhs, rhs = &#34;(&#34;, &#34;)&#34;
        elif type_ == TheoryTermType.List:
            lhs, rhs = &#34;[&#34;, &#34;]&#34;
        else:
            lhs, rhs = &#34;{&#34;, &#34;}&#34;
        return f&#39;{lhs}{&#34;,&#34;.join(str(arg) for arg in self.arguments)}{rhs}&#39;


class ReifiedTheoryElement:
    &#34;&#34;&#34;
    Class to represent theory elements.

    ReifiedTheory elements have a readable string representation, implement Python&#39;s
    rich comparison operators, and can be used as dictionary keys.
    &#34;&#34;&#34;

    _idx: int
    _theory: ReifiedTheory

    def __init__(self, idx: int, theory: ReifiedTheory):
        self._idx = idx
        self._theory = theory
        assert self.index &lt; len(theory.elements)

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;
        The index of the corresponding reified fact.
        &#34;&#34;&#34;
        return self._idx

    @property
    def _args(self) -&gt; Sequence[Symbol]:
        return self._theory.elements[self._idx].arguments

    @property
    def condition_id(self) -&gt; int:
        &#34;&#34;&#34;
        The id of the literal tuple of the condition.
        &#34;&#34;&#34;
        return self._args[2].number

    @property
    def terms(self) -&gt; List[ReifiedTheoryTerm]:
        &#34;&#34;&#34;
        The tuple of the element.
        &#34;&#34;&#34;
        term_ids = self._theory.term_tuples[self._args[1].number]
        return [ReifiedTheoryTerm(term_id, self._theory) for term_id in term_ids]

    def __hash__(self):
        return self._idx

    def __eq__(self, other):
        return self._idx == other._idx

    def __lt__(self, other):
        return self._idx &lt; other._idx

    def __str__(self):
        return f&#39;{&#34;,&#34;.join(str(term) for term in self.terms)}: literal_tuple({self.condition_id})&#39;


class ReifiedTheoryAtom:
    &#34;&#34;&#34;
    Class to represent theory atoms.

    Theory atoms have a readable string representation, implement Python&#39;s rich
    comparison operators, and can be used as dictionary keys.
    &#34;&#34;&#34;

    _idx: int
    _theory: ReifiedTheory

    def __init__(self, idx: int, theory: ReifiedTheory):
        self._idx = idx
        self._theory = theory
        assert self.index &lt; len(theory.atoms)

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;
        The index of the corresponding reified fact.
        &#34;&#34;&#34;
        return self._idx

    @property
    def _args(self) -&gt; Sequence[Symbol]:
        return self._theory.atoms[self._idx].arguments

    @property
    def elements(self) -&gt; List[ReifiedTheoryElement]:
        &#34;&#34;&#34;
        The elements of the atom.
        &#34;&#34;&#34;
        tuple_id = self._args[2].number
        return [
            ReifiedTheoryElement(elem_id, self._theory)
            for elem_id in self._theory.element_tuples[tuple_id]
        ]

    @property
    def guard(self) -&gt; Optional[Tuple[str, ReifiedTheoryTerm]]:
        &#34;&#34;&#34;
        The guard of the atom or None if the atom has no guard.
        &#34;&#34;&#34;
        args = self._args
        if len(args) &lt;= 3:
            return None

        op = self._theory.terms[args[3].number].arguments[1].string
        return (op, ReifiedTheoryTerm(args[4].number, self._theory))

    @property
    def literal(self) -&gt; int:
        &#34;&#34;&#34;
        The reified literal associated with the atom.
        &#34;&#34;&#34;
        return self._args[0].number

    @property
    def term(self) -&gt; ReifiedTheoryTerm:
        &#34;&#34;&#34;
        The term of the atom.
        &#34;&#34;&#34;
        return ReifiedTheoryTerm(self._args[1].number, self._theory)

    def __hash__(self):
        return self._idx

    def __eq__(self, other):
        return self._idx == other._idx

    def __lt__(self, other):
        return self._idx &lt; other._idx

    def __str__(self):
        name = f&#34;&amp;{self.term}&#34;

        elems = self.elements
        if elems:
            estr = f&#39; {{ {&#34;; &#34;.join(str(elem) for elem in elems)} }}&#39;
        else:
            estr = &#34;&#34;

        guard = self.guard
        if guard:
            gstr = f&#34; {guard[0]} {guard[1]}&#34;
        else:
            gstr = &#34;&#34;

        return f&#34;{name}{estr}{gstr}&#34;


def reify_program(
    prg: str, calculate_sccs: bool = False, reify_steps: bool = False
) -&gt; List[Symbol]:
    &#34;&#34;&#34;
    Reify the given program and return the reified symbols.

    Parameters
    ----------
    prg
        The program to reify in form of a string.
    calculate_sccs
        Whether to calculate SCCs of the reified program.
    reify_steps
        Whether to add a step number to the reified facts.

    Returns
    -------
    A list of symbols containing the reified facts.
    &#34;&#34;&#34;
    ret: List[Symbol] = []
    ctl = Control()
    reifier = Reifier(ret.append, calculate_sccs, reify_steps)
    ctl.register_observer(reifier)
    ctl.add(&#34;base&#34;, [], prg)
    ctl.ground([(&#34;base&#34;, [])])
    if calculate_sccs and not reify_steps:
        reifier.calculate_sccs()

    return ret</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clingox.reify.reify_program"><code class="name flex">
<span>def <span class="ident">reify_program</span></span>(<span>prg:Â str, calculate_sccs:Â boolÂ =Â False, reify_steps:Â boolÂ =Â False) â€‘>Â List[<a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Reify the given program and return the reified symbols.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prg</code></strong></dt>
<dd>The program to reify in form of a string.</dd>
<dt><strong><code>calculate_sccs</code></strong></dt>
<dd>Whether to calculate SCCs of the reified program.</dd>
<dt><strong><code>reify_steps</code></strong></dt>
<dd>Whether to add a step number to the reified facts.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of symbols containing the reified facts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reify_program(
    prg: str, calculate_sccs: bool = False, reify_steps: bool = False
) -&gt; List[Symbol]:
    &#34;&#34;&#34;
    Reify the given program and return the reified symbols.

    Parameters
    ----------
    prg
        The program to reify in form of a string.
    calculate_sccs
        Whether to calculate SCCs of the reified program.
    reify_steps
        Whether to add a step number to the reified facts.

    Returns
    -------
    A list of symbols containing the reified facts.
    &#34;&#34;&#34;
    ret: List[Symbol] = []
    ctl = Control()
    reifier = Reifier(ret.append, calculate_sccs, reify_steps)
    ctl.register_observer(reifier)
    ctl.add(&#34;base&#34;, [], prg)
    ctl.ground([(&#34;base&#34;, [])])
    if calculate_sccs and not reify_steps:
        reifier.calculate_sccs()

    return ret</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingox.reify.ReifiedTheory"><code class="flex name class">
<span>class <span class="ident">ReifiedTheory</span></span>
<span>(</span><span>symbols:Â Sequence[<a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Class indexing the symbols related to a theory.</p>
<p>The <code><a title="clingox.reify.ReifiedTheoryTerm" href="#clingox.reify.ReifiedTheoryTerm">ReifiedTheoryTerm</a></code>, <code><a title="clingox.reify.ReifiedTheoryElement" href="#clingox.reify.ReifiedTheoryElement">ReifiedTheoryElement</a></code>, and <code><a title="clingox.reify.ReifiedTheoryElement" href="#clingox.reify.ReifiedTheoryElement">ReifiedTheoryElement</a></code>
classes provide views on this data that behave as the corresponding classes
in clingo's <code><a title="clingo.theory_atoms" href="../clingo/theory_atoms.html">clingo.theory_atoms</a></code> module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReifiedTheory:
    &#34;&#34;&#34;
    Class indexing the symbols related to a theory.

    The `ReifiedTheoryTerm`, `ReifiedTheoryElement`, and `ReifiedTheoryElement`
    classes provide views on this data that behave as the corresponding classes
    in clingo&#39;s `clingo.theory_atoms` module.
    &#34;&#34;&#34;

    terms: List[Symbol]
    elements: List[Symbol]
    atoms: List[Symbol]
    term_tuples: List[List[int]]
    element_tuples: List[List[int]]

    def __init__(self, symbols: Sequence[Symbol]):
        self.terms = []
        self.elements = []
        self.atoms = []
        self.term_tuples = []
        self.element_tuples = []

        for sym in symbols:
            _ = (
                _set(((&#34;theory_atom&#34;, 3), (&#34;theory_atom&#34;, 5)), self.atoms, sym, True)
                or _set(((&#34;theory_element&#34;, 3),), self.elements, sym)
                or _set(
                    (
                        (&#34;theory_sequence&#34;, 3),
                        (&#34;theory_string&#34;, 2),
                        (&#34;theory_number&#34;, 2),
                        (&#34;theory_function&#34;, 3),
                    ),
                    self.terms,
                    sym,
                )
                or _ensure(&#34;theory_tuple&#34;, self.term_tuples, sym, True)
                or _ensure(&#34;theory_element_tuple&#34;, self.element_tuples, sym)
            )

    def __iter__(self) -&gt; Iterator[&#34;ReifiedTheoryAtom&#34;]:
        for idx in range(len(self.atoms)):
            yield ReifiedTheoryAtom(idx, self)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="clingox.reify.ReifiedTheory.atoms"><code class="name">var <span class="ident">atoms</span> :Â List[<a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingox.reify.ReifiedTheory.element_tuples"><code class="name">var <span class="ident">element_tuples</span> :Â List[List[int]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingox.reify.ReifiedTheory.elements"><code class="name">var <span class="ident">elements</span> :Â List[<a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingox.reify.ReifiedTheory.term_tuples"><code class="name">var <span class="ident">term_tuples</span> :Â List[List[int]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingox.reify.ReifiedTheory.terms"><code class="name">var <span class="ident">terms</span> :Â List[<a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="clingox.reify.ReifiedTheoryAtom"><code class="flex name class">
<span>class <span class="ident">ReifiedTheoryAtom</span></span>
<span>(</span><span>idx:Â int, theory:Â <a title="clingox.reify.ReifiedTheory" href="#clingox.reify.ReifiedTheory">ReifiedTheory</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent theory atoms.</p>
<p>Theory atoms have a readable string representation, implement Python's rich
comparison operators, and can be used as dictionary keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReifiedTheoryAtom:
    &#34;&#34;&#34;
    Class to represent theory atoms.

    Theory atoms have a readable string representation, implement Python&#39;s rich
    comparison operators, and can be used as dictionary keys.
    &#34;&#34;&#34;

    _idx: int
    _theory: ReifiedTheory

    def __init__(self, idx: int, theory: ReifiedTheory):
        self._idx = idx
        self._theory = theory
        assert self.index &lt; len(theory.atoms)

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;
        The index of the corresponding reified fact.
        &#34;&#34;&#34;
        return self._idx

    @property
    def _args(self) -&gt; Sequence[Symbol]:
        return self._theory.atoms[self._idx].arguments

    @property
    def elements(self) -&gt; List[ReifiedTheoryElement]:
        &#34;&#34;&#34;
        The elements of the atom.
        &#34;&#34;&#34;
        tuple_id = self._args[2].number
        return [
            ReifiedTheoryElement(elem_id, self._theory)
            for elem_id in self._theory.element_tuples[tuple_id]
        ]

    @property
    def guard(self) -&gt; Optional[Tuple[str, ReifiedTheoryTerm]]:
        &#34;&#34;&#34;
        The guard of the atom or None if the atom has no guard.
        &#34;&#34;&#34;
        args = self._args
        if len(args) &lt;= 3:
            return None

        op = self._theory.terms[args[3].number].arguments[1].string
        return (op, ReifiedTheoryTerm(args[4].number, self._theory))

    @property
    def literal(self) -&gt; int:
        &#34;&#34;&#34;
        The reified literal associated with the atom.
        &#34;&#34;&#34;
        return self._args[0].number

    @property
    def term(self) -&gt; ReifiedTheoryTerm:
        &#34;&#34;&#34;
        The term of the atom.
        &#34;&#34;&#34;
        return ReifiedTheoryTerm(self._args[1].number, self._theory)

    def __hash__(self):
        return self._idx

    def __eq__(self, other):
        return self._idx == other._idx

    def __lt__(self, other):
        return self._idx &lt; other._idx

    def __str__(self):
        name = f&#34;&amp;{self.term}&#34;

        elems = self.elements
        if elems:
            estr = f&#39; {{ {&#34;; &#34;.join(str(elem) for elem in elems)} }}&#39;
        else:
            estr = &#34;&#34;

        guard = self.guard
        if guard:
            gstr = f&#34; {guard[0]} {guard[1]}&#34;
        else:
            gstr = &#34;&#34;

        return f&#34;{name}{estr}{gstr}&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.reify.ReifiedTheoryAtom.elements"><code class="name">var <span class="ident">elements</span> :Â List[<a title="clingox.reify.ReifiedTheoryElement" href="#clingox.reify.ReifiedTheoryElement">ReifiedTheoryElement</a>]</code></dt>
<dd>
<div class="desc"><p>The elements of the atom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self) -&gt; List[ReifiedTheoryElement]:
    &#34;&#34;&#34;
    The elements of the atom.
    &#34;&#34;&#34;
    tuple_id = self._args[2].number
    return [
        ReifiedTheoryElement(elem_id, self._theory)
        for elem_id in self._theory.element_tuples[tuple_id]
    ]</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryAtom.guard"><code class="name">var <span class="ident">guard</span> :Â Optional[Tuple[str,Â <a title="clingox.reify.ReifiedTheoryTerm" href="#clingox.reify.ReifiedTheoryTerm">ReifiedTheoryTerm</a>]]</code></dt>
<dd>
<div class="desc"><p>The guard of the atom or None if the atom has no guard.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def guard(self) -&gt; Optional[Tuple[str, ReifiedTheoryTerm]]:
    &#34;&#34;&#34;
    The guard of the atom or None if the atom has no guard.
    &#34;&#34;&#34;
    args = self._args
    if len(args) &lt;= 3:
        return None

    op = self._theory.terms[args[3].number].arguments[1].string
    return (op, ReifiedTheoryTerm(args[4].number, self._theory))</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryAtom.index"><code class="name">var <span class="ident">index</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The index of the corresponding reified fact.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def index(self) -&gt; int:
    &#34;&#34;&#34;
    The index of the corresponding reified fact.
    &#34;&#34;&#34;
    return self._idx</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryAtom.literal"><code class="name">var <span class="ident">literal</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The reified literal associated with the atom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def literal(self) -&gt; int:
    &#34;&#34;&#34;
    The reified literal associated with the atom.
    &#34;&#34;&#34;
    return self._args[0].number</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryAtom.term"><code class="name">var <span class="ident">term</span> :Â <a title="clingox.reify.ReifiedTheoryTerm" href="#clingox.reify.ReifiedTheoryTerm">ReifiedTheoryTerm</a></code></dt>
<dd>
<div class="desc"><p>The term of the atom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def term(self) -&gt; ReifiedTheoryTerm:
    &#34;&#34;&#34;
    The term of the atom.
    &#34;&#34;&#34;
    return ReifiedTheoryTerm(self._args[1].number, self._theory)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingox.reify.ReifiedTheoryElement"><code class="flex name class">
<span>class <span class="ident">ReifiedTheoryElement</span></span>
<span>(</span><span>idx:Â int, theory:Â <a title="clingox.reify.ReifiedTheory" href="#clingox.reify.ReifiedTheory">ReifiedTheory</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent theory elements.</p>
<p>ReifiedTheory elements have a readable string representation, implement Python's
rich comparison operators, and can be used as dictionary keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReifiedTheoryElement:
    &#34;&#34;&#34;
    Class to represent theory elements.

    ReifiedTheory elements have a readable string representation, implement Python&#39;s
    rich comparison operators, and can be used as dictionary keys.
    &#34;&#34;&#34;

    _idx: int
    _theory: ReifiedTheory

    def __init__(self, idx: int, theory: ReifiedTheory):
        self._idx = idx
        self._theory = theory
        assert self.index &lt; len(theory.elements)

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;
        The index of the corresponding reified fact.
        &#34;&#34;&#34;
        return self._idx

    @property
    def _args(self) -&gt; Sequence[Symbol]:
        return self._theory.elements[self._idx].arguments

    @property
    def condition_id(self) -&gt; int:
        &#34;&#34;&#34;
        The id of the literal tuple of the condition.
        &#34;&#34;&#34;
        return self._args[2].number

    @property
    def terms(self) -&gt; List[ReifiedTheoryTerm]:
        &#34;&#34;&#34;
        The tuple of the element.
        &#34;&#34;&#34;
        term_ids = self._theory.term_tuples[self._args[1].number]
        return [ReifiedTheoryTerm(term_id, self._theory) for term_id in term_ids]

    def __hash__(self):
        return self._idx

    def __eq__(self, other):
        return self._idx == other._idx

    def __lt__(self, other):
        return self._idx &lt; other._idx

    def __str__(self):
        return f&#39;{&#34;,&#34;.join(str(term) for term in self.terms)}: literal_tuple({self.condition_id})&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.reify.ReifiedTheoryElement.condition_id"><code class="name">var <span class="ident">condition_id</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The id of the literal tuple of the condition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def condition_id(self) -&gt; int:
    &#34;&#34;&#34;
    The id of the literal tuple of the condition.
    &#34;&#34;&#34;
    return self._args[2].number</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryElement.index"><code class="name">var <span class="ident">index</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The index of the corresponding reified fact.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def index(self) -&gt; int:
    &#34;&#34;&#34;
    The index of the corresponding reified fact.
    &#34;&#34;&#34;
    return self._idx</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryElement.terms"><code class="name">var <span class="ident">terms</span> :Â List[<a title="clingox.reify.ReifiedTheoryTerm" href="#clingox.reify.ReifiedTheoryTerm">ReifiedTheoryTerm</a>]</code></dt>
<dd>
<div class="desc"><p>The tuple of the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def terms(self) -&gt; List[ReifiedTheoryTerm]:
    &#34;&#34;&#34;
    The tuple of the element.
    &#34;&#34;&#34;
    term_ids = self._theory.term_tuples[self._args[1].number]
    return [ReifiedTheoryTerm(term_id, self._theory) for term_id in term_ids]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingox.reify.ReifiedTheoryTerm"><code class="flex name class">
<span>class <span class="ident">ReifiedTheoryTerm</span></span>
<span>(</span><span>idx:Â int, theory:Â <a title="clingox.reify.ReifiedTheory" href="#clingox.reify.ReifiedTheory">ReifiedTheory</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent theory terms.</p>
<p>ReifiedTheory terms have a readable string representation, implement Python's rich
comparison operators, and can be used as dictionary keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReifiedTheoryTerm:
    &#34;&#34;&#34;
    Class to represent theory terms.

    ReifiedTheory terms have a readable string representation, implement Python&#39;s rich
    comparison operators, and can be used as dictionary keys.
    &#34;&#34;&#34;

    _idx: int
    _theory: ReifiedTheory

    def __init__(self, idx: int, theory: ReifiedTheory):
        self._idx = idx
        self._theory = theory
        assert self.index &lt; len(theory.terms)

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;
        The index of the corresponding reified fact.
        &#34;&#34;&#34;
        return self._idx

    @property
    def _args(self) -&gt; Sequence[Symbol]:
        return self._theory.terms[self._idx].arguments

    @property
    def arguments(self) -&gt; List[&#34;ReifiedTheoryTerm&#34;]:
        &#34;&#34;&#34;
        The arguments of the term (for functions, tuples, list, and sets).
        &#34;&#34;&#34;
        assert self.type in (
            TheoryTermType.List,
            TheoryTermType.Set,
            TheoryTermType.Tuple,
            TheoryTermType.Function,
        )
        term_ids = self._theory.term_tuples[self._args[2].number]
        return [ReifiedTheoryTerm(term_id, self._theory) for term_id in term_ids]

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        The name of the term (for symbols and functions).
        &#34;&#34;&#34;
        assert self.type in (TheoryTermType.Symbol, TheoryTermType.Function)
        if self.type == TheoryTermType.Function:
            return self._theory.terms[self._args[1].number].arguments[1].string
        return self._args[1].string

    @property
    def number(self) -&gt; int:
        &#34;&#34;&#34;
        The numeric representation of the term (for numbers).
        &#34;&#34;&#34;
        assert self.type == TheoryTermType.Number
        return self._args[1].number

    @property
    def type(self) -&gt; TheoryTermType:
        &#34;&#34;&#34;
        The type of the theory term.
        &#34;&#34;&#34;
        name = self._theory.terms[self._idx].name
        if name == &#34;theory_number&#34;:
            return TheoryTermType.Number
        if name == &#34;theory_string&#34;:
            return TheoryTermType.Symbol
        if name == &#34;theory_function&#34;:
            return TheoryTermType.Function
        assert name == &#34;theory_sequence&#34;
        type_ = self._args[1].name
        if type_ == &#34;tuple&#34;:
            return TheoryTermType.Tuple
        if type_ == &#34;set&#34;:
            return TheoryTermType.Set
        assert type_ == &#34;list&#34;
        return TheoryTermType.List

    def __hash__(self):
        return self._idx

    def __eq__(self, other):
        return self._idx == other._idx

    def __lt__(self, other):
        return self._idx &lt; other._idx

    def __str__(self):
        type_ = self.type

        if type_ == TheoryTermType.Number:
            return f&#34;{self.number}&#34;

        if type_ == TheoryTermType.Symbol:
            return f&#34;{self.name}&#34;

        if type_ == TheoryTermType.Function:
            args = self.arguments
            name = self.name
            if len(args) == 1 and is_operator(name):
                return f&#34;{name}({args[0]})&#34;
            if len(args) == 2 and is_operator(name):
                return f&#34;({args[0]}){name}({args[1]})&#34;
            return f&#39;{name}({&#34;,&#34;.join(str(arg) for arg in args)})&#39;

        if type_ == TheoryTermType.Tuple:
            lhs, rhs = &#34;(&#34;, &#34;)&#34;
        elif type_ == TheoryTermType.List:
            lhs, rhs = &#34;[&#34;, &#34;]&#34;
        else:
            lhs, rhs = &#34;{&#34;, &#34;}&#34;
        return f&#39;{lhs}{&#34;,&#34;.join(str(arg) for arg in self.arguments)}{rhs}&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.reify.ReifiedTheoryTerm.arguments"><code class="name">var <span class="ident">arguments</span> :Â List[<a title="clingox.reify.ReifiedTheoryTerm" href="#clingox.reify.ReifiedTheoryTerm">ReifiedTheoryTerm</a>]</code></dt>
<dd>
<div class="desc"><p>The arguments of the term (for functions, tuples, list, and sets).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def arguments(self) -&gt; List[&#34;ReifiedTheoryTerm&#34;]:
    &#34;&#34;&#34;
    The arguments of the term (for functions, tuples, list, and sets).
    &#34;&#34;&#34;
    assert self.type in (
        TheoryTermType.List,
        TheoryTermType.Set,
        TheoryTermType.Tuple,
        TheoryTermType.Function,
    )
    term_ids = self._theory.term_tuples[self._args[2].number]
    return [ReifiedTheoryTerm(term_id, self._theory) for term_id in term_ids]</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryTerm.index"><code class="name">var <span class="ident">index</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The index of the corresponding reified fact.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def index(self) -&gt; int:
    &#34;&#34;&#34;
    The index of the corresponding reified fact.
    &#34;&#34;&#34;
    return self._idx</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryTerm.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The name of the term (for symbols and functions).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    The name of the term (for symbols and functions).
    &#34;&#34;&#34;
    assert self.type in (TheoryTermType.Symbol, TheoryTermType.Function)
    if self.type == TheoryTermType.Function:
        return self._theory.terms[self._args[1].number].arguments[1].string
    return self._args[1].string</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryTerm.number"><code class="name">var <span class="ident">number</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The numeric representation of the term (for numbers).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number(self) -&gt; int:
    &#34;&#34;&#34;
    The numeric representation of the term (for numbers).
    &#34;&#34;&#34;
    assert self.type == TheoryTermType.Number
    return self._args[1].number</code></pre>
</details>
</dd>
<dt id="clingox.reify.ReifiedTheoryTerm.type"><code class="name">var <span class="ident">type</span> :Â <a title="clingo.theory_atoms.TheoryTermType" href="../clingo/theory_atoms.html#clingo.theory_atoms.TheoryTermType">TheoryTermType</a></code></dt>
<dd>
<div class="desc"><p>The type of the theory term.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; TheoryTermType:
    &#34;&#34;&#34;
    The type of the theory term.
    &#34;&#34;&#34;
    name = self._theory.terms[self._idx].name
    if name == &#34;theory_number&#34;:
        return TheoryTermType.Number
    if name == &#34;theory_string&#34;:
        return TheoryTermType.Symbol
    if name == &#34;theory_function&#34;:
        return TheoryTermType.Function
    assert name == &#34;theory_sequence&#34;
    type_ = self._args[1].name
    if type_ == &#34;tuple&#34;:
        return TheoryTermType.Tuple
    if type_ == &#34;set&#34;:
        return TheoryTermType.Set
    assert type_ == &#34;list&#34;
    return TheoryTermType.List</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingox.reify.Reifier"><code class="flex name class">
<span>class <span class="ident">Reifier</span></span>
<span>(</span><span>cb:Â Callable[[<a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>],Â None], calculate_sccs:Â boolÂ =Â False, reify_steps:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>An observer that will gather the symbols of the reification, in the same way as <code>clingo --output=reify</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cb</code></strong></dt>
<dd>A callback function that will be called with each symbol of the reification</dd>
<dt><strong><code>calculate_sccs</code></strong></dt>
<dd>Flag to calculate the SCCs</dd>
<dt><strong><code>reify_steps</code></strong></dt>
<dd>Flag to add a number as the last argument of all reification symbols for the corresponding step</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reifier(Observer):
    &#34;&#34;&#34;
    An observer that will gather the symbols of the reification, in the same way as `clingo --output=reify`.

    Parameters
    ----------
    cb
        A callback function that will be called with each symbol of the reification
    calculate_sccs
        Flag to calculate the SCCs
    reify_steps
        Flag to add a number as the last argument of all reification symbols for the corresponding step

    &#34;&#34;&#34;

    # pylint:disable=too-many-public-methods
    _step: int
    # Bug in mypy???
    # _cb: Callable[[Symbol], None]
    _calculate_sccs: bool
    _reify_steps: bool
    _step_data: _StepData

    def __init__(
        self,
        cb: Callable[[Symbol], None],
        calculate_sccs: bool = False,
        reify_steps: bool = False,
    ):
        self._step = 0
        self._cb = cb
        self._calculate_sccs = calculate_sccs
        self._reify_steps = reify_steps
        self._step_data = _StepData()

    def calculate_sccs(self) -&gt; None:
        &#34;&#34;&#34;
        Trigger computation of SCCs.

        SCCs can only be computed if the Reifier has been initialized with
        `calculate_sccs=True`, This function is called automatically if
        `reify_steps=True` has been set when initializing the Reifier.
        &#34;&#34;&#34;
        for idx, scc in enumerate(self._step_data.graph.tarjan()):
            for atm in scc:
                self._output(&#34;scc&#34;, [Number(idx), Number(atm)])

    def _add_edges(self, head: Sequence[int], body: Sequence[int]):
        if self._calculate_sccs:
            for u in head:
                for v in body:
                    if v &gt; 0:
                        self._step_data.graph.add_edge(u, v)

    def _output(self, name: str, args: Sequence[Symbol]):
        if self._reify_steps:
            args = list(args) + [Number(self._step)]
        self._cb(Function(name, args))

    def _tuple(
        self,
        name: str,
        snmap: Dict[Sequence[U], int],
        elems: Sequence[U],
        afun: Callable[[Symbol, int, U], Sequence[Symbol]],
        ordered: bool = False,
    ) -&gt; Symbol:
        pruned: Sequence[U]
        if ordered:
            pruned = elems
            ident = tuple(elems)
        else:
            seen: Set[U] = set()
            pruned = []
            for elem in elems:
                if elem not in seen:
                    seen.add(elem)
                    pruned.append(elem)
            ident = tuple(sorted(pruned))

        n = len(snmap)
        i = Number(snmap.setdefault(ident, n))
        if n == i.number:
            self._output(name, [i])
            for idx, atm in enumerate(pruned):
                self._output(name, afun(i, idx, atm))
        return i

    def _atom_tuple(self, atoms: Sequence[int]):
        return self._tuple(&#34;atom_tuple&#34;, self._step_data.atom_tuples, atoms, _lit)

    def _lit_tuple(self, lits: Sequence[int]):
        return self._tuple(&#34;literal_tuple&#34;, self._step_data.lit_tuples, lits, _lit)

    def _wlit_tuple(self, wlits: Sequence[Tuple[int, int]]):
        return self._tuple(
            &#34;weighted_literal_tuple&#34;, self._step_data.wlit_tuples, wlits, _wlit
        )

    def init_program(self, incremental: bool) -&gt; None:
        if incremental:
            self._cb(Function(&#34;tag&#34;, [Function(&#34;incremental&#34;)]))

    def begin_step(self) -&gt; None:
        pass

    def rule(self, choice: bool, head: Sequence[int], body: Sequence[int]) -&gt; None:
        hn = &#34;choice&#34; if choice else &#34;disjunction&#34;
        hd = Function(hn, [self._atom_tuple(head)])
        bd = Function(&#34;normal&#34;, [self._lit_tuple(body)])
        self._output(&#34;rule&#34;, [hd, bd])
        self._add_edges(head, body)

    def weight_rule(
        self,
        choice: bool,
        head: Sequence[int],
        lower_bound: int,
        body: Sequence[Tuple[int, int]],
    ) -&gt; None:
        hn = &#34;choice&#34; if choice else &#34;disjunction&#34;
        hd = Function(hn, [self._atom_tuple(head)])
        bd = Function(&#34;sum&#34;, [self._wlit_tuple(body), Number(lower_bound)])
        self._output(&#34;rule&#34;, [hd, bd])
        self._add_edges(head, [lit for lit, w in body])

    def minimize(self, priority: int, literals: Sequence[Tuple[int, int]]) -&gt; None:
        self._output(&#34;minimize&#34;, [Number(priority), self._wlit_tuple(literals)])

    def project(self, atoms: Sequence[int]) -&gt; None:
        for atom in atoms:
            self._output(&#34;project&#34;, [Number(atom)])

    def output_atom(self, symbol: Symbol, atom: int) -&gt; None:
        self._output(&#34;output&#34;, [symbol, self._lit_tuple([] if atom == 0 else [atom])])

    def output_term(self, symbol: Symbol, condition: Sequence[int]) -&gt; None:
        self._output(&#34;output&#34;, [symbol, self._lit_tuple(condition)])

    def external(self, atom: int, value: TruthValue) -&gt; None:
        value_name = str(value).replace(&#34;TruthValue.&#34;, &#34;&#34;).lower().rstrip(&#34;_&#34;)
        self._output(&#34;external&#34;, [Number(atom), Function(value_name)])

    def assume(self, literals: Sequence[int]) -&gt; None:
        for lit in literals:
            self._output(&#34;assume&#34;, [Number(lit)])

    def heuristic(
        self,
        atom: int,
        type_: HeuristicType,
        bias: int,
        priority: int,
        condition: Sequence[int],
    ) -&gt; None:
        type_name = str(type_).replace(&#34;HeuristicType.&#34;, &#34;&#34;).lower().rstrip(&#34;_&#34;)
        condition_lit = self._lit_tuple(condition)
        self._output(
            &#34;heuristic&#34;,
            [
                Number(atom),
                Function(type_name),
                Number(bias),
                Number(priority),
                condition_lit,
            ],
        )

    def acyc_edge(self, node_u: int, node_v: int, condition: Sequence[int]) -&gt; None:
        self._output(
            &#34;edge&#34;, [Number(node_u), Number(node_v), self._lit_tuple(condition)]
        )

    def theory_term_number(self, term_id: int, number: int) -&gt; None:
        self._output(&#34;theory_number&#34;, [Number(term_id), Number(number)])

    def theory_term_string(self, term_id: int, name: str) -&gt; None:
        self._output(&#34;theory_string&#34;, [Number(term_id), String(name)])

    def theory_term_compound(
        self, term_id: int, name_id_or_type: int, arguments: Sequence[int]
    ) -&gt; None:
        names = {-1: &#34;tuple&#34;, -2: &#34;set&#34;, -3: &#34;list&#34;}
        if name_id_or_type in names:
            name = &#34;theory_sequence&#34;
            value = Function(names[name_id_or_type])
        else:
            name = &#34;theory_function&#34;
            value = Number(name_id_or_type)
        tuple_id = self._tuple(
            &#34;theory_tuple&#34;, self._step_data.theory_tuples, arguments, _theory, True
        )
        self._output(name, [Number(term_id), value, tuple_id])

    def theory_element(
        self, element_id: int, terms: Sequence[int], condition: Sequence[int]
    ) -&gt; None:
        tuple_id = self._tuple(
            &#34;theory_tuple&#34;, self._step_data.theory_tuples, terms, _theory, True
        )
        condition_id = self._tuple(
            &#34;literal_tuple&#34;, self._step_data.lit_tuples, condition, _lit
        )
        self._output(&#34;theory_element&#34;, [Number(element_id), tuple_id, condition_id])

    def theory_atom(
        self, atom_id_or_zero: int, term_id: int, elements: Sequence[int]
    ) -&gt; None:
        tuple_e_id = self._tuple(
            &#34;theory_element_tuple&#34;,
            self._step_data.theory_element_tuples,
            elements,
            _lit,
        )
        self._output(
            &#34;theory_atom&#34;, [Number(atom_id_or_zero), Number(term_id), tuple_e_id]
        )

    def theory_atom_with_guard(
        self,
        atom_id_or_zero: int,
        term_id: int,
        elements: Sequence[int],
        operator_id: int,
        right_hand_side_id: int,
    ) -&gt; None:
        tuple_id = self._tuple(
            &#34;theory_element_tuple&#34;,
            self._step_data.theory_element_tuples,
            elements,
            _lit,
        )
        self._output(
            &#34;theory_atom&#34;,
            [
                Number(atom_id_or_zero),
                Number(term_id),
                tuple_id,
                Number(operator_id),
                Number(right_hand_side_id),
            ],
        )

    def end_step(self) -&gt; None:
        if self._reify_steps:
            self.calculate_sccs()
            self._step += 1
            self._step_data = _StepData()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clingo.backend.Observer" href="../clingo/backend.html#clingo.backend.Observer">Observer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingox.reify.Reifier.calculate_sccs"><code class="name flex">
<span>def <span class="ident">calculate_sccs</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Trigger computation of SCCs.</p>
<p>SCCs can only be computed if the Reifier has been initialized with
<code>calculate_sccs=True</code>, This function is called automatically if
<code>reify_steps=True</code> has been set when initializing the Reifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_sccs(self) -&gt; None:
    &#34;&#34;&#34;
    Trigger computation of SCCs.

    SCCs can only be computed if the Reifier has been initialized with
    `calculate_sccs=True`, This function is called automatically if
    `reify_steps=True` has been set when initializing the Reifier.
    &#34;&#34;&#34;
    for idx, scc in enumerate(self._step_data.graph.tarjan()):
        for atm in scc:
            self._output(&#34;scc&#34;, [Number(idx), Number(atm)])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clingo.backend.Observer" href="../clingo/backend.html#clingo.backend.Observer">Observer</a></b></code>:
<ul class="hlist">
<li><code><a title="clingo.backend.Observer.acyc_edge" href="../clingo/backend.html#clingo.backend.Observer.acyc_edge">acyc_edge</a></code></li>
<li><code><a title="clingo.backend.Observer.assume" href="../clingo/backend.html#clingo.backend.Observer.assume">assume</a></code></li>
<li><code><a title="clingo.backend.Observer.begin_step" href="../clingo/backend.html#clingo.backend.Observer.begin_step">begin_step</a></code></li>
<li><code><a title="clingo.backend.Observer.end_step" href="../clingo/backend.html#clingo.backend.Observer.end_step">end_step</a></code></li>
<li><code><a title="clingo.backend.Observer.external" href="../clingo/backend.html#clingo.backend.Observer.external">external</a></code></li>
<li><code><a title="clingo.backend.Observer.heuristic" href="../clingo/backend.html#clingo.backend.Observer.heuristic">heuristic</a></code></li>
<li><code><a title="clingo.backend.Observer.init_program" href="../clingo/backend.html#clingo.backend.Observer.init_program">init_program</a></code></li>
<li><code><a title="clingo.backend.Observer.minimize" href="../clingo/backend.html#clingo.backend.Observer.minimize">minimize</a></code></li>
<li><code><a title="clingo.backend.Observer.output_atom" href="../clingo/backend.html#clingo.backend.Observer.output_atom">output_atom</a></code></li>
<li><code><a title="clingo.backend.Observer.output_term" href="../clingo/backend.html#clingo.backend.Observer.output_term">output_term</a></code></li>
<li><code><a title="clingo.backend.Observer.project" href="../clingo/backend.html#clingo.backend.Observer.project">project</a></code></li>
<li><code><a title="clingo.backend.Observer.rule" href="../clingo/backend.html#clingo.backend.Observer.rule">rule</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_atom" href="../clingo/backend.html#clingo.backend.Observer.theory_atom">theory_atom</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_atom_with_guard" href="../clingo/backend.html#clingo.backend.Observer.theory_atom_with_guard">theory_atom_with_guard</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_element" href="../clingo/backend.html#clingo.backend.Observer.theory_element">theory_element</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_compound" href="../clingo/backend.html#clingo.backend.Observer.theory_term_compound">theory_term_compound</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_number" href="../clingo/backend.html#clingo.backend.Observer.theory_term_number">theory_term_number</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_string" href="../clingo/backend.html#clingo.backend.Observer.theory_term_string">theory_term_string</a></code></li>
<li><code><a title="clingo.backend.Observer.weight_rule" href="../clingo/backend.html#clingo.backend.Observer.weight_rule">weight_rule</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clingox" href="index.html">clingox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clingox.reify.reify_program" href="#clingox.reify.reify_program">reify_program</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingox.reify.ReifiedTheory" href="#clingox.reify.ReifiedTheory">ReifiedTheory</a></code></h4>
<ul class="">
<li><code><a title="clingox.reify.ReifiedTheory.atoms" href="#clingox.reify.ReifiedTheory.atoms">atoms</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheory.element_tuples" href="#clingox.reify.ReifiedTheory.element_tuples">element_tuples</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheory.elements" href="#clingox.reify.ReifiedTheory.elements">elements</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheory.term_tuples" href="#clingox.reify.ReifiedTheory.term_tuples">term_tuples</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheory.terms" href="#clingox.reify.ReifiedTheory.terms">terms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.reify.ReifiedTheoryAtom" href="#clingox.reify.ReifiedTheoryAtom">ReifiedTheoryAtom</a></code></h4>
<ul class="">
<li><code><a title="clingox.reify.ReifiedTheoryAtom.elements" href="#clingox.reify.ReifiedTheoryAtom.elements">elements</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryAtom.guard" href="#clingox.reify.ReifiedTheoryAtom.guard">guard</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryAtom.index" href="#clingox.reify.ReifiedTheoryAtom.index">index</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryAtom.literal" href="#clingox.reify.ReifiedTheoryAtom.literal">literal</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryAtom.term" href="#clingox.reify.ReifiedTheoryAtom.term">term</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.reify.ReifiedTheoryElement" href="#clingox.reify.ReifiedTheoryElement">ReifiedTheoryElement</a></code></h4>
<ul class="">
<li><code><a title="clingox.reify.ReifiedTheoryElement.condition_id" href="#clingox.reify.ReifiedTheoryElement.condition_id">condition_id</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryElement.index" href="#clingox.reify.ReifiedTheoryElement.index">index</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryElement.terms" href="#clingox.reify.ReifiedTheoryElement.terms">terms</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.reify.ReifiedTheoryTerm" href="#clingox.reify.ReifiedTheoryTerm">ReifiedTheoryTerm</a></code></h4>
<ul class="">
<li><code><a title="clingox.reify.ReifiedTheoryTerm.arguments" href="#clingox.reify.ReifiedTheoryTerm.arguments">arguments</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryTerm.index" href="#clingox.reify.ReifiedTheoryTerm.index">index</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryTerm.name" href="#clingox.reify.ReifiedTheoryTerm.name">name</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryTerm.number" href="#clingox.reify.ReifiedTheoryTerm.number">number</a></code></li>
<li><code><a title="clingox.reify.ReifiedTheoryTerm.type" href="#clingox.reify.ReifiedTheoryTerm.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.reify.Reifier" href="#clingox.reify.Reifier">Reifier</a></code></h4>
<ul class="">
<li><code><a title="clingox.reify.Reifier.calculate_sccs" href="#clingox.reify.Reifier.calculate_sccs">calculate_sccs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
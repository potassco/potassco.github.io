<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>clingox.program API documentation</title>
<meta name="description" content="This module provides functions to work with ground programs …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clingox.program</code></h1>
</header>
<section id="section-intro">
<p>This module provides functions to work with ground programs.</p>
<p>This includes constructing a ground representation using an observer, pretty
printing the ground representation, and adding ground program to control
objects via the backend.</p>
<h2 id="example">Example</h2>
<p>The following example shows how to:</p>
<ul>
<li>use the <code><a title="clingox.program.ProgramObserver" href="#clingox.program.ProgramObserver">ProgramObserver</a></code> to construct a <code><a title="clingox.program.Program" href="#clingox.program.Program">Program</a></code>, and</li>
<li>add it to another <code><a title="clingo.control.Control" href="../clingo/control.html#clingo.control.Control">Control</a></code> object.</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; from clingo.control import Control
&gt;&gt;&gt; from clingox.program import Program, ProgramObserver, Remapping
&gt;&gt;&gt;
&gt;&gt;&gt; prg = Program()
&gt;&gt;&gt; ctl_a = Control()
&gt;&gt;&gt; ctl_a.register_observer(ProgramObserver(prg))
&gt;&gt;&gt;
&gt;&gt;&gt; ctl_a.add('base', [], 'a. {b}. c :- b.')
&gt;&gt;&gt; ctl_a.ground([('base', [])])
&gt;&gt;&gt; print(prg)
a.
__x1.
c :- b.
{b}.
&gt;&gt;&gt;
&gt;&gt;&gt; ctl_b = Control(['0'])
&gt;&gt;&gt; with ctl_b.backend() as backend:
...     mapping = Remapping(backend, prg.output_atoms, prg.facts)
...     prg.add_to_backend(backend, mapping)
...
&gt;&gt;&gt; ctl_b.solve(on_model=print)
a
b c a
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides functions to work with ground programs.

This includes constructing a ground representation using an observer, pretty
printing the ground representation, and adding ground program to control
objects via the backend.

Example
-------

The following example shows how to:

- use the `ProgramObserver` to construct a `Program`, and
- add it to another `clingo.control.Control` object.

```python-repl
&gt;&gt;&gt; from clingo.control import Control
&gt;&gt;&gt; from clingox.program import Program, ProgramObserver, Remapping
&gt;&gt;&gt;
&gt;&gt;&gt; prg = Program()
&gt;&gt;&gt; ctl_a = Control()
&gt;&gt;&gt; ctl_a.register_observer(ProgramObserver(prg))
&gt;&gt;&gt;
&gt;&gt;&gt; ctl_a.add(&#39;base&#39;, [], &#39;a. {b}. c :- b.&#39;)
&gt;&gt;&gt; ctl_a.ground([(&#39;base&#39;, [])])
&gt;&gt;&gt; print(prg)
a.
__x1.
c :- b.
{b}.
&gt;&gt;&gt;
&gt;&gt;&gt; ctl_b = Control([&#39;0&#39;])
&gt;&gt;&gt; with ctl_b.backend() as backend:
...     mapping = Remapping(backend, prg.output_atoms, prg.facts)
...     prg.add_to_backend(backend, mapping)
...
&gt;&gt;&gt; ctl_b.solve(on_model=print)
a
b c a
```
&#34;&#34;&#34;

from copy import copy
from dataclasses import dataclass, field
from functools import singledispatch
from itertools import chain
from typing import (
    Callable,
    Iterable,
    List,
    Mapping,
    MutableMapping,
    MutableSequence,
    NamedTuple,
    Optional,
    Sequence,
    Tuple,
    TypeVar,
)

from clingo import Backend, HeuristicType, Observer, Symbol, TruthValue

__all__ = [
    &#34;add_to_backend&#34;,
    &#34;pretty_str&#34;,
    &#34;remap&#34;,
    &#34;Edge&#34;,
    &#34;External&#34;,
    &#34;Fact&#34;,
    &#34;Heuristic&#34;,
    &#34;Minimize&#34;,
    &#34;Program&#34;,
    &#34;ProgramObserver&#34;,
    &#34;Project&#34;,
    &#34;Remapping&#34;,
    &#34;Rule&#34;,
    &#34;Show&#34;,
    &#34;WeightRule&#34;,
]
__pdoc__ = {}

Atom = int
Literal = int
Weight = int
OutputTable = Mapping[Atom, Symbol]
AtomMap = Callable[[Atom], Atom]
Statement = TypeVar(
    &#34;Statement&#34;,
    &#34;Fact&#34;,
    &#34;Show&#34;,
    &#34;Rule&#34;,
    &#34;WeightRule&#34;,
    &#34;Heuristic&#34;,
    &#34;Edge&#34;,
    &#34;Minimize&#34;,
    &#34;External&#34;,
    &#34;Project&#34;,
)


@singledispatch
def pretty_str(stm, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print statements.

    Parameters
    ----------
    stm
        The statement to convert to a string.
    output_atoms
        A mapping from program atoms to symbols.

    Returns
    -------
    The string representation of the statement.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;


@singledispatch
def remap(stm, mapping: AtomMap):
    &#34;&#34;&#34;
    Remap literals in the given statement with the provided mapping.

    Parameters
    ----------
    stm
        The statement to remap.
    mapping
        The mapping function to remap literals.

    Returns
    -------
    The updated statement.

    See Also
    --------
    Remapping
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;


@singledispatch
def add_to_backend(stm, backend: Backend):
    &#34;&#34;&#34;
    Add statements to the backend using the provided mapping to map literals.

    Parameters
    ----------
    stm
        The statement to add to the backend.
    backend
        The backend.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;


def _pretty_str_lit(stm: Literal, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print literals and atoms.
    &#34;&#34;&#34;
    atom = abs(stm)
    if atom in output_atoms:
        atom_str = str(output_atoms[atom])
    else:
        atom_str = f&#34;__x{atom}&#34;

    return f&#34;not {atom_str}&#34; if stm &lt; 0 else atom_str


def _pretty_str_rule_head(
    choice: bool, has_body: bool, head: Sequence[Atom], output_atoms: OutputTable
) -&gt; str:
    &#34;&#34;&#34;
    Pretty print the head of a rule including the implication symbol if
    necessary.
    &#34;&#34;&#34;
    ret = &#34;&#34;

    if choice:
        ret += &#34;{&#34;
    ret += &#34;; &#34;.join(_pretty_str_lit(lit, output_atoms) for lit in head)
    if choice:
        ret += &#34;}&#34;

    if has_body or (not head and not choice):
        ret += &#34; :- &#34;

    return ret


def _pretty_str_truth_value(stm: TruthValue):
    &#34;&#34;&#34;
    Pretty print a truth value.
    &#34;&#34;&#34;
    if stm == TruthValue.False_:
        return &#34;False&#34;
    if stm == TruthValue.True_:
        return &#34;True&#34;
    return &#34;Free&#34;


def _remap_lit(literal: Literal, mapping: AtomMap) -&gt; Atom:
    return -mapping(-literal) if literal &lt; 0 else mapping(literal)


def _remap_seq(literals: Sequence[Literal], mapping: AtomMap):
    &#34;&#34;&#34;
    Apply the mapping to a sequence of literals or atoms.
    &#34;&#34;&#34;
    return [_remap_lit(lit, mapping) for lit in literals]


def _remap_wseq(literals: Sequence[Tuple[Literal, Weight]], mapping: AtomMap):
    &#34;&#34;&#34;
    Apply the mapping to a sequence of weighted literals or atoms.
    &#34;&#34;&#34;
    return [(_remap_lit(lit, mapping), weight) for lit, weight in literals]


def _remap_stms(stms: MutableSequence[Statement], mapping: AtomMap):
    &#34;&#34;&#34;
    Remap the given statements.
    &#34;&#34;&#34;
    for i, stm in enumerate(stms):
        stms[i] = remap(stm, mapping)


def _add_stms_to_backend(
    stms: Iterable[Statement], backend: Backend, mapping: Optional[AtomMap]
):
    &#34;&#34;&#34;
    Remap the given statements returning a list with the result.
    &#34;&#34;&#34;
    for stm in stms:
        if mapping:
            add_to_backend(remap(stm, mapping), backend)
        else:
            add_to_backend(stm, backend)


class Fact(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a fact.
    &#34;&#34;&#34;

    symbol: Symbol


@pretty_str.register(Fact)
def _pretty_str_fact(stm: Fact, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a fact.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    return f&#34;{stm.symbol}.&#34;


@remap.register(Fact)
def _remap_fact(stm: Fact, mapping: AtomMap) -&gt; Fact:
    &#34;&#34;&#34;
    Remap a fact statement.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    return stm


@add_to_backend.register(Fact)
def _add_to_backend_fact(stm: Fact, backend: Backend) -&gt; None:
    &#34;&#34;&#34;
    Add a fact to the backend.

    This does nothing to not interfere with the mapping of literals. If facts
    are to be mapped, then this should be done manually beforehand.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument


class Show(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a show statements.
    &#34;&#34;&#34;

    symbol: Symbol
    condition: Sequence[Literal]


@pretty_str.register(Show)
def _pretty_str_show(stm: Show, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a fact.
    &#34;&#34;&#34;
    body = &#34;, &#34;.join(_pretty_str_lit(lit, output_atoms) for lit in stm.condition)
    return f&#39;#show {stm.symbol}{&#34;: &#34; if body else &#34;&#34;}{body}.&#39;


@remap.register(Show)
def _remap_show(stm: Show, mapping: AtomMap) -&gt; Show:
    &#34;&#34;&#34;
    Remap a show statetment.
    &#34;&#34;&#34;
    return Show(stm.symbol, _remap_seq(stm.condition, mapping))


@add_to_backend.register(Show)
def _add_to_backend_show(stm: Show, backend: Backend) -&gt; None:
    &#34;&#34;&#34;
    Add a show statement to the backend.

    Note that this currently does nothing because backend does not yet support
    adding to the symbol table.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument


class Rule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of disjunctive and choice rules.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    body: Sequence[Literal]


@pretty_str.register(Rule)
def _pretty_str_rule(stm: Rule, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a rule.
    &#34;&#34;&#34;
    head = _pretty_str_rule_head(stm.choice, bool(stm.body), stm.head, output_atoms)
    body = &#34;, &#34;.join(_pretty_str_lit(lit, output_atoms) for lit in stm.body)

    return f&#34;{head}{body}.&#34;


@remap.register(Rule)
def _remap_rule(stm: Rule, mapping: AtomMap) -&gt; Rule:
    &#34;&#34;&#34;
    Remap literals in a rule.
    &#34;&#34;&#34;
    return Rule(
        stm.choice, _remap_seq(stm.head, mapping), _remap_seq(stm.body, mapping)
    )


@add_to_backend.register(Rule)
def _add_to_backend_rule(stm: Rule, backend: Backend) -&gt; None:
    &#34;&#34;&#34;
    Add a rule to the backend.
    &#34;&#34;&#34;
    backend.add_rule(stm.head, stm.body, stm.choice)


class WeightRule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of rules with a weight constraint in the body.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    lower_bound: Weight
    body: Sequence[Tuple[Literal, Weight]]


@pretty_str.register(WeightRule)
def _pretty_str_weight_rule(stm: WeightRule, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a rule or weight rule.
    &#34;&#34;&#34;
    head = _pretty_str_rule_head(stm.choice, bool(stm.body), stm.head, output_atoms)
    body = &#34;, &#34;.join(
        f&#34;{weight},{i}: {_pretty_str_lit(literal, output_atoms)}&#34;
        for i, (literal, weight) in enumerate(stm.body)
    )

    return f&#34;{head}{stm.lower_bound}{{{body}}}.&#34;


@remap.register(WeightRule)
def _remap_weight_rule(stm: WeightRule, mapping: AtomMap) -&gt; WeightRule:
    &#34;&#34;&#34;
    Remap literals in a weight rule.
    &#34;&#34;&#34;
    return WeightRule(
        stm.choice,
        _remap_seq(stm.head, mapping),
        stm.lower_bound,
        _remap_wseq(stm.body, mapping),
    )


@add_to_backend.register(WeightRule)
def _add_to_backend_weight_rule(stm: WeightRule, backend: Backend) -&gt; None:
    &#34;&#34;&#34;
    Add a weight rule to the backend.
    &#34;&#34;&#34;
    backend.add_weight_rule(stm.head, stm.lower_bound, stm.body, stm.choice)


class Project(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of project statements.
    &#34;&#34;&#34;

    atom: Atom


@pretty_str.register(Project)
def _pretty_str_project(stm: Project, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a project statement.
    &#34;&#34;&#34;
    return f&#34;#project {_pretty_str_lit(stm.atom, output_atoms)}.&#34;


@remap.register(Project)
def _remap_project(stm: Project, mapping: AtomMap):
    &#34;&#34;&#34;
    Remap project statement.
    &#34;&#34;&#34;
    return Project(mapping(stm.atom))


@add_to_backend.register(Project)
def _add_to_backend_project(stm: Project, backend: Backend):
    &#34;&#34;&#34;
    Add a project statement to the backend.
    &#34;&#34;&#34;
    backend.add_project([stm.atom])


class External(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of external atoms.
    &#34;&#34;&#34;

    atom: Atom
    value: TruthValue


@pretty_str.register(External)
def _pretty_print_external(stm: External, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print an external.
    &#34;&#34;&#34;
    return f&#34;#external {_pretty_str_lit(stm.atom, output_atoms)}. [{_pretty_str_truth_value(stm.value)}]&#34;


@remap.register(External)
def _remap_external(stm: External, mapping: AtomMap) -&gt; External:
    &#34;&#34;&#34;
    Remap the external.
    &#34;&#34;&#34;
    return External(mapping(stm.atom), stm.value)


@add_to_backend.register(External)
def _add_to_backend_external(stm: External, backend: Backend):
    &#34;&#34;&#34;
    Add an external statement to the backend remapping its atom.
    &#34;&#34;&#34;
    backend.add_external(stm.atom, stm.value)


class Minimize(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a minimize statement.
    &#34;&#34;&#34;

    priority: Weight
    literals: Sequence[Tuple[Literal, Weight]]


@pretty_str.register(Minimize)
def _pretty_print_minimize(stm, output_atoms) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a minimize statement.
    &#34;&#34;&#34;
    body = &#34;; &#34;.join(
        f&#34;{weight}@{stm.priority},{i}: {_pretty_str_lit(literal, output_atoms)}&#34;
        for i, (literal, weight) in enumerate(stm.literals)
    )
    return f&#34;#minimize{{{body}}}.&#34;


@remap.register(Minimize)
def _remap_minimize(stm: Minimize, mapping: AtomMap) -&gt; Minimize:
    &#34;&#34;&#34;
    Remap the literals in the minimize statement.
    &#34;&#34;&#34;
    return Minimize(stm.priority, _remap_wseq(stm.literals, mapping))


@add_to_backend.register(Minimize)
def _add_to_backend_minimize(stm: Minimize, backend: Backend):
    &#34;&#34;&#34;
    Add a minimize statement to the backend.
    &#34;&#34;&#34;
    backend.add_minimize(stm.priority, stm.literals)


class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]


def _pretty_str_heuristic_type(type_):
    return str(type_).replace(&#34;HeuristicType.&#34;, &#34;&#34;)


@pretty_str.register(Heuristic)
def _pretty_str_heuristic(stm: Heuristic, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a heuristic statement.
    &#34;&#34;&#34;
    body = &#34;, &#34;.join(_pretty_str_lit(lit, output_atoms) for lit in stm.condition)
    head = _pretty_str_lit(stm.atom, output_atoms)
    type_ = _pretty_str_heuristic_type(stm.type_)
    return f&#39;#heuristic {head}{&#34;: &#34; if body else &#34;&#34;}{body}. [{stm.bias}@{stm.priority}, {type_}]&#39;


@remap.register(Heuristic)
def _remap_heuristic(stm: Heuristic, mapping: AtomMap) -&gt; Heuristic:
    &#34;&#34;&#34;
    Remap the heuristic statement.
    &#34;&#34;&#34;
    return Heuristic(
        mapping(stm.atom),
        stm.type_,
        stm.bias,
        stm.priority,
        _remap_seq(stm.condition, mapping),
    )


@add_to_backend.register(Heuristic)
def _add_to_backend_heuristic(stm: Heuristic, backend: Backend) -&gt; None:
    &#34;&#34;&#34;
    Add a heurisitic statement to the backend.
    &#34;&#34;&#34;
    backend.add_heuristic(stm.atom, stm.type_, stm.bias, stm.priority, stm.condition)


class Edge(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    u: int
    v: int
    condition: Sequence[Literal]


@pretty_str.register(Edge)
def _pretty_str_edge(stm: Edge, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print a heuristic statement.
    &#34;&#34;&#34;
    body = &#34;, &#34;.join(_pretty_str_lit(lit, output_atoms) for lit in stm.condition)
    return f&#39;#edge ({stm.u},{stm.v}){&#34;: &#34; if body else &#34;&#34;}{body}.&#39;


@remap.register(Edge)
def _remap_edge(stm: Edge, mapping: AtomMap) -&gt; Edge:
    &#34;&#34;&#34;
    Remap an edge statement.
    &#34;&#34;&#34;
    return Edge(stm.u, stm.v, _remap_seq(stm.condition, mapping))


@add_to_backend.register(Edge)
def _add_to_backend_edge(stm: Edge, backend: Backend) -&gt; None:
    &#34;&#34;&#34;
    Add an edge statement to the backend remapping its literals.
    &#34;&#34;&#34;
    backend.add_acyc_edge(stm.u, stm.v, stm.condition)


@dataclass
class Program:  # pylint: disable=too-many-instance-attributes
    &#34;&#34;&#34;
    Ground program representation.

    Although inefficient, the string representation of this program is parsable
    by clingo.
    &#34;&#34;&#34;

    output_atoms: MutableMapping[Atom, Symbol] = field(default_factory=dict)
    &#34;&#34;&#34;
    A mapping from program atoms to symbols.
    &#34;&#34;&#34;
    shows: List[Show] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of show statements.
    &#34;&#34;&#34;
    facts: List[Fact] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of facts.
    &#34;&#34;&#34;
    rules: List[Rule] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of rules.
    &#34;&#34;&#34;
    weight_rules: List[WeightRule] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of weight rules.
    &#34;&#34;&#34;
    heuristics: List[Heuristic] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of heuristic statements.
    &#34;&#34;&#34;
    edges: List[Edge] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of edge statements.
    &#34;&#34;&#34;
    minimizes: List[Minimize] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of minimize statements.
    &#34;&#34;&#34;
    externals: List[External] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of external statements.
    &#34;&#34;&#34;
    projects: Optional[List[Project]] = None
    &#34;&#34;&#34;
    A list of project statements.
    &#34;&#34;&#34;
    assumptions: List[Literal] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of assumptions in form of program literals.
    &#34;&#34;&#34;

    def _pretty_stms(self, arg: Iterable[Statement], sort: bool) -&gt; Iterable[str]:
        if sort:
            arg = sorted(arg)
        return (pretty_str(x, self.output_atoms) for x in arg)

    def _pretty_assumptions(self, sort: bool) -&gt; Iterable[str]:
        if not self.assumptions:
            return []
        arg = sorted(self.assumptions) if sort else self.assumptions
        assumptions = (_pretty_str_lit(lit, self.output_atoms) for lit in arg)
        return [f&#39;% assumptions: {&#34;, &#34;.join(assumptions)}&#39;]

    def _pretty_projects(self, sort: bool) -&gt; Iterable[str]:
        if self.projects is None:
            return []
        # This is to inform that there is an empty projection statement.
        # It might be worth to allow writing just #project.
        if not self.projects:
            return [&#34;#project x: #false.&#34;]
        arg = sorted(self.projects) if sort else self.projects
        return (pretty_str(project, self.output_atoms) for project in arg)

    def sort(self) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Sort the statements in the program inplace.

        Returns
        -------
        A reference to self.
        &#34;&#34;&#34;
        self.shows.sort()
        self.facts.sort()
        self.rules.sort()
        self.weight_rules.sort()
        self.heuristics.sort()
        self.edges.sort()
        self.minimizes.sort()
        self.externals.sort()
        if self.projects is not None:
            self.projects.sort()
        self.assumptions.sort()

        return self

    def remap(self, mapping: AtomMap) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Remap the literals in the program inplace.

        Parameters
        ----------
        mapping
            A function to remap program atoms.

        Returns
        -------
        A reference to self.

        See Also
        --------
        remap
        &#34;&#34;&#34;
        _remap_stms(self.shows, mapping)
        _remap_stms(self.facts, mapping)
        _remap_stms(self.rules, mapping)
        _remap_stms(self.weight_rules, mapping)
        _remap_stms(self.heuristics, mapping)
        _remap_stms(self.edges, mapping)
        _remap_stms(self.minimizes, mapping)
        _remap_stms(self.externals, mapping)
        if self.projects is not None:
            _remap_stms(self.projects, mapping)
        for i, lit in enumerate(self.assumptions):
            self.assumptions[i] = _remap_lit(lit, mapping)
        self.output_atoms = {
            mapping(lit): sym for lit, sym in self.output_atoms.items()
        }

        return self

    def add_to_backend(
        self, backend: Backend, mapping: Optional[AtomMap] = None
    ) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Add the program to the given backend with an optional mapping.

        Note that the output table cannot be added to the backend for technical
        reasons. This has to be taken care of by the user. See for example the
        `Remapping` class, which provides functionality for this.

        Parameters
        ----------
        backend
            The backend.
        mapping
            A mapping function to remap literals.

        Returns
        -------
        A reference to self.

        See Also
        --------
        add_to_backend
        &#34;&#34;&#34;

        _add_stms_to_backend(self.shows, backend, mapping)
        _add_stms_to_backend(self.facts, backend, mapping)
        _add_stms_to_backend(self.rules, backend, mapping)
        _add_stms_to_backend(self.weight_rules, backend, mapping)
        _add_stms_to_backend(self.heuristics, backend, mapping)
        _add_stms_to_backend(self.edges, backend, mapping)
        _add_stms_to_backend(self.minimizes, backend, mapping)
        _add_stms_to_backend(self.externals, backend, mapping)
        if self.projects is not None:
            if self.projects:
                _add_stms_to_backend(self.projects, backend, mapping)
            else:
                backend.add_project([])

        backend.add_assume(
            [_remap_lit(lit, mapping) if mapping else lit for lit in self.assumptions]
        )

        return self

    def pretty_str(self, sort: bool = True) -&gt; str:
        &#34;&#34;&#34;
        Return a readable string represenation of the program.

        Parameters
        ----------
        sort
            Whether to sort the statements in the program befor printing.

        Returns
        -------
        The string representation of the program.
        &#34;&#34;&#34;
        return &#34;\n&#34;.join(
            chain(
                self._pretty_stms(self.shows, sort),
                self._pretty_stms(self.facts, sort),
                self._pretty_stms(self.rules, sort),
                self._pretty_stms(self.weight_rules, sort),
                self._pretty_stms(self.heuristics, sort),
                self._pretty_stms(self.edges, sort),
                self._pretty_stms(self.minimizes, sort),
                self._pretty_stms(self.externals, sort),
                self._pretty_projects(sort),
                self._pretty_assumptions(sort),
            )
        )

    def copy(self) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Return a shallow copy of the program copying all mutable state.

        Returns
        -------
        A shallow copy of the program.
        &#34;&#34;&#34;
        return copy(self)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Return a readable string represenation of the program.
        &#34;&#34;&#34;
        return self.pretty_str()


class Remapping:
    &#34;&#34;&#34;
    This class maps existing literals to fresh literals as created by the
    backend.

    Parameters
    ----------
    backend
        The backend used to introduce fresh atoms.
    output_atoms
        The output table to initialize the mapping with.
    facts
        A list of facts each of which will receive a fresh program atom.
    &#34;&#34;&#34;

    _backend: Backend
    _map: MutableMapping[Atom, Atom]

    def __init__(
        self, backend: Backend, output_atoms: OutputTable, facts: Iterable[Fact] = None
    ):
        self._backend = backend
        self._map = {}
        for atom, sym in output_atoms.items():
            assert atom not in self._map
            self._map[atom] = self._backend.add_atom(sym)
        if facts is not None:
            for fact in facts:
                backend.add_rule([backend.add_atom(fact.symbol)])

    def __call__(self, atom: Atom) -&gt; Atom:
        &#34;&#34;&#34;
        Map the given program atom to the corresponding atom in the backend.

        If the literal was not mapped during initialization, a new literal is
        associated with it.

        Parameters
        ----------
        atom
            The atom to remap.

        Returns
        -------
        The remapped program atom.
        &#34;&#34;&#34;
        if atom not in self._map:
            self._map[atom] = self._backend.add_atom()

        return self._map[atom]


__pdoc__[&#34;Remapping.__call__&#34;] = True


class ProgramObserver(Observer):
    &#34;&#34;&#34;
    Program observer to build a ground program representation while grounding.

    This class explicitly ignores theory atoms because they already have a
    ground representation.

    Parameters
    ----------
    program
        The program to add statements to.
    &#34;&#34;&#34;

    _program: Program

    def __init__(self, program: Program):
        self._program = program

    def begin_step(self) -&gt; None:
        &#34;&#34;&#34;
        Resets the assumptions.
        &#34;&#34;&#34;
        self._program.assumptions.clear()

    def output_atom(self, symbol: Symbol, atom: Atom) -&gt; None:
        &#34;&#34;&#34;
        Add the given atom to the list of facts or output table.
        &#34;&#34;&#34;
        if atom != 0:
            self._program.output_atoms[atom] = symbol
        else:
            self._program.facts.append(Fact(symbol))

    def output_term(self, symbol: Symbol, condition: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add a term to the output table.
        &#34;&#34;&#34;
        self._program.shows.append(Show(symbol, condition))

    def rule(self, choice: bool, head: Sequence[Atom], body: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add a rule to the ground representation.

        Parameters
        ----------
        choice
            Determines if the head is a choice or a disjunction.
        head
            List of program atoms forming the rule head.
        body
            List of program literals forming the rule body.
        &#34;&#34;&#34;
        self._program.rules.append(Rule(choice, head, body))

    def weight_rule(
        self,
        choice: bool,
        head: Sequence[Atom],
        lower_bound: Weight,
        body: Sequence[Tuple[Literal, Weight]],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a weight rule to the ground representation.

        Parameters
        ----------
        choice
            Determines if the head is a choice or a disjunction.
        head
            List of program atoms forming the head of the rule.
        lower_bound
            The lower bound of the weight constraint in the rule body.
        body
            List of weighted literals (pairs of literal and weight) forming the
            elements of the weight constraint.
        &#34;&#34;&#34;
        self._program.weight_rules.append(WeightRule(choice, head, lower_bound, body))

    def project(self, atoms: Sequence[Atom]) -&gt; None:
        &#34;&#34;&#34;
        Add a project statement to the ground representation.

        Parameters
        ----------
        atoms
            The program atoms to project on.
        &#34;&#34;&#34;
        if self._program.projects is None:
            self._program.projects = []
        self._program.projects.extend(Project(atom) for atom in atoms)

    def external(self, atom: Atom, value: TruthValue) -&gt; None:
        &#34;&#34;&#34;
        Add an external statement to the ground representation.

        Parameters
        ----------
        atom
            The external atom in form of a program literal.
        value
            The truth value of the external statement.
        &#34;&#34;&#34;
        self._program.externals.append(External(atom, value))

    def assume(self, literals: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Extend the program with the given assumptions.

        Parameters
        ----------
        literals
            The program literals to assume (positive literals are true and
            negative literals false for the next solve call).
        &#34;&#34;&#34;
        self._program.assumptions.extend(literals)

    def minimize(
        self, priority: Weight, literals: Sequence[Tuple[Literal, Weight]]
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a minimize statement to the ground representation.

        Parameters
        ----------
        priority
            The priority of the directive.
        literals
            List of weighted literals whose sum to minimize (pairs of literal
            and weight).
        &#34;&#34;&#34;
        self._program.minimizes.append(Minimize(priority, literals))

    def acyc_edge(self, node_u: int, node_v: int, condition: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add an edge statement to the gronud representation.

        Parameters
        ----------
        node_u
            The start vertex of the edge (in form of an integer).
        node_v
            Тhe end vertex of the edge (in form of an integer).
        condition
            The list of program literals forming th condition under which to
            add the edge.
        &#34;&#34;&#34;
        self._program.edges.append(Edge(node_u, node_v, condition))

    def heuristic(
        self,
        atom: Atom,
        type_: HeuristicType,
        bias: Weight,
        priority: Weight,
        condition: Sequence[Literal],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add heurisitic statement to the gronud representation.

        Parameters
        ----------
        atom
            The program atom heuristically modified.
        type_
            The type of the modification.
        bias
            A signed integer.
        priority
            An unsigned integer.
        condition
            List of program literals.
        &#34;&#34;&#34;
        self._program.heuristics.append(
            Heuristic(atom, type_, bias, priority, condition)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clingox.program.add_to_backend"><code class="name flex">
<span>def <span class="ident">add_to_backend</span></span>(<span>stm, backend: <a title="clingo.backend.Backend" href="../clingo/backend.html#clingo.backend.Backend">Backend</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add statements to the backend using the provided mapping to map literals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stm</code></strong></dt>
<dd>The statement to add to the backend.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>The backend.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@singledispatch
def add_to_backend(stm, backend: Backend):
    &#34;&#34;&#34;
    Add statements to the backend using the provided mapping to map literals.

    Parameters
    ----------
    stm
        The statement to add to the backend.
    backend
        The backend.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;</code></pre>
</details>
</dd>
<dt id="clingox.program.pretty_str"><code class="name flex">
<span>def <span class="ident">pretty_str</span></span>(<span>stm, output_atoms: Mapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty print statements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stm</code></strong></dt>
<dd>The statement to convert to a string.</dd>
<dt><strong><code>output_atoms</code></strong></dt>
<dd>A mapping from program atoms to symbols.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string representation of the statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@singledispatch
def pretty_str(stm, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print statements.

    Parameters
    ----------
    stm
        The statement to convert to a string.
    output_atoms
        A mapping from program atoms to symbols.

    Returns
    -------
    The string representation of the statement.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;</code></pre>
</details>
</dd>
<dt id="clingox.program.remap"><code class="name flex">
<span>def <span class="ident">remap</span></span>(<span>stm, mapping: Callable[[int], int])</span>
</code></dt>
<dd>
<div class="desc"><p>Remap literals in the given statement with the provided mapping.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stm</code></strong></dt>
<dd>The statement to remap.</dd>
<dt><strong><code>mapping</code></strong></dt>
<dd>The mapping function to remap literals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated statement.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.program.Remapping" href="#clingox.program.Remapping">Remapping</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@singledispatch
def remap(stm, mapping: AtomMap):
    &#34;&#34;&#34;
    Remap literals in the given statement with the provided mapping.

    Parameters
    ----------
    stm
        The statement to remap.
    mapping
        The mapping function to remap literals.

    Returns
    -------
    The updated statement.

    See Also
    --------
    Remapping
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingox.program.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
<span>(</span><span>u: int, v: int, condition: Sequence[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of a heuristic statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    u: int
    v: int
    condition: Sequence[Literal]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Edge.condition"><code class="name">var <span class="ident">condition</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="clingox.program.Edge.u"><code class="name">var <span class="ident">u</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.Edge.v"><code class="name">var <span class="ident">v</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.External"><code class="flex name class">
<span>class <span class="ident">External</span></span>
<span>(</span><span>atom: int, value: <a title="clingo.core.TruthValue" href="../clingo/core.html#clingo.core.TruthValue">TruthValue</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of external atoms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class External(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of external atoms.
    &#34;&#34;&#34;

    atom: Atom
    value: TruthValue</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.External.atom"><code class="name">var <span class="ident">atom</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.External.value"><code class="name">var <span class="ident">value</span> : <a title="clingo.core.TruthValue" href="../clingo/core.html#clingo.core.TruthValue">TruthValue</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Fact"><code class="flex name class">
<span>class <span class="ident">Fact</span></span>
<span>(</span><span>symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of a fact.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fact(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a fact.
    &#34;&#34;&#34;

    symbol: Symbol</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Fact.symbol"><code class="name">var <span class="ident">symbol</span> : <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Heuristic"><code class="flex name class">
<span>class <span class="ident">Heuristic</span></span>
<span>(</span><span>atom: int, type_: <a title="clingo.backend.HeuristicType" href="../clingo/backend.html#clingo.backend.HeuristicType">HeuristicType</a>, bias: int, priority: int, condition: Sequence[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of a heuristic statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Heuristic.atom"><code class="name">var <span class="ident">atom</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.Heuristic.bias"><code class="name">var <span class="ident">bias</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="clingox.program.Heuristic.condition"><code class="name">var <span class="ident">condition</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="clingox.program.Heuristic.priority"><code class="name">var <span class="ident">priority</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="clingox.program.Heuristic.type_"><code class="name">var <span class="ident">type_</span> : <a title="clingo.backend.HeuristicType" href="../clingo/backend.html#clingo.backend.HeuristicType">HeuristicType</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Minimize"><code class="flex name class">
<span>class <span class="ident">Minimize</span></span>
<span>(</span><span>priority: int, literals: Sequence[Tuple[int, int]])</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of a minimize statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Minimize(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a minimize statement.
    &#34;&#34;&#34;

    priority: Weight
    literals: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Minimize.literals"><code class="name">var <span class="ident">literals</span> : Sequence[Tuple[int, int]]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="clingox.program.Minimize.priority"><code class="name">var <span class="ident">priority</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Program"><code class="flex name class">
<span>class <span class="ident">Program</span></span>
<span>(</span><span>output_atoms: MutableMapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>] = &lt;factory&gt;, shows: List[<a title="clingox.program.Show" href="#clingox.program.Show">Show</a>] = &lt;factory&gt;, facts: List[<a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a>] = &lt;factory&gt;, rules: List[<a title="clingox.program.Rule" href="#clingox.program.Rule">Rule</a>] = &lt;factory&gt;, weight_rules: List[<a title="clingox.program.WeightRule" href="#clingox.program.WeightRule">WeightRule</a>] = &lt;factory&gt;, heuristics: List[<a title="clingox.program.Heuristic" href="#clingox.program.Heuristic">Heuristic</a>] = &lt;factory&gt;, edges: List[<a title="clingox.program.Edge" href="#clingox.program.Edge">Edge</a>] = &lt;factory&gt;, minimizes: List[<a title="clingox.program.Minimize" href="#clingox.program.Minimize">Minimize</a>] = &lt;factory&gt;, externals: List[<a title="clingox.program.External" href="#clingox.program.External">External</a>] = &lt;factory&gt;, projects: Optional[List[<a title="clingox.program.Project" href="#clingox.program.Project">Project</a>]] = None, assumptions: List[int] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Ground program representation.</p>
<p>Although inefficient, the string representation of this program is parsable
by clingo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Program:  # pylint: disable=too-many-instance-attributes
    &#34;&#34;&#34;
    Ground program representation.

    Although inefficient, the string representation of this program is parsable
    by clingo.
    &#34;&#34;&#34;

    output_atoms: MutableMapping[Atom, Symbol] = field(default_factory=dict)
    &#34;&#34;&#34;
    A mapping from program atoms to symbols.
    &#34;&#34;&#34;
    shows: List[Show] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of show statements.
    &#34;&#34;&#34;
    facts: List[Fact] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of facts.
    &#34;&#34;&#34;
    rules: List[Rule] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of rules.
    &#34;&#34;&#34;
    weight_rules: List[WeightRule] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of weight rules.
    &#34;&#34;&#34;
    heuristics: List[Heuristic] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of heuristic statements.
    &#34;&#34;&#34;
    edges: List[Edge] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of edge statements.
    &#34;&#34;&#34;
    minimizes: List[Minimize] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of minimize statements.
    &#34;&#34;&#34;
    externals: List[External] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of external statements.
    &#34;&#34;&#34;
    projects: Optional[List[Project]] = None
    &#34;&#34;&#34;
    A list of project statements.
    &#34;&#34;&#34;
    assumptions: List[Literal] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of assumptions in form of program literals.
    &#34;&#34;&#34;

    def _pretty_stms(self, arg: Iterable[Statement], sort: bool) -&gt; Iterable[str]:
        if sort:
            arg = sorted(arg)
        return (pretty_str(x, self.output_atoms) for x in arg)

    def _pretty_assumptions(self, sort: bool) -&gt; Iterable[str]:
        if not self.assumptions:
            return []
        arg = sorted(self.assumptions) if sort else self.assumptions
        assumptions = (_pretty_str_lit(lit, self.output_atoms) for lit in arg)
        return [f&#39;% assumptions: {&#34;, &#34;.join(assumptions)}&#39;]

    def _pretty_projects(self, sort: bool) -&gt; Iterable[str]:
        if self.projects is None:
            return []
        # This is to inform that there is an empty projection statement.
        # It might be worth to allow writing just #project.
        if not self.projects:
            return [&#34;#project x: #false.&#34;]
        arg = sorted(self.projects) if sort else self.projects
        return (pretty_str(project, self.output_atoms) for project in arg)

    def sort(self) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Sort the statements in the program inplace.

        Returns
        -------
        A reference to self.
        &#34;&#34;&#34;
        self.shows.sort()
        self.facts.sort()
        self.rules.sort()
        self.weight_rules.sort()
        self.heuristics.sort()
        self.edges.sort()
        self.minimizes.sort()
        self.externals.sort()
        if self.projects is not None:
            self.projects.sort()
        self.assumptions.sort()

        return self

    def remap(self, mapping: AtomMap) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Remap the literals in the program inplace.

        Parameters
        ----------
        mapping
            A function to remap program atoms.

        Returns
        -------
        A reference to self.

        See Also
        --------
        remap
        &#34;&#34;&#34;
        _remap_stms(self.shows, mapping)
        _remap_stms(self.facts, mapping)
        _remap_stms(self.rules, mapping)
        _remap_stms(self.weight_rules, mapping)
        _remap_stms(self.heuristics, mapping)
        _remap_stms(self.edges, mapping)
        _remap_stms(self.minimizes, mapping)
        _remap_stms(self.externals, mapping)
        if self.projects is not None:
            _remap_stms(self.projects, mapping)
        for i, lit in enumerate(self.assumptions):
            self.assumptions[i] = _remap_lit(lit, mapping)
        self.output_atoms = {
            mapping(lit): sym for lit, sym in self.output_atoms.items()
        }

        return self

    def add_to_backend(
        self, backend: Backend, mapping: Optional[AtomMap] = None
    ) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Add the program to the given backend with an optional mapping.

        Note that the output table cannot be added to the backend for technical
        reasons. This has to be taken care of by the user. See for example the
        `Remapping` class, which provides functionality for this.

        Parameters
        ----------
        backend
            The backend.
        mapping
            A mapping function to remap literals.

        Returns
        -------
        A reference to self.

        See Also
        --------
        add_to_backend
        &#34;&#34;&#34;

        _add_stms_to_backend(self.shows, backend, mapping)
        _add_stms_to_backend(self.facts, backend, mapping)
        _add_stms_to_backend(self.rules, backend, mapping)
        _add_stms_to_backend(self.weight_rules, backend, mapping)
        _add_stms_to_backend(self.heuristics, backend, mapping)
        _add_stms_to_backend(self.edges, backend, mapping)
        _add_stms_to_backend(self.minimizes, backend, mapping)
        _add_stms_to_backend(self.externals, backend, mapping)
        if self.projects is not None:
            if self.projects:
                _add_stms_to_backend(self.projects, backend, mapping)
            else:
                backend.add_project([])

        backend.add_assume(
            [_remap_lit(lit, mapping) if mapping else lit for lit in self.assumptions]
        )

        return self

    def pretty_str(self, sort: bool = True) -&gt; str:
        &#34;&#34;&#34;
        Return a readable string represenation of the program.

        Parameters
        ----------
        sort
            Whether to sort the statements in the program befor printing.

        Returns
        -------
        The string representation of the program.
        &#34;&#34;&#34;
        return &#34;\n&#34;.join(
            chain(
                self._pretty_stms(self.shows, sort),
                self._pretty_stms(self.facts, sort),
                self._pretty_stms(self.rules, sort),
                self._pretty_stms(self.weight_rules, sort),
                self._pretty_stms(self.heuristics, sort),
                self._pretty_stms(self.edges, sort),
                self._pretty_stms(self.minimizes, sort),
                self._pretty_stms(self.externals, sort),
                self._pretty_projects(sort),
                self._pretty_assumptions(sort),
            )
        )

    def copy(self) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Return a shallow copy of the program copying all mutable state.

        Returns
        -------
        A shallow copy of the program.
        &#34;&#34;&#34;
        return copy(self)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Return a readable string represenation of the program.
        &#34;&#34;&#34;
        return self.pretty_str()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="clingox.program.Program.assumptions"><code class="name">var <span class="ident">assumptions</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>A list of assumptions in form of program literals.</p></div>
</dd>
<dt id="clingox.program.Program.edges"><code class="name">var <span class="ident">edges</span> : List[<a title="clingox.program.Edge" href="#clingox.program.Edge">Edge</a>]</code></dt>
<dd>
<div class="desc"><p>A list of edge statements.</p></div>
</dd>
<dt id="clingox.program.Program.externals"><code class="name">var <span class="ident">externals</span> : List[<a title="clingox.program.External" href="#clingox.program.External">External</a>]</code></dt>
<dd>
<div class="desc"><p>A list of external statements.</p></div>
</dd>
<dt id="clingox.program.Program.facts"><code class="name">var <span class="ident">facts</span> : List[<a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a>]</code></dt>
<dd>
<div class="desc"><p>A list of facts.</p></div>
</dd>
<dt id="clingox.program.Program.heuristics"><code class="name">var <span class="ident">heuristics</span> : List[<a title="clingox.program.Heuristic" href="#clingox.program.Heuristic">Heuristic</a>]</code></dt>
<dd>
<div class="desc"><p>A list of heuristic statements.</p></div>
</dd>
<dt id="clingox.program.Program.minimizes"><code class="name">var <span class="ident">minimizes</span> : List[<a title="clingox.program.Minimize" href="#clingox.program.Minimize">Minimize</a>]</code></dt>
<dd>
<div class="desc"><p>A list of minimize statements.</p></div>
</dd>
<dt id="clingox.program.Program.output_atoms"><code class="name">var <span class="ident">output_atoms</span> : MutableMapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]</code></dt>
<dd>
<div class="desc"><p>A mapping from program atoms to symbols.</p></div>
</dd>
<dt id="clingox.program.Program.projects"><code class="name">var <span class="ident">projects</span> : Optional[List[<a title="clingox.program.Project" href="#clingox.program.Project">Project</a>]]</code></dt>
<dd>
<div class="desc"><p>A list of project statements.</p></div>
</dd>
<dt id="clingox.program.Program.rules"><code class="name">var <span class="ident">rules</span> : List[<a title="clingox.program.Rule" href="#clingox.program.Rule">Rule</a>]</code></dt>
<dd>
<div class="desc"><p>A list of rules.</p></div>
</dd>
<dt id="clingox.program.Program.shows"><code class="name">var <span class="ident">shows</span> : List[<a title="clingox.program.Show" href="#clingox.program.Show">Show</a>]</code></dt>
<dd>
<div class="desc"><p>A list of show statements.</p></div>
</dd>
<dt id="clingox.program.Program.weight_rules"><code class="name">var <span class="ident">weight_rules</span> : List[<a title="clingox.program.WeightRule" href="#clingox.program.WeightRule">WeightRule</a>]</code></dt>
<dd>
<div class="desc"><p>A list of weight rules.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingox.program.Program.add_to_backend"><code class="name flex">
<span>def <span class="ident">add_to_backend</span></span>(<span>self, backend: <a title="clingo.backend.Backend" href="../clingo/backend.html#clingo.backend.Backend">Backend</a>, mapping: Optional[Callable[[int], int]] = None) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add the program to the given backend with an optional mapping.</p>
<p>Note that the output table cannot be added to the backend for technical
reasons. This has to be taken care of by the user. See for example the
<code><a title="clingox.program.Remapping" href="#clingox.program.Remapping">Remapping</a></code> class, which provides functionality for this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong></dt>
<dd>The backend.</dd>
<dt><strong><code>mapping</code></strong></dt>
<dd>A mapping function to remap literals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A reference to self.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.program.add_to_backend" href="#clingox.program.add_to_backend">add_to_backend()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_backend(
    self, backend: Backend, mapping: Optional[AtomMap] = None
) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Add the program to the given backend with an optional mapping.

    Note that the output table cannot be added to the backend for technical
    reasons. This has to be taken care of by the user. See for example the
    `Remapping` class, which provides functionality for this.

    Parameters
    ----------
    backend
        The backend.
    mapping
        A mapping function to remap literals.

    Returns
    -------
    A reference to self.

    See Also
    --------
    add_to_backend
    &#34;&#34;&#34;

    _add_stms_to_backend(self.shows, backend, mapping)
    _add_stms_to_backend(self.facts, backend, mapping)
    _add_stms_to_backend(self.rules, backend, mapping)
    _add_stms_to_backend(self.weight_rules, backend, mapping)
    _add_stms_to_backend(self.heuristics, backend, mapping)
    _add_stms_to_backend(self.edges, backend, mapping)
    _add_stms_to_backend(self.minimizes, backend, mapping)
    _add_stms_to_backend(self.externals, backend, mapping)
    if self.projects is not None:
        if self.projects:
            _add_stms_to_backend(self.projects, backend, mapping)
        else:
            backend.add_project([])

    backend.add_assume(
        [_remap_lit(lit, mapping) if mapping else lit for lit in self.assumptions]
    )

    return self</code></pre>
</details>
</dd>
<dt id="clingox.program.Program.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a shallow copy of the program copying all mutable state.</p>
<h2 id="returns">Returns</h2>
<p>A shallow copy of the program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Return a shallow copy of the program copying all mutable state.

    Returns
    -------
    A shallow copy of the program.
    &#34;&#34;&#34;
    return copy(self)</code></pre>
</details>
</dd>
<dt id="clingox.program.Program.pretty_str"><code class="name flex">
<span>def <span class="ident">pretty_str</span></span>(<span>self, sort: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a readable string represenation of the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sort</code></strong></dt>
<dd>Whether to sort the statements in the program befor printing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string representation of the program.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_str(self, sort: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Return a readable string represenation of the program.

    Parameters
    ----------
    sort
        Whether to sort the statements in the program befor printing.

    Returns
    -------
    The string representation of the program.
    &#34;&#34;&#34;
    return &#34;\n&#34;.join(
        chain(
            self._pretty_stms(self.shows, sort),
            self._pretty_stms(self.facts, sort),
            self._pretty_stms(self.rules, sort),
            self._pretty_stms(self.weight_rules, sort),
            self._pretty_stms(self.heuristics, sort),
            self._pretty_stms(self.edges, sort),
            self._pretty_stms(self.minimizes, sort),
            self._pretty_stms(self.externals, sort),
            self._pretty_projects(sort),
            self._pretty_assumptions(sort),
        )
    )</code></pre>
</details>
</dd>
<dt id="clingox.program.Program.remap"><code class="name flex">
<span>def <span class="ident">remap</span></span>(<span>self, mapping: Callable[[int], int]) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<div class="desc"><p>Remap the literals in the program inplace.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>A function to remap program atoms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A reference to self.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.program.remap" href="#clingox.program.remap">remap()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remap(self, mapping: AtomMap) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Remap the literals in the program inplace.

    Parameters
    ----------
    mapping
        A function to remap program atoms.

    Returns
    -------
    A reference to self.

    See Also
    --------
    remap
    &#34;&#34;&#34;
    _remap_stms(self.shows, mapping)
    _remap_stms(self.facts, mapping)
    _remap_stms(self.rules, mapping)
    _remap_stms(self.weight_rules, mapping)
    _remap_stms(self.heuristics, mapping)
    _remap_stms(self.edges, mapping)
    _remap_stms(self.minimizes, mapping)
    _remap_stms(self.externals, mapping)
    if self.projects is not None:
        _remap_stms(self.projects, mapping)
    for i, lit in enumerate(self.assumptions):
        self.assumptions[i] = _remap_lit(lit, mapping)
    self.output_atoms = {
        mapping(lit): sym for lit, sym in self.output_atoms.items()
    }

    return self</code></pre>
</details>
</dd>
<dt id="clingox.program.Program.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sort the statements in the program inplace.</p>
<h2 id="returns">Returns</h2>
<p>A reference to self.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Sort the statements in the program inplace.

    Returns
    -------
    A reference to self.
    &#34;&#34;&#34;
    self.shows.sort()
    self.facts.sort()
    self.rules.sort()
    self.weight_rules.sort()
    self.heuristics.sort()
    self.edges.sort()
    self.minimizes.sort()
    self.externals.sort()
    if self.projects is not None:
        self.projects.sort()
    self.assumptions.sort()

    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingox.program.ProgramObserver"><code class="flex name class">
<span>class <span class="ident">ProgramObserver</span></span>
<span>(</span><span>program: <a title="clingox.program.Program" href="#clingox.program.Program">Program</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Program observer to build a ground program representation while grounding.</p>
<p>This class explicitly ignores theory atoms because they already have a
ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>program</code></strong></dt>
<dd>The program to add statements to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgramObserver(Observer):
    &#34;&#34;&#34;
    Program observer to build a ground program representation while grounding.

    This class explicitly ignores theory atoms because they already have a
    ground representation.

    Parameters
    ----------
    program
        The program to add statements to.
    &#34;&#34;&#34;

    _program: Program

    def __init__(self, program: Program):
        self._program = program

    def begin_step(self) -&gt; None:
        &#34;&#34;&#34;
        Resets the assumptions.
        &#34;&#34;&#34;
        self._program.assumptions.clear()

    def output_atom(self, symbol: Symbol, atom: Atom) -&gt; None:
        &#34;&#34;&#34;
        Add the given atom to the list of facts or output table.
        &#34;&#34;&#34;
        if atom != 0:
            self._program.output_atoms[atom] = symbol
        else:
            self._program.facts.append(Fact(symbol))

    def output_term(self, symbol: Symbol, condition: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add a term to the output table.
        &#34;&#34;&#34;
        self._program.shows.append(Show(symbol, condition))

    def rule(self, choice: bool, head: Sequence[Atom], body: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add a rule to the ground representation.

        Parameters
        ----------
        choice
            Determines if the head is a choice or a disjunction.
        head
            List of program atoms forming the rule head.
        body
            List of program literals forming the rule body.
        &#34;&#34;&#34;
        self._program.rules.append(Rule(choice, head, body))

    def weight_rule(
        self,
        choice: bool,
        head: Sequence[Atom],
        lower_bound: Weight,
        body: Sequence[Tuple[Literal, Weight]],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a weight rule to the ground representation.

        Parameters
        ----------
        choice
            Determines if the head is a choice or a disjunction.
        head
            List of program atoms forming the head of the rule.
        lower_bound
            The lower bound of the weight constraint in the rule body.
        body
            List of weighted literals (pairs of literal and weight) forming the
            elements of the weight constraint.
        &#34;&#34;&#34;
        self._program.weight_rules.append(WeightRule(choice, head, lower_bound, body))

    def project(self, atoms: Sequence[Atom]) -&gt; None:
        &#34;&#34;&#34;
        Add a project statement to the ground representation.

        Parameters
        ----------
        atoms
            The program atoms to project on.
        &#34;&#34;&#34;
        if self._program.projects is None:
            self._program.projects = []
        self._program.projects.extend(Project(atom) for atom in atoms)

    def external(self, atom: Atom, value: TruthValue) -&gt; None:
        &#34;&#34;&#34;
        Add an external statement to the ground representation.

        Parameters
        ----------
        atom
            The external atom in form of a program literal.
        value
            The truth value of the external statement.
        &#34;&#34;&#34;
        self._program.externals.append(External(atom, value))

    def assume(self, literals: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Extend the program with the given assumptions.

        Parameters
        ----------
        literals
            The program literals to assume (positive literals are true and
            negative literals false for the next solve call).
        &#34;&#34;&#34;
        self._program.assumptions.extend(literals)

    def minimize(
        self, priority: Weight, literals: Sequence[Tuple[Literal, Weight]]
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a minimize statement to the ground representation.

        Parameters
        ----------
        priority
            The priority of the directive.
        literals
            List of weighted literals whose sum to minimize (pairs of literal
            and weight).
        &#34;&#34;&#34;
        self._program.minimizes.append(Minimize(priority, literals))

    def acyc_edge(self, node_u: int, node_v: int, condition: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add an edge statement to the gronud representation.

        Parameters
        ----------
        node_u
            The start vertex of the edge (in form of an integer).
        node_v
            Тhe end vertex of the edge (in form of an integer).
        condition
            The list of program literals forming th condition under which to
            add the edge.
        &#34;&#34;&#34;
        self._program.edges.append(Edge(node_u, node_v, condition))

    def heuristic(
        self,
        atom: Atom,
        type_: HeuristicType,
        bias: Weight,
        priority: Weight,
        condition: Sequence[Literal],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add heurisitic statement to the gronud representation.

        Parameters
        ----------
        atom
            The program atom heuristically modified.
        type_
            The type of the modification.
        bias
            A signed integer.
        priority
            An unsigned integer.
        condition
            List of program literals.
        &#34;&#34;&#34;
        self._program.heuristics.append(
            Heuristic(atom, type_, bias, priority, condition)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clingo.backend.Observer" href="../clingo/backend.html#clingo.backend.Observer">Observer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingox.program.ProgramObserver.acyc_edge"><code class="name flex">
<span>def <span class="ident">acyc_edge</span></span>(<span>self, node_u: int, node_v: int, condition: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an edge statement to the gronud representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_u</code></strong></dt>
<dd>The start vertex of the edge (in form of an integer).</dd>
<dt><strong><code>node_v</code></strong></dt>
<dd>Тhe end vertex of the edge (in form of an integer).</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>The list of program literals forming th condition under which to
add the edge.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acyc_edge(self, node_u: int, node_v: int, condition: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Add an edge statement to the gronud representation.

    Parameters
    ----------
    node_u
        The start vertex of the edge (in form of an integer).
    node_v
        Тhe end vertex of the edge (in form of an integer).
    condition
        The list of program literals forming th condition under which to
        add the edge.
    &#34;&#34;&#34;
    self._program.edges.append(Edge(node_u, node_v, condition))</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.assume"><code class="name flex">
<span>def <span class="ident">assume</span></span>(<span>self, literals: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extend the program with the given assumptions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literals</code></strong></dt>
<dd>The program literals to assume (positive literals are true and
negative literals false for the next solve call).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assume(self, literals: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Extend the program with the given assumptions.

    Parameters
    ----------
    literals
        The program literals to assume (positive literals are true and
        negative literals false for the next solve call).
    &#34;&#34;&#34;
    self._program.assumptions.extend(literals)</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.begin_step"><code class="name flex">
<span>def <span class="ident">begin_step</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the assumptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_step(self) -&gt; None:
    &#34;&#34;&#34;
    Resets the assumptions.
    &#34;&#34;&#34;
    self._program.assumptions.clear()</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.external"><code class="name flex">
<span>def <span class="ident">external</span></span>(<span>self, atom: int, value: <a title="clingo.core.TruthValue" href="../clingo/core.html#clingo.core.TruthValue">TruthValue</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an external statement to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong></dt>
<dd>The external atom in form of a program literal.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The truth value of the external statement.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def external(self, atom: Atom, value: TruthValue) -&gt; None:
    &#34;&#34;&#34;
    Add an external statement to the ground representation.

    Parameters
    ----------
    atom
        The external atom in form of a program literal.
    value
        The truth value of the external statement.
    &#34;&#34;&#34;
    self._program.externals.append(External(atom, value))</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.heuristic"><code class="name flex">
<span>def <span class="ident">heuristic</span></span>(<span>self, atom: int, type_: <a title="clingo.backend.HeuristicType" href="../clingo/backend.html#clingo.backend.HeuristicType">HeuristicType</a>, bias: int, priority: int, condition: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add heurisitic statement to the gronud representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong></dt>
<dd>The program atom heuristically modified.</dd>
<dt><strong><code>type_</code></strong></dt>
<dd>The type of the modification.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>A signed integer.</dd>
<dt><strong><code>priority</code></strong></dt>
<dd>An unsigned integer.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>List of program literals.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heuristic(
    self,
    atom: Atom,
    type_: HeuristicType,
    bias: Weight,
    priority: Weight,
    condition: Sequence[Literal],
) -&gt; None:
    &#34;&#34;&#34;
    Add heurisitic statement to the gronud representation.

    Parameters
    ----------
    atom
        The program atom heuristically modified.
    type_
        The type of the modification.
    bias
        A signed integer.
    priority
        An unsigned integer.
    condition
        List of program literals.
    &#34;&#34;&#34;
    self._program.heuristics.append(
        Heuristic(atom, type_, bias, priority, condition)
    )</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.minimize"><code class="name flex">
<span>def <span class="ident">minimize</span></span>(<span>self, priority: int, literals: Sequence[Tuple[int, int]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a minimize statement to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>priority</code></strong></dt>
<dd>The priority of the directive.</dd>
<dt><strong><code>literals</code></strong></dt>
<dd>List of weighted literals whose sum to minimize (pairs of literal
and weight).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimize(
    self, priority: Weight, literals: Sequence[Tuple[Literal, Weight]]
) -&gt; None:
    &#34;&#34;&#34;
    Add a minimize statement to the ground representation.

    Parameters
    ----------
    priority
        The priority of the directive.
    literals
        List of weighted literals whose sum to minimize (pairs of literal
        and weight).
    &#34;&#34;&#34;
    self._program.minimizes.append(Minimize(priority, literals))</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.output_atom"><code class="name flex">
<span>def <span class="ident">output_atom</span></span>(<span>self, symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>, atom: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add the given atom to the list of facts or output table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_atom(self, symbol: Symbol, atom: Atom) -&gt; None:
    &#34;&#34;&#34;
    Add the given atom to the list of facts or output table.
    &#34;&#34;&#34;
    if atom != 0:
        self._program.output_atoms[atom] = symbol
    else:
        self._program.facts.append(Fact(symbol))</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.output_term"><code class="name flex">
<span>def <span class="ident">output_term</span></span>(<span>self, symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>, condition: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a term to the output table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_term(self, symbol: Symbol, condition: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Add a term to the output table.
    &#34;&#34;&#34;
    self._program.shows.append(Show(symbol, condition))</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, atoms: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a project statement to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atoms</code></strong></dt>
<dd>The program atoms to project on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, atoms: Sequence[Atom]) -&gt; None:
    &#34;&#34;&#34;
    Add a project statement to the ground representation.

    Parameters
    ----------
    atoms
        The program atoms to project on.
    &#34;&#34;&#34;
    if self._program.projects is None:
        self._program.projects = []
    self._program.projects.extend(Project(atom) for atom in atoms)</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.rule"><code class="name flex">
<span>def <span class="ident">rule</span></span>(<span>self, choice: bool, head: Sequence[int], body: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a rule to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>choice</code></strong></dt>
<dd>Determines if the head is a choice or a disjunction.</dd>
<dt><strong><code>head</code></strong></dt>
<dd>List of program atoms forming the rule head.</dd>
<dt><strong><code>body</code></strong></dt>
<dd>List of program literals forming the rule body.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rule(self, choice: bool, head: Sequence[Atom], body: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Add a rule to the ground representation.

    Parameters
    ----------
    choice
        Determines if the head is a choice or a disjunction.
    head
        List of program atoms forming the rule head.
    body
        List of program literals forming the rule body.
    &#34;&#34;&#34;
    self._program.rules.append(Rule(choice, head, body))</code></pre>
</details>
</dd>
<dt id="clingox.program.ProgramObserver.weight_rule"><code class="name flex">
<span>def <span class="ident">weight_rule</span></span>(<span>self, choice: bool, head: Sequence[int], lower_bound: int, body: Sequence[Tuple[int, int]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a weight rule to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>choice</code></strong></dt>
<dd>Determines if the head is a choice or a disjunction.</dd>
<dt><strong><code>head</code></strong></dt>
<dd>List of program atoms forming the head of the rule.</dd>
<dt><strong><code>lower_bound</code></strong></dt>
<dd>The lower bound of the weight constraint in the rule body.</dd>
<dt><strong><code>body</code></strong></dt>
<dd>List of weighted literals (pairs of literal and weight) forming the
elements of the weight constraint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_rule(
    self,
    choice: bool,
    head: Sequence[Atom],
    lower_bound: Weight,
    body: Sequence[Tuple[Literal, Weight]],
) -&gt; None:
    &#34;&#34;&#34;
    Add a weight rule to the ground representation.

    Parameters
    ----------
    choice
        Determines if the head is a choice or a disjunction.
    head
        List of program atoms forming the head of the rule.
    lower_bound
        The lower bound of the weight constraint in the rule body.
    body
        List of weighted literals (pairs of literal and weight) forming the
        elements of the weight constraint.
    &#34;&#34;&#34;
    self._program.weight_rules.append(WeightRule(choice, head, lower_bound, body))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clingo.backend.Observer" href="../clingo/backend.html#clingo.backend.Observer">Observer</a></b></code>:
<ul class="hlist">
<li><code><a title="clingo.backend.Observer.end_step" href="../clingo/backend.html#clingo.backend.Observer.end_step">end_step</a></code></li>
<li><code><a title="clingo.backend.Observer.init_program" href="../clingo/backend.html#clingo.backend.Observer.init_program">init_program</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_atom" href="../clingo/backend.html#clingo.backend.Observer.theory_atom">theory_atom</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_atom_with_guard" href="../clingo/backend.html#clingo.backend.Observer.theory_atom_with_guard">theory_atom_with_guard</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_element" href="../clingo/backend.html#clingo.backend.Observer.theory_element">theory_element</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_compound" href="../clingo/backend.html#clingo.backend.Observer.theory_term_compound">theory_term_compound</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_number" href="../clingo/backend.html#clingo.backend.Observer.theory_term_number">theory_term_number</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_string" href="../clingo/backend.html#clingo.backend.Observer.theory_term_string">theory_term_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clingox.program.Project"><code class="flex name class">
<span>class <span class="ident">Project</span></span>
<span>(</span><span>atom: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of project statements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Project(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of project statements.
    &#34;&#34;&#34;

    atom: Atom</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Project.atom"><code class="name">var <span class="ident">atom</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Remapping"><code class="flex name class">
<span>class <span class="ident">Remapping</span></span>
<span>(</span><span>backend: <a title="clingo.backend.Backend" href="../clingo/backend.html#clingo.backend.Backend">Backend</a>, output_atoms: Mapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>], facts: Iterable[<a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class maps existing literals to fresh literals as created by the
backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong></dt>
<dd>The backend used to introduce fresh atoms.</dd>
<dt><strong><code>output_atoms</code></strong></dt>
<dd>The output table to initialize the mapping with.</dd>
<dt><strong><code>facts</code></strong></dt>
<dd>A list of facts each of which will receive a fresh program atom.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Remapping:
    &#34;&#34;&#34;
    This class maps existing literals to fresh literals as created by the
    backend.

    Parameters
    ----------
    backend
        The backend used to introduce fresh atoms.
    output_atoms
        The output table to initialize the mapping with.
    facts
        A list of facts each of which will receive a fresh program atom.
    &#34;&#34;&#34;

    _backend: Backend
    _map: MutableMapping[Atom, Atom]

    def __init__(
        self, backend: Backend, output_atoms: OutputTable, facts: Iterable[Fact] = None
    ):
        self._backend = backend
        self._map = {}
        for atom, sym in output_atoms.items():
            assert atom not in self._map
            self._map[atom] = self._backend.add_atom(sym)
        if facts is not None:
            for fact in facts:
                backend.add_rule([backend.add_atom(fact.symbol)])

    def __call__(self, atom: Atom) -&gt; Atom:
        &#34;&#34;&#34;
        Map the given program atom to the corresponding atom in the backend.

        If the literal was not mapped during initialization, a new literal is
        associated with it.

        Parameters
        ----------
        atom
            The atom to remap.

        Returns
        -------
        The remapped program atom.
        &#34;&#34;&#34;
        if atom not in self._map:
            self._map[atom] = self._backend.add_atom()

        return self._map[atom]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="clingox.program.Remapping.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, atom: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Map the given program atom to the corresponding atom in the backend.</p>
<p>If the literal was not mapped during initialization, a new literal is
associated with it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong></dt>
<dd>The atom to remap.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The remapped program atom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, atom: Atom) -&gt; Atom:
    &#34;&#34;&#34;
    Map the given program atom to the corresponding atom in the backend.

    If the literal was not mapped during initialization, a new literal is
    associated with it.

    Parameters
    ----------
    atom
        The atom to remap.

    Returns
    -------
    The remapped program atom.
    &#34;&#34;&#34;
    if atom not in self._map:
        self._map[atom] = self._backend.add_atom()

    return self._map[atom]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingox.program.Rule"><code class="flex name class">
<span>class <span class="ident">Rule</span></span>
<span>(</span><span>choice: bool, head: Sequence[int], body: Sequence[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of disjunctive and choice rules.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of disjunctive and choice rules.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    body: Sequence[Literal]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Rule.body"><code class="name">var <span class="ident">body</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="clingox.program.Rule.choice"><code class="name">var <span class="ident">choice</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.Rule.head"><code class="name">var <span class="ident">head</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Show"><code class="flex name class">
<span>class <span class="ident">Show</span></span>
<span>(</span><span>symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>, condition: Sequence[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of a show statements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Show(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a show statements.
    &#34;&#34;&#34;

    symbol: Symbol
    condition: Sequence[Literal]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Show.condition"><code class="name">var <span class="ident">condition</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="clingox.program.Show.symbol"><code class="name">var <span class="ident">symbol</span> : <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.WeightRule"><code class="flex name class">
<span>class <span class="ident">WeightRule</span></span>
<span>(</span><span>choice: bool, head: Sequence[int], lower_bound: int, body: Sequence[Tuple[int, int]])</span>
</code></dt>
<dd>
<div class="desc"><p>Ground representation of rules with a weight constraint in the body.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightRule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of rules with a weight constraint in the body.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    lower_bound: Weight
    body: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.WeightRule.body"><code class="name">var <span class="ident">body</span> : Sequence[Tuple[int, int]]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="clingox.program.WeightRule.choice"><code class="name">var <span class="ident">choice</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.WeightRule.head"><code class="name">var <span class="ident">head</span> : Sequence[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="clingox.program.WeightRule.lower_bound"><code class="name">var <span class="ident">lower_bound</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#example">Example</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clingox" href="index.html">clingox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clingox.program.add_to_backend" href="#clingox.program.add_to_backend">add_to_backend</a></code></li>
<li><code><a title="clingox.program.pretty_str" href="#clingox.program.pretty_str">pretty_str</a></code></li>
<li><code><a title="clingox.program.remap" href="#clingox.program.remap">remap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingox.program.Edge" href="#clingox.program.Edge">Edge</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Edge.condition" href="#clingox.program.Edge.condition">condition</a></code></li>
<li><code><a title="clingox.program.Edge.u" href="#clingox.program.Edge.u">u</a></code></li>
<li><code><a title="clingox.program.Edge.v" href="#clingox.program.Edge.v">v</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.External" href="#clingox.program.External">External</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.External.atom" href="#clingox.program.External.atom">atom</a></code></li>
<li><code><a title="clingox.program.External.value" href="#clingox.program.External.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Fact.symbol" href="#clingox.program.Fact.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Heuristic" href="#clingox.program.Heuristic">Heuristic</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Heuristic.atom" href="#clingox.program.Heuristic.atom">atom</a></code></li>
<li><code><a title="clingox.program.Heuristic.bias" href="#clingox.program.Heuristic.bias">bias</a></code></li>
<li><code><a title="clingox.program.Heuristic.condition" href="#clingox.program.Heuristic.condition">condition</a></code></li>
<li><code><a title="clingox.program.Heuristic.priority" href="#clingox.program.Heuristic.priority">priority</a></code></li>
<li><code><a title="clingox.program.Heuristic.type_" href="#clingox.program.Heuristic.type_">type_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Minimize" href="#clingox.program.Minimize">Minimize</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Minimize.literals" href="#clingox.program.Minimize.literals">literals</a></code></li>
<li><code><a title="clingox.program.Minimize.priority" href="#clingox.program.Minimize.priority">priority</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Program" href="#clingox.program.Program">Program</a></code></h4>
<ul class="two-column">
<li><code><a title="clingox.program.Program.add_to_backend" href="#clingox.program.Program.add_to_backend">add_to_backend</a></code></li>
<li><code><a title="clingox.program.Program.assumptions" href="#clingox.program.Program.assumptions">assumptions</a></code></li>
<li><code><a title="clingox.program.Program.copy" href="#clingox.program.Program.copy">copy</a></code></li>
<li><code><a title="clingox.program.Program.edges" href="#clingox.program.Program.edges">edges</a></code></li>
<li><code><a title="clingox.program.Program.externals" href="#clingox.program.Program.externals">externals</a></code></li>
<li><code><a title="clingox.program.Program.facts" href="#clingox.program.Program.facts">facts</a></code></li>
<li><code><a title="clingox.program.Program.heuristics" href="#clingox.program.Program.heuristics">heuristics</a></code></li>
<li><code><a title="clingox.program.Program.minimizes" href="#clingox.program.Program.minimizes">minimizes</a></code></li>
<li><code><a title="clingox.program.Program.output_atoms" href="#clingox.program.Program.output_atoms">output_atoms</a></code></li>
<li><code><a title="clingox.program.Program.pretty_str" href="#clingox.program.Program.pretty_str">pretty_str</a></code></li>
<li><code><a title="clingox.program.Program.projects" href="#clingox.program.Program.projects">projects</a></code></li>
<li><code><a title="clingox.program.Program.remap" href="#clingox.program.Program.remap">remap</a></code></li>
<li><code><a title="clingox.program.Program.rules" href="#clingox.program.Program.rules">rules</a></code></li>
<li><code><a title="clingox.program.Program.shows" href="#clingox.program.Program.shows">shows</a></code></li>
<li><code><a title="clingox.program.Program.sort" href="#clingox.program.Program.sort">sort</a></code></li>
<li><code><a title="clingox.program.Program.weight_rules" href="#clingox.program.Program.weight_rules">weight_rules</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.ProgramObserver" href="#clingox.program.ProgramObserver">ProgramObserver</a></code></h4>
<ul class="two-column">
<li><code><a title="clingox.program.ProgramObserver.acyc_edge" href="#clingox.program.ProgramObserver.acyc_edge">acyc_edge</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.assume" href="#clingox.program.ProgramObserver.assume">assume</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.begin_step" href="#clingox.program.ProgramObserver.begin_step">begin_step</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.external" href="#clingox.program.ProgramObserver.external">external</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.heuristic" href="#clingox.program.ProgramObserver.heuristic">heuristic</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.minimize" href="#clingox.program.ProgramObserver.minimize">minimize</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.output_atom" href="#clingox.program.ProgramObserver.output_atom">output_atom</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.output_term" href="#clingox.program.ProgramObserver.output_term">output_term</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.project" href="#clingox.program.ProgramObserver.project">project</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.rule" href="#clingox.program.ProgramObserver.rule">rule</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.weight_rule" href="#clingox.program.ProgramObserver.weight_rule">weight_rule</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Project" href="#clingox.program.Project">Project</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Project.atom" href="#clingox.program.Project.atom">atom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Remapping" href="#clingox.program.Remapping">Remapping</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Remapping.__call__" href="#clingox.program.Remapping.__call__">__call__</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Rule" href="#clingox.program.Rule">Rule</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Rule.body" href="#clingox.program.Rule.body">body</a></code></li>
<li><code><a title="clingox.program.Rule.choice" href="#clingox.program.Rule.choice">choice</a></code></li>
<li><code><a title="clingox.program.Rule.head" href="#clingox.program.Rule.head">head</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Show" href="#clingox.program.Show">Show</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Show.condition" href="#clingox.program.Show.condition">condition</a></code></li>
<li><code><a title="clingox.program.Show.symbol" href="#clingox.program.Show.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.WeightRule" href="#clingox.program.WeightRule">WeightRule</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.WeightRule.body" href="#clingox.program.WeightRule.body">body</a></code></li>
<li><code><a title="clingox.program.WeightRule.choice" href="#clingox.program.WeightRule.choice">choice</a></code></li>
<li><code><a title="clingox.program.WeightRule.head" href="#clingox.program.WeightRule.head">head</a></code></li>
<li><code><a title="clingox.program.WeightRule.lower_bound" href="#clingox.program.WeightRule.lower_bound">lower_bound</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
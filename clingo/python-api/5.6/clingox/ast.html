<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>clingox.ast API documentation</title>
<meta name="description" content="This module provides highlevel functions to work with clingo&#39;s AST …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<nav class="http-server-breadcrumbs">
<a href="https://potassco.org/clingo/python-api/5.5/">All packages</a>
:: <a href="https://potassco.org/clingo/python-api/5.5/clingox/">clingox</a>
</nav>
<h1 class="title">Module <code>clingox.ast</code></h1>
</header>
<section id="section-intro">
<p>This module provides highlevel functions to work with clingo's AST.</p>
<h2 id="theory-parsing-examples">Theory Parsing Examples</h2>
<p>The following examples shows how to construct and use a theory parser:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from clingo.ast import TheoryAtomType, parse_string
&gt;&gt;&gt; from clingox.ast import Arity, Associativity, TheoryParser
&gt;&gt;&gt;
&gt;&gt;&gt; terms = {&quot;term&quot;:
...     {(&quot;-&quot;, Arity.Unary): (3, Associativity.NoAssociativity),
...      (&quot;**&quot;, Arity.Binary): (2, Associativity.Right),
...      (&quot;*&quot;, Arity.Binary): (1, Associativity.Left),
...      (&quot;+&quot;, Arity.Binary): (0, Associativity.Left),
...      (&quot;-&quot;, Arity.Binary): (0, Associativity.Left)}}
&gt;&gt;&gt; atoms = {(&quot;eval&quot;, 0): (TheoryAtomType.Head, &quot;term&quot;, None)}
&gt;&gt;&gt; parser = TheoryParser(terms, atoms)
&gt;&gt;&gt;
&gt;&gt;&gt; parse_string('&amp;eval{ -1 * 2 + 3 }.', print)
#program base.
&amp;eval { (- 1 * 2 + 3) }.
&gt;&gt;&gt; parse_string('&amp;eval{ -1 * 2 + 3 }.', lambda x: print(parser(x)))
#program base.
&amp;eval { +(*(-(1),2),3) }.
</code></pre>
<p>The same parser can also be constructed from a theory:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from clingo.ast import parse_string, ASTType
&gt;&gt;&gt; from clingox.ast import theory_parser_from_definition
&gt;&gt;&gt;
&gt;&gt;&gt; theory = &quot;&quot;&quot;\
... #theory test {
...     term {
...         -  : 3, unary;
...         ** : 2, binary, right;
...         *  : 1, binary, left;
...         +  : 0, binary, left;
...         -  : 0, binary, left
...     };
...     &amp;eval/0 : term, head
... }.
... &quot;&quot;&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; parsers = []
&gt;&gt;&gt; def extract(stm):
...     if stm.ast_type == ASTType.TheoryDefinition:
...         parsers.append(theory_parser_from_definition(stm))
...
&gt;&gt;&gt; parse_string(theory, extract)
&gt;&gt;&gt; parse_string('&amp;eval{ -1 * 2 + 3 }.', print)
#program base.
&amp;eval { (- 1 * 2 + 3) }.
&gt;&gt;&gt; parse_string('&amp;eval{ -1 * 2 + 3 }.', lambda x: print(parsers[0](x)))
#program base.
&amp;eval { +(*(-(1),2),3) }.
</code></pre>
<h2 id="ast-to-dict-conversion-example">Ast To Dict Conversion Example</h2>
<p>Another interesting feature is to convert ASTs to YAML:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from json import dumps
&gt;&gt;&gt; from clingo.ast import parse_string
&gt;&gt;&gt; from clingox.ast import ast_to_dict
&gt;&gt;&gt;
&gt;&gt;&gt; prg = []
&gt;&gt;&gt; parse_string('a.', lambda x: prg.append(ast_to_dict(x)))
&gt;&gt;&gt;
&gt;&gt;&gt; print(dumps(prg, indent=2))
[
  {
    &quot;ast_type&quot;: &quot;Program&quot;,
    &quot;location&quot;: &quot;&lt;string&gt;:1:1&quot;,
    &quot;name&quot;: &quot;base&quot;,
    &quot;parameters&quot;: []
  },
  {
    &quot;ast_type&quot;: &quot;Rule&quot;,
    &quot;location&quot;: &quot;&lt;string&gt;:1:1-3&quot;,
    &quot;head&quot;: {
      &quot;ast_type&quot;: &quot;Literal&quot;,
      &quot;location&quot;: &quot;&lt;string&gt;:1:1-2&quot;,
      &quot;sign&quot;: 0,
      &quot;atom&quot;: {
        &quot;ast_type&quot;: &quot;SymbolicAtom&quot;,
        &quot;symbol&quot;: {
          &quot;ast_type&quot;: &quot;Function&quot;,
          &quot;location&quot;: &quot;&lt;string&gt;:1:1-2&quot;,
          &quot;name&quot;: &quot;a&quot;,
          &quot;arguments&quot;: [],
          &quot;external&quot;: 0
        }
      }
    },
    &quot;body&quot;: []
  }
]
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
This module provides highlevel functions to work with clingo&#39;s AST.

Theory Parsing Examples
-----------------------

The following examples shows how to construct and use a theory parser:

```python-repl
&gt;&gt;&gt; from clingo.ast import TheoryAtomType, parse_string
&gt;&gt;&gt; from clingox.ast import Arity, Associativity, TheoryParser
&gt;&gt;&gt;
&gt;&gt;&gt; terms = {&#34;term&#34;:
...     {(&#34;-&#34;, Arity.Unary): (3, Associativity.NoAssociativity),
...      (&#34;**&#34;, Arity.Binary): (2, Associativity.Right),
...      (&#34;*&#34;, Arity.Binary): (1, Associativity.Left),
...      (&#34;+&#34;, Arity.Binary): (0, Associativity.Left),
...      (&#34;-&#34;, Arity.Binary): (0, Associativity.Left)}}
&gt;&gt;&gt; atoms = {(&#34;eval&#34;, 0): (TheoryAtomType.Head, &#34;term&#34;, None)}
&gt;&gt;&gt; parser = TheoryParser(terms, atoms)
&gt;&gt;&gt;
&gt;&gt;&gt; parse_string(&#39;&amp;eval{ -1 * 2 + 3 }.&#39;, print)
#program base.
&amp;eval { (- 1 * 2 + 3) }.
&gt;&gt;&gt; parse_string(&#39;&amp;eval{ -1 * 2 + 3 }.&#39;, lambda x: print(parser(x)))
#program base.
&amp;eval { +(*(-(1),2),3) }.
```

The same parser can also be constructed from a theory:

```python-repl
&gt;&gt;&gt; from clingo.ast import parse_string, ASTType
&gt;&gt;&gt; from clingox.ast import theory_parser_from_definition
&gt;&gt;&gt;
&gt;&gt;&gt; theory = &#34;&#34;&#34;\\
... #theory test {
...     term {
...         -  : 3, unary;
...         ** : 2, binary, right;
...         *  : 1, binary, left;
...         +  : 0, binary, left;
...         -  : 0, binary, left
...     };
...     &amp;eval/0 : term, head
... }.
... &#34;&#34;&#34;
&gt;&gt;&gt;
&gt;&gt;&gt; parsers = []
&gt;&gt;&gt; def extract(stm):
...     if stm.ast_type == ASTType.TheoryDefinition:
...         parsers.append(theory_parser_from_definition(stm))
...
&gt;&gt;&gt; parse_string(theory, extract)
&gt;&gt;&gt; parse_string(&#39;&amp;eval{ -1 * 2 + 3 }.&#39;, print)
#program base.
&amp;eval { (- 1 * 2 + 3) }.
&gt;&gt;&gt; parse_string(&#39;&amp;eval{ -1 * 2 + 3 }.&#39;, lambda x: print(parsers[0](x)))
#program base.
&amp;eval { +(*(-(1),2),3) }.
```

AST to dict Conversion Example
------------------------------

Another interesting feature is to convert ASTs to YAML:

```python-repl
&gt;&gt;&gt; from json import dumps
&gt;&gt;&gt; from clingo.ast import parse_string
&gt;&gt;&gt; from clingox.ast import ast_to_dict
&gt;&gt;&gt;
&gt;&gt;&gt; prg = []
&gt;&gt;&gt; parse_string(&#39;a.&#39;, lambda x: prg.append(ast_to_dict(x)))
&gt;&gt;&gt;
&gt;&gt;&gt; print(dumps(prg, indent=2))
[
  {
    &#34;ast_type&#34;: &#34;Program&#34;,
    &#34;location&#34;: &#34;&lt;string&gt;:1:1&#34;,
    &#34;name&#34;: &#34;base&#34;,
    &#34;parameters&#34;: []
  },
  {
    &#34;ast_type&#34;: &#34;Rule&#34;,
    &#34;location&#34;: &#34;&lt;string&gt;:1:1-3&#34;,
    &#34;head&#34;: {
      &#34;ast_type&#34;: &#34;Literal&#34;,
      &#34;location&#34;: &#34;&lt;string&gt;:1:1-2&#34;,
      &#34;sign&#34;: 0,
      &#34;atom&#34;: {
        &#34;ast_type&#34;: &#34;SymbolicAtom&#34;,
        &#34;symbol&#34;: {
          &#34;ast_type&#34;: &#34;Function&#34;,
          &#34;location&#34;: &#34;&lt;string&gt;:1:1-2&#34;,
          &#34;name&#34;: &#34;a&#34;,
          &#34;arguments&#34;: [],
          &#34;external&#34;: 0
        }
      }
    },
    &#34;body&#34;: []
  }
]
```
&#39;&#39;&#39;

from typing import Any, Callable, List, Mapping, Optional, Sequence, Set, Tuple, Union, cast
from functools import singledispatch
from copy import copy
from re import fullmatch
from enum import Enum, auto

import clingo
from clingo import ast
from clingo.ast import (
    AST, ASTSequence, ASTType, Function, Location, Position, StrSequence,
    SymbolicTerm, SymbolicAtom, TheoryAtomType, TheoryFunction,
    TheoryOperatorType, Transformer, UnaryOperation)
from .theory import is_operator

__all__ = [&#39;ast_to_dict&#39;, &#39;dict_to_ast&#39;, &#39;location_to_str&#39;,
           &#39;prefix_symbolic_atoms&#39;, &#39;rename_symbolic_atoms&#39;, &#39;str_to_location&#39;,
           &#39;theory_parser_from_definition&#39;, &#39;Arity&#39;, &#39;Associativity&#39;,
           &#39;AtomTable&#39;, &#39;OperatorTable&#39;, &#39;TheoryParser&#39;, &#39;TheoryTermParser&#39;,
           &#39;TheoryUnparsedTermParser&#39;, &#39;TheoryUnparsedTermParser&#39;]


class Arity(Enum):
    &#39;&#39;&#39;
    Enumeration of operator arities.
    &#39;&#39;&#39;
    # pylint:disable=invalid-name
    Unary = 1
    Binary = 2


class Associativity(Enum):
    &#39;&#39;&#39;
    Enumeration of operator associativities.
    &#39;&#39;&#39;
    # pylint: disable=invalid-name
    Left = auto()
    Right = auto()
    NoAssociativity = auto()


def _s(m, a: str, b: str):
    &#39;&#39;&#39;
    Select the match group b if not None and group a otherwise.
    &#39;&#39;&#39;
    return m[a] if m[b] is None else m[b]


def _quote(s: str) -&gt; str:
    return s.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;:&#39;, &#39;\\:&#39;)


def _unquote(s: str) -&gt; str:
    return s.replace(&#39;\\:&#39;, &#39;:&#39;).replace(&#39;\\\\&#39;, &#39;\\&#39;)


def location_to_str(loc: Location) -&gt; str:
    &#34;&#34;&#34;
    This function transfroms a loctation object into a readable string.

    Colons in the location will be quoted ensuring that the resulting is
    parsable using `str_to_location`.

    Parameters
    ----------
    loc
        The location to transform.

    Returns
    -------
    The string representation of the given location.
    &#34;&#34;&#34;
    begin, end = loc.begin, loc.end
    bf, ef = _quote(begin.filename), _quote(end.filename)
    ret = f&#34;{bf}:{begin.line}:{begin.column}&#34;
    dash, eq = True, bf == ef
    if not eq:
        ret += f&#34;{&#39;-&#39; if dash else &#39;:&#39;}{ef}&#34;
        dash = False
    eq = eq and begin.line == end.line
    if not eq:
        ret += f&#34;{&#39;-&#39; if dash else &#39;:&#39;}{end.line}&#34;
        dash = False
    eq = eq and begin.column == end.column
    if not eq:
        ret += f&#34;{&#39;-&#39; if dash else &#39;:&#39;}{end.column}&#34;
        dash = False
    return ret


def str_to_location(loc: str) -&gt; Location:
    &#34;&#34;&#34;
    This function parses a location from its string representation.

    Parameters
    ----------
    loc
        The string to parse.

    Returns
    -------
    The parsed location.

    See Also
    --------
    location_to_str
    &#34;&#34;&#34;
    m = fullmatch(
        r&#39;(?P&lt;bf&gt;([^\\:]|\\\\|\\:)*):(?P&lt;bl&gt;[0-9]*):(?P&lt;bc&gt;[0-9]+)&#39;
        r&#39;(-(((?P&lt;ef&gt;([^\\:]|\\\\|\\:)*):)?(?P&lt;el&gt;[0-9]*):)?(?P&lt;ec&gt;[0-9]+))?&#39;, loc)
    if not m:
        raise RuntimeError(&#39;could not parse location&#39;)
    begin = Position(_unquote(m[&#39;bf&#39;]), int(m[&#39;bl&#39;]), int(m[&#39;bc&#39;]))
    end = Position(_unquote(_s(m, &#39;bf&#39;, &#39;ef&#39;)), int(_s(m, &#39;bl&#39;, &#39;el&#39;)), int(_s(m, &#39;bc&#39;, &#39;ec&#39;)))
    return Location(begin, end)


OperatorTable = Mapping[Tuple[str, Arity],
                        Tuple[int, Associativity]]
AtomTable = Mapping[Tuple[str, int],
                    Tuple[TheoryAtomType,
                          str,
                          Optional[Tuple[List[str], str]]]]


class TheoryUnparsedTermParser:
    &#34;&#34;&#34;
    Parser for unparsed theory terms in clingo&#39;s AST that works like the
    inbuilt one.

    Note that associativity for unary operators is ignored and binary
    operators must use either `Associativity.Left` or `Associativity.Right`.

    Parameters
    ----------
    table
        Mapping of operator/arity pairs to priority/associativity pairs.
    &#34;&#34;&#34;
    _stack: List[Tuple[str, Arity]]
    _terms: List[AST]
    _table: OperatorTable

    def __init__(self, table: OperatorTable):
        self._stack = []
        self._terms = []
        self._table = table

    def _priority_and_associativity(self, operator: str) -&gt; Tuple[int, Associativity]:
        &#34;&#34;&#34;
        Get priority and associativity of the given binary operator.
        &#34;&#34;&#34;
        return self._table[(operator, Arity.Binary)]

    def _priority(self, operator: str, arity: Arity) -&gt; int:
        &#34;&#34;&#34;
        Get priority of the given unary or binary operator.
        &#34;&#34;&#34;
        return self._table[(operator, arity)][0]

    def _check(self, operator: str) -&gt; bool:
        &#34;&#34;&#34;
        Returns true if the stack has to be reduced because of the precedence
        of the given binary operator is lower than the preceeding operator on
        the stack.
        &#34;&#34;&#34;
        if not self._stack:
            return False
        priority, associativity = self._priority_and_associativity(operator)
        previous_priority = self._priority(*self._stack[-1])
        return (previous_priority &gt; priority or
                (previous_priority == priority and associativity == Associativity.Left))

    def _reduce(self) -&gt; None:
        &#34;&#34;&#34;
        Combines the last unary or binary term on the stack.
        &#34;&#34;&#34;
        b = self._terms.pop()
        operator, arity = self._stack.pop()
        if arity == Arity.Unary:
            self._terms.append(TheoryFunction(b.location, operator, [b]))
        else:
            a = self._terms.pop()
            loc = Location(a.location.begin, b.location.end)
            self._terms.append(TheoryFunction(loc, operator, [a, b]))

    def check_operator(self, operator: str, arity: Arity, location: Location) -&gt; None:
        &#34;&#34;&#34;
        Check if the given operator is in the parse table raising a runtime
        error if absent.

        Parameters
        ----------
        operator
            The operator name.
        arity
            The arity of the operator.
        location
            Location of the operator for error reporting.
        &#34;&#34;&#34;
        if (operator, arity) not in self._table:
            raise RuntimeError(f&#34;cannot parse operator `{operator}`: {location_to_str(location)}&#34;)

    def parse(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parses the given unparsed term, replacing it by nested theory
        functions.

        Parameters
        ----------
        x
            The AST to parse.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        del self._stack[:]
        del self._terms[:]

        arity = Arity.Unary

        for element in x.elements:
            for operator in element.operators:
                self.check_operator(operator, arity, x.location)

                while arity == Arity.Binary and self._check(operator):
                    self._reduce()

                self._stack.append((operator, arity))
                arity = Arity.Unary

            self._terms.append(element.term)
            arity = Arity.Binary

        while self._stack:
            self._reduce()

        return self._terms[0]


class TheoryTermParser(Transformer):
    &#34;&#34;&#34;
    Parser for theory terms in clingo&#39;s AST that works like the inbuilt one.

    This is implemented as a transformer that traverses the AST replacing all
    terms found.

    Parameters
    ----------
    table
        This must either be a table of operators or a `TheoryUnparsedTermParser`.

    See Also
    --------
    TheoryUnparsedTermParser
    &#34;&#34;&#34;
    # pylint: disable=invalid-name

    def __init__(self, table: Union[OperatorTable, TheoryUnparsedTermParser]):
        self._parser = table if isinstance(table, TheoryUnparsedTermParser) else TheoryUnparsedTermParser(table)

    def visit_TheoryFunction(self, x) -&gt; AST:
        &#34;&#34;&#34;
        Parse the theory function and check if it agrees with the grammar.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        arity = None
        if len(x.arguments) == 1:
            arity = Arity.Unary
        if len(x.arguments) == 2:
            arity = Arity.Binary
        if arity is not None and is_operator(x.name):
            self._parser.check_operator(x.name, arity, x.location)

        return x.update(**self.visit_children(x))

    def visit_TheoryUnparsedTerm(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse the given unparsed term.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return cast(AST, self(self._parser.parse(x)))


class TheoryParser(Transformer):
    &#34;&#34;&#34;
    This class parses theory atoms in the same way as clingo&#39;s internal parser.

    Parameters
    ----------
    terms
        Mapping from term identifiers to `TheoryTermParser`s. If an operator
        table is given, the `TheoryTermParser` is constructed from this table.

    atoms
        Mapping from atom name/arity pairs to tuples defining the acceptable
        structure of the theory atom.
    &#34;&#34;&#34;
    # pylint: disable=invalid-name
    _table: Mapping[Tuple[str, int],
                    Tuple[TheoryAtomType,
                          TheoryTermParser,
                          Optional[Tuple[Set[str], TheoryTermParser]]]]
    _in_body: bool
    _in_head: bool
    _is_directive: bool

    def __init__(self, terms: Mapping[str, Union[OperatorTable, TheoryTermParser]], atoms: AtomTable):
        self._reset()

        term_parsers = {}
        for term_key, parser in terms.items():
            if isinstance(parser, TheoryTermParser):
                term_parsers[term_key] = parser
            else:
                term_parsers[term_key] = TheoryTermParser(parser)

        self._table = {}
        for atom_key, (atom_type, term_key, guard) in atoms.items():
            guard_table = None
            if guard is not None:
                guard_table = (set(guard[0]), term_parsers[guard[1]])
            self._table[atom_key] = (atom_type, term_parsers[term_key], guard_table)

    def _reset(self, in_head=True, in_body=True, is_directive=True):
        &#34;&#34;&#34;
        Set state information about active scope.
        &#34;&#34;&#34;
        self._in_head = in_head
        self._in_body = in_body
        self._is_directive = is_directive

    def _visit_body(self, x: AST) -&gt; AST:
        try:
            self._reset(False, True, False)
            old = x.body
            new = self.visit_sequence(old)
            return x if new is old else x.update(body=new)
        finally:
            self._reset()

    def visit_Rule(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body and head.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        ret = self._visit_body(x)
        try:
            self._reset(True, False, not x.body)
            head = self(x.head)
            if head is not x.head:
                if ret is x:
                    ret = copy(ret)
                ret.head = head
        finally:
            self._reset()

        return ret

    def visit_ShowTerm(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_Minimize(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_Edge(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_Heuristic(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_ProjectAtom(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_TheoryAtom(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse the given theory atom.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        name = x.term.name
        arity = len(x.term.arguments)
        if (name, arity) not in self._table:
            raise RuntimeError(f&#34;theory atom definiton not found: {location_to_str(x.location)}&#34;)

        type_, element_parser, guard_table = self._table[(name, arity)]
        if type_ == TheoryAtomType.Head and not self._in_head:
            raise RuntimeError(f&#34;theory atom only accepted in head: {location_to_str(x.location)}&#34;)
        if type_ == TheoryAtomType.Body and not self._in_body:
            raise RuntimeError(f&#34;theory atom only accepted in body: {location_to_str(x.location)}&#34;)
        if type_ == TheoryAtomType.Directive and not (self._in_head and self._is_directive):
            raise RuntimeError(f&#34;theory atom must be a directive: {location_to_str(x.location)}&#34;)

        x = copy(x)
        x.term = element_parser(x.term)
        x.elements = element_parser.visit_sequence(x.elements)

        if x.guard is not None:
            if guard_table is None:
                raise RuntimeError(f&#34;unexpected guard in theory atom: {location_to_str(x.location)}&#34;)

            guards, guard_parser = guard_table
            if x.guard.operator_name not in guards:
                raise RuntimeError(f&#34;unexpected guard in theory atom: {location_to_str(x.location)}&#34;)

            x.guard = copy(x.guard)
            x.guard.term = guard_parser(x.guard.term)

        return x


def theory_parser_from_definition(x: AST) -&gt; TheoryParser:
    &#34;&#34;&#34;
    Turn an AST node of type TheoryDefinition into a TheoryParser.

    Parameters
    ----------
    x
        An AST representing a theory definition.

    Returns
    -------
    The corresponding `TheoryParser`.
    &#34;&#34;&#34;
    assert x.ast_type == ASTType.TheoryDefinition

    terms = {}
    atoms = {}

    for term_def in x.terms:
        term_table = {}

        for op_def in term_def.operators:
            op_assoc: Associativity
            if op_def.operator_type == TheoryOperatorType.BinaryLeft:
                op_type = Arity.Binary
                op_assoc = Associativity.Left
            elif op_def.operator_type == TheoryOperatorType.BinaryRight:
                op_type = Arity.Binary
                op_assoc = Associativity.Right
            else:
                op_type = Arity.Unary
                op_assoc = Associativity.NoAssociativity

            term_table[(op_def.name, op_type)] = (op_def.priority, op_assoc)

        terms[term_def.name] = term_table

    for atom_def in x.atoms:
        guard = None
        if atom_def.guard is not None:
            guard = (atom_def.guard.operators, atom_def.guard.term)

        atoms[(atom_def.name, atom_def.arity)] = (atom_def.atom_type, atom_def.term, guard)

    return TheoryParser(terms, atoms)


class _SymbolicAtomTransformer(Transformer):
    &#39;&#39;&#39;
    Transforms symbolic atoms with the given function.
    &#39;&#39;&#39;
    # pylint: disable=invalid-name

    def __init__(self, transformer_function: Callable[[AST], AST]):
        self._transformer_function = transformer_function

    def visit_SymbolicAtom(self, x: AST) -&gt; AST:
        &#39;&#39;&#39;
        Transform the given symbolic.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#39;&#39;&#39;
        term = x.symbol
        new_term = self._transformer_function(term)
        return x if new_term is term else SymbolicAtom(new_term)


def rewrite_symbolic_atoms(x: AST, rewrite_function: Callable[[AST], AST]) -&gt; AST:
    &#39;&#39;&#39;
    Rewrite all symbolic atoms in the given AST node with the given function.

    Parameters
    ----------
    x
        The ast in which to rename symbolic atoms.
    rename_function
        A function applied to the term representation of the symbolic atom. The
        function has to return a term compatible with symbolic atoms.

    Returns
    -------
    The rewritten AST.
    &#39;&#39;&#39;
    return cast(AST, _SymbolicAtomTransformer(rewrite_function)(x))


def rename_symbolic_atoms(x: AST, rename_function: Callable[[str], str]) -&gt; AST:
    &#39;&#39;&#39;
    Rename all symbolic atoms in the given AST node with the given function.

    Parameters
    ----------
    x
        The ast in which to rename symbolic atoms.
    rename_function
        A function for renaming symbols.

    Returns
    -------
    The rewritten AST.
    &#39;&#39;&#39;
    def renamer(term: AST):
        if term.ast_type == ASTType.UnaryOperation:
            return UnaryOperation(term.location, term.operator_type, renamer(term.argument))
        if term.ast_type == ASTType.SymbolicTerm:
            sym = term.symbol
            new_name = rename_function(sym.name)
            return SymbolicTerm(term.location, clingo.Function(new_name, sym.arguments, sym.positive))
        if term.ast_type == ASTType.Function:
            return Function(term.location, rename_function(term.name), term.arguments, term.external)
        return term

    return rewrite_symbolic_atoms(x, renamer)


def prefix_symbolic_atoms(x: AST, prefix: str) -&gt; AST:
    &#39;&#39;&#39;
    Prefix all symbolic atoms in the given AST with the given string.

    Parameters
    ----------
    x
        The ast in which to prefix symbolic atom names.
    prefix
        The prefix to add.

    Returns
    -------
    The rewritten AST.

    See Also
    --------
    rename_symbolic_atoms
    &#39;&#39;&#39;
    return rename_symbolic_atoms(x, lambda s: prefix + s)


def reify_symbolic_atoms(x: AST, name: str,
                         argument_extender: Callable[[AST], Sequence[AST]] = None,
                         reify_strong_negation: bool = False) -&gt; AST:
    &#39;&#39;&#39;
    Reify all symbolic atoms in the given AST node with the given name and
    function.

    Parameters
    ----------
    x
        The ast in which to rename symbolic atoms.
    name
        A string to serve as name of the new symbolic atom.
    argument_extender
        A function to provide extra arguments. If not provided, no extra
        arguments are added. The term passed as argument should be placed in
        the correct position.
    reify_strong_negation
        Boolean indicating how to encode strong negation. If false, `-p(X)` is
        reified as `-name(p(X))`. If true, then -p(X) is reified as
        name(-p(X)). In the latter case, this means that stable models
        containing both `name(p(a))` and `name(-p(a))` are possible. Clingo
        style consistency can be restored by adding the constraint
        `:- name(X), name(-X), X&lt;-X.`

    Returns
    -------
    The rewritten AST.
    &#39;&#39;&#39;

    def reifier(term: AST):
        if term.ast_type == ASTType.UnaryOperation and not reify_strong_negation:
            return UnaryOperation(term.location, term.operator_type, reifier(term.argument))
        arguments = argument_extender(term) if argument_extender else [term]
        return Function(term.location, name, arguments, False)

    return rewrite_symbolic_atoms(x, reifier)


@singledispatch
def _encode(x: Any) -&gt; Any:
    assert False, f&#34;unknown value to encode: {x}&#34;


@_encode.register(str)
def _encode_str(x: str) -&gt; str:
    return x


@_encode.register(clingo.Symbol)
def _encode_symbol(x: clingo.Symbol) -&gt; str:
    return str(x)


@_encode.register(int)
def _encode_int(x: int) -&gt; int:
    return x


@_encode.register(ASTSequence)
def _encode_ast_seq(x: ASTSequence) -&gt; List[Any]:
    return [_encode(y) for y in x]


@_encode.register(StrSequence)
def _encode_str_seq(x: StrSequence) -&gt; List[Any]:
    return [_encode(y) for y in x]


@_encode.register(type(None))
def _encode_none(x: None) -&gt; None:
    return x


@_encode.register(AST)
def _encode_ast(x: AST) -&gt; Any:
    return ast_to_dict(x)


def ast_to_dict(x: AST) -&gt; dict:
    &#34;&#34;&#34;
    Convert the given ast node into a dictionary representation whose elements
    only involve the data structures: `dict`, `list`, `int`, and `str`.

    The resulting value can be used with other Python modules like the `yaml`
    or `pickle` modules.

    Parameters
    ----------
    x
        The ast to transform.

    Returns
    -------
    The corresponding Python representation.

    See Also
    --------
    dict_to_ast
    &#34;&#34;&#34;
    ret = {&#34;ast_type&#34;: str(x.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)}
    for key, val in x.items():
        if key == &#39;location&#39;:
            assert isinstance(val, Location)
            enc = location_to_str(val)
        else:
            enc = _encode(val)
        ret[key] = enc
    return ret


@singledispatch
def _decode(x: Any, key: str) -&gt; Any:
    raise RuntimeError(f&#34;unknown key/value to decode: {key}: {x}&#34;)


@_decode.register(str)
def _decode_str(x: str, key: str) -&gt; Any:
    if key == &#34;location&#34;:
        return str_to_location(x)

    if key == &#34;symbol&#34;:
        return clingo.parse_term(x)

    assert key in (&#34;name&#34;, &#34;id&#34;, &#34;code&#34;, &#34;elements&#34;, &#34;term&#34;, &#34;list&#34;, &#34;operator_name&#34;)
    return x


@_decode.register(int)
def _decode_int(x: int, key: str) -&gt; Any:
    # pylint: disable=unused-argument
    return x


@_decode.register(type(None))
def _decode_none(x: None, key: str) -&gt; Any:
    # pylint: disable=unused-argument
    return x


@_decode.register(list)
def _decode_list(x: list, key_: str) -&gt; Any:
    # pylint: disable=unused-argument
    return [_decode(y, &#34;list&#34;) for y in x]


@_decode.register(dict)
def _decode_dict(x: dict, key_: str) -&gt; Any:
    # pylint: disable=unused-argument
    return dict_to_ast(x)


def dict_to_ast(x: dict) -&gt; AST:
    &#34;&#34;&#34;
    Convert the Python dict representation of an AST node into an AST node.

    Parameters
    ----------
    x
        The Python representation of the AST.

    Returns
    -------
    The corresponding AST.

    See Also
    --------
    ast_to_dict
    &#34;&#34;&#34;
    return getattr(ast, x[&#39;ast_type&#39;])(**{key: _decode(value, key) for key, value in x.items() if key != &#34;ast_type&#34;})</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clingox.ast.ast_to_dict"><code class="name flex">
<span>def <span class="ident">ast_to_dict</span></span>(<span>x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the given ast node into a dictionary representation whose elements
only involve the data structures: <code>dict</code>, <code>list</code>, <code>int</code>, and <code>str</code>.</p>
<p>The resulting value can be used with other Python modules like the <code>yaml</code>
or <code>pickle</code> modules.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The ast to transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The corresponding Python representation.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.ast.dict_to_ast" href="#clingox.ast.dict_to_ast">dict_to_ast()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ast_to_dict(x: AST) -&gt; dict:
    &#34;&#34;&#34;
    Convert the given ast node into a dictionary representation whose elements
    only involve the data structures: `dict`, `list`, `int`, and `str`.

    The resulting value can be used with other Python modules like the `yaml`
    or `pickle` modules.

    Parameters
    ----------
    x
        The ast to transform.

    Returns
    -------
    The corresponding Python representation.

    See Also
    --------
    dict_to_ast
    &#34;&#34;&#34;
    ret = {&#34;ast_type&#34;: str(x.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)}
    for key, val in x.items():
        if key == &#39;location&#39;:
            assert isinstance(val, Location)
            enc = location_to_str(val)
        else:
            enc = _encode(val)
        ret[key] = enc
    return ret</code></pre>
</details>
</dd>
<dt id="clingox.ast.dict_to_ast"><code class="name flex">
<span>def <span class="ident">dict_to_ast</span></span>(<span>x: dict) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert the Python dict representation of an AST node into an AST node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The Python representation of the AST.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The corresponding AST.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.ast.ast_to_dict" href="#clingox.ast.ast_to_dict">ast_to_dict()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict_to_ast(x: dict) -&gt; AST:
    &#34;&#34;&#34;
    Convert the Python dict representation of an AST node into an AST node.

    Parameters
    ----------
    x
        The Python representation of the AST.

    Returns
    -------
    The corresponding AST.

    See Also
    --------
    ast_to_dict
    &#34;&#34;&#34;
    return getattr(ast, x[&#39;ast_type&#39;])(**{key: _decode(value, key) for key, value in x.items() if key != &#34;ast_type&#34;})</code></pre>
</details>
</dd>
<dt id="clingox.ast.location_to_str"><code class="name flex">
<span>def <span class="ident">location_to_str</span></span>(<span>loc: <a title="clingo.ast.Location" href="../clingo/ast.html#clingo.ast.Location">Location</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>This function transfroms a loctation object into a readable string.</p>
<p>Colons in the location will be quoted ensuring that the resulting is
parsable using <code><a title="clingox.ast.str_to_location" href="#clingox.ast.str_to_location">str_to_location()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong></dt>
<dd>The location to transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string representation of the given location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def location_to_str(loc: Location) -&gt; str:
    &#34;&#34;&#34;
    This function transfroms a loctation object into a readable string.

    Colons in the location will be quoted ensuring that the resulting is
    parsable using `str_to_location`.

    Parameters
    ----------
    loc
        The location to transform.

    Returns
    -------
    The string representation of the given location.
    &#34;&#34;&#34;
    begin, end = loc.begin, loc.end
    bf, ef = _quote(begin.filename), _quote(end.filename)
    ret = f&#34;{bf}:{begin.line}:{begin.column}&#34;
    dash, eq = True, bf == ef
    if not eq:
        ret += f&#34;{&#39;-&#39; if dash else &#39;:&#39;}{ef}&#34;
        dash = False
    eq = eq and begin.line == end.line
    if not eq:
        ret += f&#34;{&#39;-&#39; if dash else &#39;:&#39;}{end.line}&#34;
        dash = False
    eq = eq and begin.column == end.column
    if not eq:
        ret += f&#34;{&#39;-&#39; if dash else &#39;:&#39;}{end.column}&#34;
        dash = False
    return ret</code></pre>
</details>
</dd>
<dt id="clingox.ast.prefix_symbolic_atoms"><code class="name flex">
<span>def <span class="ident">prefix_symbolic_atoms</span></span>(<span>x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>, prefix: str) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Prefix all symbolic atoms in the given AST with the given string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The ast in which to prefix symbolic atom names.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The prefix to add.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.ast.rename_symbolic_atoms" href="#clingox.ast.rename_symbolic_atoms">rename_symbolic_atoms()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prefix_symbolic_atoms(x: AST, prefix: str) -&gt; AST:
    &#39;&#39;&#39;
    Prefix all symbolic atoms in the given AST with the given string.

    Parameters
    ----------
    x
        The ast in which to prefix symbolic atom names.
    prefix
        The prefix to add.

    Returns
    -------
    The rewritten AST.

    See Also
    --------
    rename_symbolic_atoms
    &#39;&#39;&#39;
    return rename_symbolic_atoms(x, lambda s: prefix + s)</code></pre>
</details>
</dd>
<dt id="clingox.ast.rename_symbolic_atoms"><code class="name flex">
<span>def <span class="ident">rename_symbolic_atoms</span></span>(<span>x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>, rename_function: Callable[[str], str]) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Rename all symbolic atoms in the given AST node with the given function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The ast in which to rename symbolic atoms.</dd>
<dt><strong><code>rename_function</code></strong></dt>
<dd>A function for renaming symbols.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_symbolic_atoms(x: AST, rename_function: Callable[[str], str]) -&gt; AST:
    &#39;&#39;&#39;
    Rename all symbolic atoms in the given AST node with the given function.

    Parameters
    ----------
    x
        The ast in which to rename symbolic atoms.
    rename_function
        A function for renaming symbols.

    Returns
    -------
    The rewritten AST.
    &#39;&#39;&#39;
    def renamer(term: AST):
        if term.ast_type == ASTType.UnaryOperation:
            return UnaryOperation(term.location, term.operator_type, renamer(term.argument))
        if term.ast_type == ASTType.SymbolicTerm:
            sym = term.symbol
            new_name = rename_function(sym.name)
            return SymbolicTerm(term.location, clingo.Function(new_name, sym.arguments, sym.positive))
        if term.ast_type == ASTType.Function:
            return Function(term.location, rename_function(term.name), term.arguments, term.external)
        return term

    return rewrite_symbolic_atoms(x, renamer)</code></pre>
</details>
</dd>
<dt id="clingox.ast.str_to_location"><code class="name flex">
<span>def <span class="ident">str_to_location</span></span>(<span>loc: str) ‑> <a title="clingo.ast.Location" href="../clingo/ast.html#clingo.ast.Location">Location</a></span>
</code></dt>
<dd>
<div class="desc"><p>This function parses a location from its string representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong></dt>
<dd>The string to parse.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The parsed location.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.ast.location_to_str" href="#clingox.ast.location_to_str">location_to_str()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_to_location(loc: str) -&gt; Location:
    &#34;&#34;&#34;
    This function parses a location from its string representation.

    Parameters
    ----------
    loc
        The string to parse.

    Returns
    -------
    The parsed location.

    See Also
    --------
    location_to_str
    &#34;&#34;&#34;
    m = fullmatch(
        r&#39;(?P&lt;bf&gt;([^\\:]|\\\\|\\:)*):(?P&lt;bl&gt;[0-9]*):(?P&lt;bc&gt;[0-9]+)&#39;
        r&#39;(-(((?P&lt;ef&gt;([^\\:]|\\\\|\\:)*):)?(?P&lt;el&gt;[0-9]*):)?(?P&lt;ec&gt;[0-9]+))?&#39;, loc)
    if not m:
        raise RuntimeError(&#39;could not parse location&#39;)
    begin = Position(_unquote(m[&#39;bf&#39;]), int(m[&#39;bl&#39;]), int(m[&#39;bc&#39;]))
    end = Position(_unquote(_s(m, &#39;bf&#39;, &#39;ef&#39;)), int(_s(m, &#39;bl&#39;, &#39;el&#39;)), int(_s(m, &#39;bc&#39;, &#39;ec&#39;)))
    return Location(begin, end)</code></pre>
</details>
</dd>
<dt id="clingox.ast.theory_parser_from_definition"><code class="name flex">
<span>def <span class="ident">theory_parser_from_definition</span></span>(<span>x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingox.ast.TheoryParser" href="#clingox.ast.TheoryParser">TheoryParser</a></span>
</code></dt>
<dd>
<div class="desc"><p>Turn an AST node of type TheoryDefinition into a TheoryParser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>An AST representing a theory definition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The corresponding <code><a title="clingox.ast.TheoryParser" href="#clingox.ast.TheoryParser">TheoryParser</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def theory_parser_from_definition(x: AST) -&gt; TheoryParser:
    &#34;&#34;&#34;
    Turn an AST node of type TheoryDefinition into a TheoryParser.

    Parameters
    ----------
    x
        An AST representing a theory definition.

    Returns
    -------
    The corresponding `TheoryParser`.
    &#34;&#34;&#34;
    assert x.ast_type == ASTType.TheoryDefinition

    terms = {}
    atoms = {}

    for term_def in x.terms:
        term_table = {}

        for op_def in term_def.operators:
            op_assoc: Associativity
            if op_def.operator_type == TheoryOperatorType.BinaryLeft:
                op_type = Arity.Binary
                op_assoc = Associativity.Left
            elif op_def.operator_type == TheoryOperatorType.BinaryRight:
                op_type = Arity.Binary
                op_assoc = Associativity.Right
            else:
                op_type = Arity.Unary
                op_assoc = Associativity.NoAssociativity

            term_table[(op_def.name, op_type)] = (op_def.priority, op_assoc)

        terms[term_def.name] = term_table

    for atom_def in x.atoms:
        guard = None
        if atom_def.guard is not None:
            guard = (atom_def.guard.operators, atom_def.guard.term)

        atoms[(atom_def.name, atom_def.arity)] = (atom_def.atom_type, atom_def.term, guard)

    return TheoryParser(terms, atoms)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingox.ast.Arity"><code class="flex name class">
<span>class <span class="ident">Arity</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of operator arities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Arity(Enum):
    &#39;&#39;&#39;
    Enumeration of operator arities.
    &#39;&#39;&#39;
    # pylint:disable=invalid-name
    Unary = 1
    Binary = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingox.ast.Arity.Binary"><code class="name">var <span class="ident">Binary</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingox.ast.Arity.Unary"><code class="name">var <span class="ident">Unary</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="clingox.ast.Associativity"><code class="flex name class">
<span>class <span class="ident">Associativity</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of operator associativities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Associativity(Enum):
    &#39;&#39;&#39;
    Enumeration of operator associativities.
    &#39;&#39;&#39;
    # pylint: disable=invalid-name
    Left = auto()
    Right = auto()
    NoAssociativity = auto()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingox.ast.Associativity.Left"><code class="name">var <span class="ident">Left</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingox.ast.Associativity.NoAssociativity"><code class="name">var <span class="ident">NoAssociativity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingox.ast.Associativity.Right"><code class="name">var <span class="ident">Right</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="clingox.ast.TheoryParser"><code class="flex name class">
<span>class <span class="ident">TheoryParser</span></span>
<span>(</span><span>terms: Mapping[str, Union[Mapping[Tuple[str, <a title="clingox.ast.Arity" href="#clingox.ast.Arity">Arity</a>], Tuple[int, <a title="clingox.ast.Associativity" href="#clingox.ast.Associativity">Associativity</a>]], <a title="clingox.ast.TheoryTermParser" href="#clingox.ast.TheoryTermParser">TheoryTermParser</a>]], atoms: Mapping[Tuple[str, int], Tuple[<a title="clingo.ast.TheoryAtomType" href="../clingo/ast.html#clingo.ast.TheoryAtomType">TheoryAtomType</a>, str, Optional[Tuple[List[str], str]]]])</span>
</code></dt>
<dd>
<div class="desc"><p>This class parses theory atoms in the same way as clingo's internal parser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>terms</code></strong></dt>
<dd>Mapping from term identifiers to <code><a title="clingox.ast.TheoryTermParser" href="#clingox.ast.TheoryTermParser">TheoryTermParser</a></code>s. If an operator
table is given, the <code><a title="clingox.ast.TheoryTermParser" href="#clingox.ast.TheoryTermParser">TheoryTermParser</a></code> is constructed from this table.</dd>
<dt><strong><code>atoms</code></strong></dt>
<dd>Mapping from atom name/arity pairs to tuples defining the acceptable
structure of the theory atom.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryParser(Transformer):
    &#34;&#34;&#34;
    This class parses theory atoms in the same way as clingo&#39;s internal parser.

    Parameters
    ----------
    terms
        Mapping from term identifiers to `TheoryTermParser`s. If an operator
        table is given, the `TheoryTermParser` is constructed from this table.

    atoms
        Mapping from atom name/arity pairs to tuples defining the acceptable
        structure of the theory atom.
    &#34;&#34;&#34;
    # pylint: disable=invalid-name
    _table: Mapping[Tuple[str, int],
                    Tuple[TheoryAtomType,
                          TheoryTermParser,
                          Optional[Tuple[Set[str], TheoryTermParser]]]]
    _in_body: bool
    _in_head: bool
    _is_directive: bool

    def __init__(self, terms: Mapping[str, Union[OperatorTable, TheoryTermParser]], atoms: AtomTable):
        self._reset()

        term_parsers = {}
        for term_key, parser in terms.items():
            if isinstance(parser, TheoryTermParser):
                term_parsers[term_key] = parser
            else:
                term_parsers[term_key] = TheoryTermParser(parser)

        self._table = {}
        for atom_key, (atom_type, term_key, guard) in atoms.items():
            guard_table = None
            if guard is not None:
                guard_table = (set(guard[0]), term_parsers[guard[1]])
            self._table[atom_key] = (atom_type, term_parsers[term_key], guard_table)

    def _reset(self, in_head=True, in_body=True, is_directive=True):
        &#34;&#34;&#34;
        Set state information about active scope.
        &#34;&#34;&#34;
        self._in_head = in_head
        self._in_body = in_body
        self._is_directive = is_directive

    def _visit_body(self, x: AST) -&gt; AST:
        try:
            self._reset(False, True, False)
            old = x.body
            new = self.visit_sequence(old)
            return x if new is old else x.update(body=new)
        finally:
            self._reset()

    def visit_Rule(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body and head.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        ret = self._visit_body(x)
        try:
            self._reset(True, False, not x.body)
            head = self(x.head)
            if head is not x.head:
                if ret is x:
                    ret = copy(ret)
                ret.head = head
        finally:
            self._reset()

        return ret

    def visit_ShowTerm(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_Minimize(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_Edge(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_Heuristic(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_ProjectAtom(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse theory atoms in body.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return self._visit_body(x)

    def visit_TheoryAtom(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse the given theory atom.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        name = x.term.name
        arity = len(x.term.arguments)
        if (name, arity) not in self._table:
            raise RuntimeError(f&#34;theory atom definiton not found: {location_to_str(x.location)}&#34;)

        type_, element_parser, guard_table = self._table[(name, arity)]
        if type_ == TheoryAtomType.Head and not self._in_head:
            raise RuntimeError(f&#34;theory atom only accepted in head: {location_to_str(x.location)}&#34;)
        if type_ == TheoryAtomType.Body and not self._in_body:
            raise RuntimeError(f&#34;theory atom only accepted in body: {location_to_str(x.location)}&#34;)
        if type_ == TheoryAtomType.Directive and not (self._in_head and self._is_directive):
            raise RuntimeError(f&#34;theory atom must be a directive: {location_to_str(x.location)}&#34;)

        x = copy(x)
        x.term = element_parser(x.term)
        x.elements = element_parser.visit_sequence(x.elements)

        if x.guard is not None:
            if guard_table is None:
                raise RuntimeError(f&#34;unexpected guard in theory atom: {location_to_str(x.location)}&#34;)

            guards, guard_parser = guard_table
            if x.guard.operator_name not in guards:
                raise RuntimeError(f&#34;unexpected guard in theory atom: {location_to_str(x.location)}&#34;)

            x.guard = copy(x.guard)
            x.guard.term = guard_parser(x.guard.term)

        return x</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clingo.ast.Transformer" href="../clingo/ast.html#clingo.ast.Transformer">Transformer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingox.ast.TheoryParser.visit_Edge"><code class="name flex">
<span>def <span class="ident">visit_Edge</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse theory atoms in body.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Edge(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse theory atoms in body.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    return self._visit_body(x)</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryParser.visit_Heuristic"><code class="name flex">
<span>def <span class="ident">visit_Heuristic</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse theory atoms in body.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Heuristic(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse theory atoms in body.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    return self._visit_body(x)</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryParser.visit_Minimize"><code class="name flex">
<span>def <span class="ident">visit_Minimize</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse theory atoms in body.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Minimize(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse theory atoms in body.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    return self._visit_body(x)</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryParser.visit_ProjectAtom"><code class="name flex">
<span>def <span class="ident">visit_ProjectAtom</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse theory atoms in body.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ProjectAtom(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse theory atoms in body.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    return self._visit_body(x)</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryParser.visit_Rule"><code class="name flex">
<span>def <span class="ident">visit_Rule</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse theory atoms in body and head.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Rule(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse theory atoms in body and head.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    ret = self._visit_body(x)
    try:
        self._reset(True, False, not x.body)
        head = self(x.head)
        if head is not x.head:
            if ret is x:
                ret = copy(ret)
            ret.head = head
    finally:
        self._reset()

    return ret</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryParser.visit_ShowTerm"><code class="name flex">
<span>def <span class="ident">visit_ShowTerm</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse theory atoms in body.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ShowTerm(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse theory atoms in body.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    return self._visit_body(x)</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryParser.visit_TheoryAtom"><code class="name flex">
<span>def <span class="ident">visit_TheoryAtom</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse the given theory atom.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_TheoryAtom(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse the given theory atom.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    name = x.term.name
    arity = len(x.term.arguments)
    if (name, arity) not in self._table:
        raise RuntimeError(f&#34;theory atom definiton not found: {location_to_str(x.location)}&#34;)

    type_, element_parser, guard_table = self._table[(name, arity)]
    if type_ == TheoryAtomType.Head and not self._in_head:
        raise RuntimeError(f&#34;theory atom only accepted in head: {location_to_str(x.location)}&#34;)
    if type_ == TheoryAtomType.Body and not self._in_body:
        raise RuntimeError(f&#34;theory atom only accepted in body: {location_to_str(x.location)}&#34;)
    if type_ == TheoryAtomType.Directive and not (self._in_head and self._is_directive):
        raise RuntimeError(f&#34;theory atom must be a directive: {location_to_str(x.location)}&#34;)

    x = copy(x)
    x.term = element_parser(x.term)
    x.elements = element_parser.visit_sequence(x.elements)

    if x.guard is not None:
        if guard_table is None:
            raise RuntimeError(f&#34;unexpected guard in theory atom: {location_to_str(x.location)}&#34;)

        guards, guard_parser = guard_table
        if x.guard.operator_name not in guards:
            raise RuntimeError(f&#34;unexpected guard in theory atom: {location_to_str(x.location)}&#34;)

        x.guard = copy(x.guard)
        x.guard.term = guard_parser(x.guard.term)

    return x</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clingo.ast.Transformer" href="../clingo/ast.html#clingo.ast.Transformer">Transformer</a></b></code>:
<ul class="hlist">
<li><code><a title="clingo.ast.Transformer.visit" href="../clingo/ast.html#clingo.ast.Transformer.visit">visit</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_children" href="../clingo/ast.html#clingo.ast.Transformer.visit_children">visit_children</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_sequence" href="../clingo/ast.html#clingo.ast.Transformer.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clingox.ast.TheoryTermParser"><code class="flex name class">
<span>class <span class="ident">TheoryTermParser</span></span>
<span>(</span><span>table: Union[Mapping[Tuple[str, <a title="clingox.ast.Arity" href="#clingox.ast.Arity">Arity</a>], Tuple[int, <a title="clingox.ast.Associativity" href="#clingox.ast.Associativity">Associativity</a>]], <a title="clingox.ast.TheoryUnparsedTermParser" href="#clingox.ast.TheoryUnparsedTermParser">TheoryUnparsedTermParser</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Parser for theory terms in clingo's AST that works like the inbuilt one.</p>
<p>This is implemented as a transformer that traverses the AST replacing all
terms found.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong></dt>
<dd>This must either be a table of operators or a <code><a title="clingox.ast.TheoryUnparsedTermParser" href="#clingox.ast.TheoryUnparsedTermParser">TheoryUnparsedTermParser</a></code>.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.ast.TheoryUnparsedTermParser" href="#clingox.ast.TheoryUnparsedTermParser">TheoryUnparsedTermParser</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryTermParser(Transformer):
    &#34;&#34;&#34;
    Parser for theory terms in clingo&#39;s AST that works like the inbuilt one.

    This is implemented as a transformer that traverses the AST replacing all
    terms found.

    Parameters
    ----------
    table
        This must either be a table of operators or a `TheoryUnparsedTermParser`.

    See Also
    --------
    TheoryUnparsedTermParser
    &#34;&#34;&#34;
    # pylint: disable=invalid-name

    def __init__(self, table: Union[OperatorTable, TheoryUnparsedTermParser]):
        self._parser = table if isinstance(table, TheoryUnparsedTermParser) else TheoryUnparsedTermParser(table)

    def visit_TheoryFunction(self, x) -&gt; AST:
        &#34;&#34;&#34;
        Parse the theory function and check if it agrees with the grammar.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        arity = None
        if len(x.arguments) == 1:
            arity = Arity.Unary
        if len(x.arguments) == 2:
            arity = Arity.Binary
        if arity is not None and is_operator(x.name):
            self._parser.check_operator(x.name, arity, x.location)

        return x.update(**self.visit_children(x))

    def visit_TheoryUnparsedTerm(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parse the given unparsed term.

        Parameters
        ----------
        x
            The AST to rewrite.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        return cast(AST, self(self._parser.parse(x)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clingo.ast.Transformer" href="../clingo/ast.html#clingo.ast.Transformer">Transformer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingox.ast.TheoryTermParser.visit_TheoryFunction"><code class="name flex">
<span>def <span class="ident">visit_TheoryFunction</span></span>(<span>self, x) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse the theory function and check if it agrees with the grammar.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_TheoryFunction(self, x) -&gt; AST:
    &#34;&#34;&#34;
    Parse the theory function and check if it agrees with the grammar.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    arity = None
    if len(x.arguments) == 1:
        arity = Arity.Unary
    if len(x.arguments) == 2:
        arity = Arity.Binary
    if arity is not None and is_operator(x.name):
        self._parser.check_operator(x.name, arity, x.location)

    return x.update(**self.visit_children(x))</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryTermParser.visit_TheoryUnparsedTerm"><code class="name flex">
<span>def <span class="ident">visit_TheoryUnparsedTerm</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse the given unparsed term.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to rewrite.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_TheoryUnparsedTerm(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parse the given unparsed term.

    Parameters
    ----------
    x
        The AST to rewrite.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    return cast(AST, self(self._parser.parse(x)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clingo.ast.Transformer" href="../clingo/ast.html#clingo.ast.Transformer">Transformer</a></b></code>:
<ul class="hlist">
<li><code><a title="clingo.ast.Transformer.visit" href="../clingo/ast.html#clingo.ast.Transformer.visit">visit</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_children" href="../clingo/ast.html#clingo.ast.Transformer.visit_children">visit_children</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_sequence" href="../clingo/ast.html#clingo.ast.Transformer.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clingox.ast.TheoryUnparsedTermParser"><code class="flex name class">
<span>class <span class="ident">TheoryUnparsedTermParser</span></span>
<span>(</span><span>table: Mapping[Tuple[str, <a title="clingox.ast.Arity" href="#clingox.ast.Arity">Arity</a>], Tuple[int, <a title="clingox.ast.Associativity" href="#clingox.ast.Associativity">Associativity</a>]])</span>
</code></dt>
<dd>
<div class="desc"><p>Parser for unparsed theory terms in clingo's AST that works like the
inbuilt one.</p>
<p>Note that associativity for unary operators is ignored and binary
operators must use either <code><a title="clingox.ast.Associativity.Left" href="#clingox.ast.Associativity.Left">Associativity.Left</a></code> or <code><a title="clingox.ast.Associativity.Right" href="#clingox.ast.Associativity.Right">Associativity.Right</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong></dt>
<dd>Mapping of operator/arity pairs to priority/associativity pairs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryUnparsedTermParser:
    &#34;&#34;&#34;
    Parser for unparsed theory terms in clingo&#39;s AST that works like the
    inbuilt one.

    Note that associativity for unary operators is ignored and binary
    operators must use either `Associativity.Left` or `Associativity.Right`.

    Parameters
    ----------
    table
        Mapping of operator/arity pairs to priority/associativity pairs.
    &#34;&#34;&#34;
    _stack: List[Tuple[str, Arity]]
    _terms: List[AST]
    _table: OperatorTable

    def __init__(self, table: OperatorTable):
        self._stack = []
        self._terms = []
        self._table = table

    def _priority_and_associativity(self, operator: str) -&gt; Tuple[int, Associativity]:
        &#34;&#34;&#34;
        Get priority and associativity of the given binary operator.
        &#34;&#34;&#34;
        return self._table[(operator, Arity.Binary)]

    def _priority(self, operator: str, arity: Arity) -&gt; int:
        &#34;&#34;&#34;
        Get priority of the given unary or binary operator.
        &#34;&#34;&#34;
        return self._table[(operator, arity)][0]

    def _check(self, operator: str) -&gt; bool:
        &#34;&#34;&#34;
        Returns true if the stack has to be reduced because of the precedence
        of the given binary operator is lower than the preceeding operator on
        the stack.
        &#34;&#34;&#34;
        if not self._stack:
            return False
        priority, associativity = self._priority_and_associativity(operator)
        previous_priority = self._priority(*self._stack[-1])
        return (previous_priority &gt; priority or
                (previous_priority == priority and associativity == Associativity.Left))

    def _reduce(self) -&gt; None:
        &#34;&#34;&#34;
        Combines the last unary or binary term on the stack.
        &#34;&#34;&#34;
        b = self._terms.pop()
        operator, arity = self._stack.pop()
        if arity == Arity.Unary:
            self._terms.append(TheoryFunction(b.location, operator, [b]))
        else:
            a = self._terms.pop()
            loc = Location(a.location.begin, b.location.end)
            self._terms.append(TheoryFunction(loc, operator, [a, b]))

    def check_operator(self, operator: str, arity: Arity, location: Location) -&gt; None:
        &#34;&#34;&#34;
        Check if the given operator is in the parse table raising a runtime
        error if absent.

        Parameters
        ----------
        operator
            The operator name.
        arity
            The arity of the operator.
        location
            Location of the operator for error reporting.
        &#34;&#34;&#34;
        if (operator, arity) not in self._table:
            raise RuntimeError(f&#34;cannot parse operator `{operator}`: {location_to_str(location)}&#34;)

    def parse(self, x: AST) -&gt; AST:
        &#34;&#34;&#34;
        Parses the given unparsed term, replacing it by nested theory
        functions.

        Parameters
        ----------
        x
            The AST to parse.

        Returns
        -------
        The rewritten AST.
        &#34;&#34;&#34;
        del self._stack[:]
        del self._terms[:]

        arity = Arity.Unary

        for element in x.elements:
            for operator in element.operators:
                self.check_operator(operator, arity, x.location)

                while arity == Arity.Binary and self._check(operator):
                    self._reduce()

                self._stack.append((operator, arity))
                arity = Arity.Unary

            self._terms.append(element.term)
            arity = Arity.Binary

        while self._stack:
            self._reduce()

        return self._terms[0]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="clingox.ast.TheoryUnparsedTermParser.check_operator"><code class="name flex">
<span>def <span class="ident">check_operator</span></span>(<span>self, operator: str, arity: <a title="clingox.ast.Arity" href="#clingox.ast.Arity">Arity</a>, location: <a title="clingo.ast.Location" href="../clingo/ast.html#clingo.ast.Location">Location</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the given operator is in the parse table raising a runtime
error if absent.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>operator</code></strong></dt>
<dd>The operator name.</dd>
<dt><strong><code>arity</code></strong></dt>
<dd>The arity of the operator.</dd>
<dt><strong><code>location</code></strong></dt>
<dd>Location of the operator for error reporting.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_operator(self, operator: str, arity: Arity, location: Location) -&gt; None:
    &#34;&#34;&#34;
    Check if the given operator is in the parse table raising a runtime
    error if absent.

    Parameters
    ----------
    operator
        The operator name.
    arity
        The arity of the operator.
    location
        Location of the operator for error reporting.
    &#34;&#34;&#34;
    if (operator, arity) not in self._table:
        raise RuntimeError(f&#34;cannot parse operator `{operator}`: {location_to_str(location)}&#34;)</code></pre>
</details>
</dd>
<dt id="clingox.ast.TheoryUnparsedTermParser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, x: <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="../clingo/ast.html#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parses the given unparsed term, replacing it by nested theory
functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The AST to parse.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rewritten AST.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, x: AST) -&gt; AST:
    &#34;&#34;&#34;
    Parses the given unparsed term, replacing it by nested theory
    functions.

    Parameters
    ----------
    x
        The AST to parse.

    Returns
    -------
    The rewritten AST.
    &#34;&#34;&#34;
    del self._stack[:]
    del self._terms[:]

    arity = Arity.Unary

    for element in x.elements:
        for operator in element.operators:
            self.check_operator(operator, arity, x.location)

            while arity == Arity.Binary and self._check(operator):
                self._reduce()

            self._stack.append((operator, arity))
            arity = Arity.Unary

        self._terms.append(element.term)
        arity = Arity.Binary

    while self._stack:
        self._reduce()

    return self._terms[0]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#theory-parsing-examples">Theory Parsing Examples</a></li>
<li><a href="#ast-to-dict-conversion-example">AST to dict Conversion Example</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clingox" href="index.html">clingox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clingox.ast.ast_to_dict" href="#clingox.ast.ast_to_dict">ast_to_dict</a></code></li>
<li><code><a title="clingox.ast.dict_to_ast" href="#clingox.ast.dict_to_ast">dict_to_ast</a></code></li>
<li><code><a title="clingox.ast.location_to_str" href="#clingox.ast.location_to_str">location_to_str</a></code></li>
<li><code><a title="clingox.ast.prefix_symbolic_atoms" href="#clingox.ast.prefix_symbolic_atoms">prefix_symbolic_atoms</a></code></li>
<li><code><a title="clingox.ast.rename_symbolic_atoms" href="#clingox.ast.rename_symbolic_atoms">rename_symbolic_atoms</a></code></li>
<li><code><a title="clingox.ast.str_to_location" href="#clingox.ast.str_to_location">str_to_location</a></code></li>
<li><code><a title="clingox.ast.theory_parser_from_definition" href="#clingox.ast.theory_parser_from_definition">theory_parser_from_definition</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingox.ast.Arity" href="#clingox.ast.Arity">Arity</a></code></h4>
<ul class="">
<li><code><a title="clingox.ast.Arity.Binary" href="#clingox.ast.Arity.Binary">Binary</a></code></li>
<li><code><a title="clingox.ast.Arity.Unary" href="#clingox.ast.Arity.Unary">Unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.ast.Associativity" href="#clingox.ast.Associativity">Associativity</a></code></h4>
<ul class="">
<li><code><a title="clingox.ast.Associativity.Left" href="#clingox.ast.Associativity.Left">Left</a></code></li>
<li><code><a title="clingox.ast.Associativity.NoAssociativity" href="#clingox.ast.Associativity.NoAssociativity">NoAssociativity</a></code></li>
<li><code><a title="clingox.ast.Associativity.Right" href="#clingox.ast.Associativity.Right">Right</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.ast.TheoryParser" href="#clingox.ast.TheoryParser">TheoryParser</a></code></h4>
<ul class="two-column">
<li><code><a title="clingox.ast.TheoryParser.visit_Edge" href="#clingox.ast.TheoryParser.visit_Edge">visit_Edge</a></code></li>
<li><code><a title="clingox.ast.TheoryParser.visit_Heuristic" href="#clingox.ast.TheoryParser.visit_Heuristic">visit_Heuristic</a></code></li>
<li><code><a title="clingox.ast.TheoryParser.visit_Minimize" href="#clingox.ast.TheoryParser.visit_Minimize">visit_Minimize</a></code></li>
<li><code><a title="clingox.ast.TheoryParser.visit_ProjectAtom" href="#clingox.ast.TheoryParser.visit_ProjectAtom">visit_ProjectAtom</a></code></li>
<li><code><a title="clingox.ast.TheoryParser.visit_Rule" href="#clingox.ast.TheoryParser.visit_Rule">visit_Rule</a></code></li>
<li><code><a title="clingox.ast.TheoryParser.visit_ShowTerm" href="#clingox.ast.TheoryParser.visit_ShowTerm">visit_ShowTerm</a></code></li>
<li><code><a title="clingox.ast.TheoryParser.visit_TheoryAtom" href="#clingox.ast.TheoryParser.visit_TheoryAtom">visit_TheoryAtom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.ast.TheoryTermParser" href="#clingox.ast.TheoryTermParser">TheoryTermParser</a></code></h4>
<ul class="">
<li><code><a title="clingox.ast.TheoryTermParser.visit_TheoryFunction" href="#clingox.ast.TheoryTermParser.visit_TheoryFunction">visit_TheoryFunction</a></code></li>
<li><code><a title="clingox.ast.TheoryTermParser.visit_TheoryUnparsedTerm" href="#clingox.ast.TheoryTermParser.visit_TheoryUnparsedTerm">visit_TheoryUnparsedTerm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.ast.TheoryUnparsedTermParser" href="#clingox.ast.TheoryUnparsedTermParser">TheoryUnparsedTermParser</a></code></h4>
<ul class="">
<li><code><a title="clingox.ast.TheoryUnparsedTermParser.check_operator" href="#clingox.ast.TheoryUnparsedTermParser.check_operator">check_operator</a></code></li>
<li><code><a title="clingox.ast.TheoryUnparsedTermParser.parse" href="#clingox.ast.TheoryUnparsedTermParser.parse">parse</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>clingo.ast API documentation</title>
<meta name="description" content="Module to work with clingo&#39;s non-ground program representation â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<nav class="http-server-breadcrumbs">
<a href="https://potassco.org/clingo/python-api/5.5/">All packages</a>
:: <a href="https://potassco.org/clingo/python-api/5.5/clingo/">clingo</a>
</nav>
<h1 class="title">Module <code>clingo.ast</code></h1>
</header>
<section id="section-intro">
<p>Module to work with clingo's non-ground program representation.</p>
<h2 id="grammar">Grammar</h2>
<p>The grammar below defines valid ASTs. For each upper case identifier there is a
matching function in the module. Arguments follow in parenthesis: each having a
type given on the right-hand side of the colon. The symbols <code>?</code>, <code>*</code>, and <code>+</code>
are used to denote optional arguments (<code>None</code> encodes abscence), list
arguments, and non-empty list arguments.</p>
<pre><code># Terms

term = SymbolicTerm
        ( location : Location
        , symbol   : clingo.Symbol
        )
     | Variable
        ( location : Location
        , name     : str
        )
     | UnaryOperation
        ( location      : Location
        , operator_type : UnaryOperator
        , argument      : term
        )
     | BinaryOperation
        ( location      : Location
        , operator_type : BinaryOperator
        , left          : term
        , right         : term
        )
     | Interval
        ( location : Location
        , left     : term
        , right    : term
        )
     | Function
        ( location  : Location
        , name      : str
        , arguments : term*
        , external  : bool
        )
     | Pool
        ( location  : Location
        , arguments : term*
        )

csp_term = CSPSum
            ( location : Location
            , terms    : CSPProduct
                          ( location    : Location
                          , coefficient : term
                          , variable    : term?
                          )*
            )

theory_term = SymbolicTerm
               ( location : Location
               , symbol   : clingo.Symbol
               )
            | Variable
               ( location : Location
               , name     : str
               )
            | TheorySequence
               ( location : Location
               , sequence_type : TheorySequenceType
               , terms         : theory_term*
               )
            | TheoryFunction
               ( location  : Location
               , name      : str
               , arguments : theory_term*
               )
            | TheoryUnparsedTerm
               ( location : Location
               , elements : TheoryUnparsedTermElement
                             ( operators : str*
                             , term      : theory_term
                             )+
               )

# Literals

symbolic_atom = SymbolicAtom
                 ( symbol : term
                 )

literal = Literal
           ( location : Location
           , sign     : Sign
           , atom     : Comparison
                         ( comparison : ComparisonOperator
                         , left       : term
                         , right      : term
                         )
                      | BooleanConstant
                         ( value : bool
                         )
                      | symbolic_atom
           )

        | CSPLiteral
           ( location : Location
           , term     : csp_term
           , guards   : CSPGuard
                         ( comparison : ComparisonOperator
                         , term       : csp_term
                         )+
           )

# Head and Body Literals

aggregate_guard = AggregateGuard
                   ( comparison : ComparisonOperator
                   , term       : term
                   )

conditional_literal = ConditionalLiteral
                       ( location  : Location
                       , literal   : Literal
                       , condition : Literal*
                       )

aggregate = Aggregate
             ( location    : Location
             , left_guard  : aggregate_guard?
             , elements    : conditional_literal*
             , right_guard : aggregate_guard?
             )

theory_atom = TheoryAtom
               ( location : Location
               , term     : term
               , elements : TheoryAtomElement
                             ( terms     : theory_term*
                             , condition : literal*
                             )*
               , guard    : TheoryGuard
                             ( operator_name : str
                             , term          : theory_term
                             )?
               )

body_atom = aggregate
          | BodyAggregate
             ( location    : Location
             , left_guard  : aggregate_guard?
             , function    : AggregateFunction
             , elements    : BodyAggregateElement
                              ( terms     : term*
                              , condition : literal*
                              )*
             , right_guard : aggregate_guard?
             )
          | Disjoint
             ( location : Location
             , elements : DisjointElement
                           ( location  : Location
                           , terms     : term*
                           , term      : csp_term
                           , condition : literal*
                           )*
             )
          | theory_atom

body_literal = literal
             | conditional_literal
             | Literal
                ( location : Location
                , sign     : Sign
                , atom     : body_atom
                )

head = literal
     | aggregate
     | HeadAggregate
        ( location    : Location
        , left_guard  : aggregate_guard?
        , function    : AggregateFunction
        , elements    : HeadAggregateElement
                         ( terms     : term*
                         , condition : conditional_literal
                         )*
        , right_guard : aggregate_guard?
        )
     | Disjunction
        ( location : Location
        , elements : conditional_literal*
        )
     | theory_atom

# Statements

statement = Rule
             ( location : Location
             , head     : head
             , body     : body_literal*
             )
          | Definition
             ( location   : Location
             , name       : str
             , value      : term
             , is_default : bool
             )
          | ShowSignature
             ( location   : Location
             , name       : str
             , arity      : int
             , sign       : bool
             , csp        : bool
             )
          | Defined
             ( location   : Location
             , name       : str
             , arity      : int
             , sign       : bool
             )
          | ShowTerm
             ( location : Location
             , term     : term
             , body     : body_literal*
             , csp      : bool
             )
          | Minimize
             ( location : Location
             , weight   : term
             , priority : term
             , terms    : term*
             , body     : body_literal*
             )
          | Script
             ( location : Location
             , name     : str
             , code     : str
             )
          | Program
             ( location   : Location
             , name       : str
             , parameters : Id
                             ( location : Location
                             , id       : str
                             )*
             )
          | External
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             , type     : term
             )
          | Edge
             ( location : Location
             , u        : term
             , v        : term
             , body     : body_literal*
             )
          | Heuristic
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             , bias     : term
             , priority : term
             , modifier : term
             )
          | ProjectAtom
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             )
          | ProjectSignature
             ( location : Location
             , name     : str
             , arity    : int
             , sign     : bool
             )
          | TheoryDefinition
             ( location : Location
             , name     : str
             , terms    : TheoryTermDefinition
                           ( location  : Location
                           , name      : str
                           , operators : TheoryOperatorDefinition
                                          ( location      : Location
                                          , name          : str
                                          , priority      : int
                                          , operator_type : TheoryOperatorType
                                          )*
                           )*
             , atoms    : TheoryAtomDefinition
                           ( location  : Location
                           , atom_type : TheoryAtomType
                           , name      : str
                           , arity     : int
                           , term      : str
                           , guard     : TheoryGuardDefinition
                                          ( operators : str*
                                          , term      : str
                                          )?
                           )*
             )
</code></pre>
<h2 id="examples">Examples</h2>
<p>The following example parses a program from a string and passes the resulting
<code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> to the builder:</p>
<pre><code>&gt;&gt;&gt; from clingo import Control, ast
&gt;&gt;&gt; from clingo.ast import Location, ProgramBuilder, Position, parse_string
&gt;&gt;&gt;
&gt;&gt;&gt; ctl = Control()
&gt;&gt;&gt;
&gt;&gt;&gt; with ProgramBuilder(ctl) as bld:
...     # parse from string
...     parse_string('a.', bld.add)
...     # build rule manually
...     pos = Position('&lt;string&gt;', 1, 1)
...     loc = Location(pos, pos)
...     fun = ast.Function(loc, 'b', [], False)
...     atm = ast.SymbolicAtom(fun)
...     lit = ast.Literal(loc, ast.Sign.NoSign, atm)
...     bld.add(ast.Rule(loc, lit, []))
...
&gt;&gt;&gt; ctl.ground([('base', [])])
&gt;&gt;&gt; print(ctl.solve(on_model=print))
a b
SAT
</code></pre>
<p>The next example shows how to transform ASTs using the <code><a title="clingo.ast.Transformer" href="#clingo.ast.Transformer">Transformer</a></code> class:</p>
<pre><code>&gt;&gt;&gt; from clingo.ast import Transformer, Variable, parse_string
&gt;&gt;&gt;
&gt;&gt;&gt; class VariableRenamer(Transformer):
...     def visit_Variable(self, node):
...         return node.update(name='_' + node.name)
...
&gt;&gt;&gt; vrt = VariableRenamer()
&gt;&gt;&gt; parse_string('p(X) :- q(X).', lambda stm: print(str(vrt(stm))))
#program base.
p(_X) :- q(_X).
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Module to work with clingo&#39;s non-ground program representation.

Grammar
-------
The grammar below defines valid ASTs. For each upper case identifier there is a
matching function in the module. Arguments follow in parenthesis: each having a
type given on the right-hand side of the colon. The symbols `?`, `*`, and `+`
are used to denote optional arguments (`None` encodes abscence), list
arguments, and non-empty list arguments.

```
# Terms

term = SymbolicTerm
        ( location : Location
        , symbol   : clingo.Symbol
        )
     | Variable
        ( location : Location
        , name     : str
        )
     | UnaryOperation
        ( location      : Location
        , operator_type : UnaryOperator
        , argument      : term
        )
     | BinaryOperation
        ( location      : Location
        , operator_type : BinaryOperator
        , left          : term
        , right         : term
        )
     | Interval
        ( location : Location
        , left     : term
        , right    : term
        )
     | Function
        ( location  : Location
        , name      : str
        , arguments : term*
        , external  : bool
        )
     | Pool
        ( location  : Location
        , arguments : term*
        )

csp_term = CSPSum
            ( location : Location
            , terms    : CSPProduct
                          ( location    : Location
                          , coefficient : term
                          , variable    : term?
                          )*
            )

theory_term = SymbolicTerm
               ( location : Location
               , symbol   : clingo.Symbol
               )
            | Variable
               ( location : Location
               , name     : str
               )
            | TheorySequence
               ( location : Location
               , sequence_type : TheorySequenceType
               , terms         : theory_term*
               )
            | TheoryFunction
               ( location  : Location
               , name      : str
               , arguments : theory_term*
               )
            | TheoryUnparsedTerm
               ( location : Location
               , elements : TheoryUnparsedTermElement
                             ( operators : str*
                             , term      : theory_term
                             )+
               )

# Literals

symbolic_atom = SymbolicAtom
                 ( symbol : term
                 )

literal = Literal
           ( location : Location
           , sign     : Sign
           , atom     : Comparison
                         ( comparison : ComparisonOperator
                         , left       : term
                         , right      : term
                         )
                      | BooleanConstant
                         ( value : bool
                         )
                      | symbolic_atom
           )

        | CSPLiteral
           ( location : Location
           , term     : csp_term
           , guards   : CSPGuard
                         ( comparison : ComparisonOperator
                         , term       : csp_term
                         )+
           )

# Head and Body Literals

aggregate_guard = AggregateGuard
                   ( comparison : ComparisonOperator
                   , term       : term
                   )

conditional_literal = ConditionalLiteral
                       ( location  : Location
                       , literal   : Literal
                       , condition : Literal*
                       )

aggregate = Aggregate
             ( location    : Location
             , left_guard  : aggregate_guard?
             , elements    : conditional_literal*
             , right_guard : aggregate_guard?
             )

theory_atom = TheoryAtom
               ( location : Location
               , term     : term
               , elements : TheoryAtomElement
                             ( terms     : theory_term*
                             , condition : literal*
                             )*
               , guard    : TheoryGuard
                             ( operator_name : str
                             , term          : theory_term
                             )?
               )

body_atom = aggregate
          | BodyAggregate
             ( location    : Location
             , left_guard  : aggregate_guard?
             , function    : AggregateFunction
             , elements    : BodyAggregateElement
                              ( terms     : term*
                              , condition : literal*
                              )*
             , right_guard : aggregate_guard?
             )
          | Disjoint
             ( location : Location
             , elements : DisjointElement
                           ( location  : Location
                           , terms     : term*
                           , term      : csp_term
                           , condition : literal*
                           )*
             )
          | theory_atom

body_literal = literal
             | conditional_literal
             | Literal
                ( location : Location
                , sign     : Sign
                , atom     : body_atom
                )

head = literal
     | aggregate
     | HeadAggregate
        ( location    : Location
        , left_guard  : aggregate_guard?
        , function    : AggregateFunction
        , elements    : HeadAggregateElement
                         ( terms     : term*
                         , condition : conditional_literal
                         )*
        , right_guard : aggregate_guard?
        )
     | Disjunction
        ( location : Location
        , elements : conditional_literal*
        )
     | theory_atom

# Statements

statement = Rule
             ( location : Location
             , head     : head
             , body     : body_literal*
             )
          | Definition
             ( location   : Location
             , name       : str
             , value      : term
             , is_default : bool
             )
          | ShowSignature
             ( location   : Location
             , name       : str
             , arity      : int
             , sign       : bool
             , csp        : bool
             )
          | Defined
             ( location   : Location
             , name       : str
             , arity      : int
             , sign       : bool
             )
          | ShowTerm
             ( location : Location
             , term     : term
             , body     : body_literal*
             , csp      : bool
             )
          | Minimize
             ( location : Location
             , weight   : term
             , priority : term
             , terms    : term*
             , body     : body_literal*
             )
          | Script
             ( location : Location
             , name     : str
             , code     : str
             )
          | Program
             ( location   : Location
             , name       : str
             , parameters : Id
                             ( location : Location
                             , id       : str
                             )*
             )
          | External
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             , type     : term
             )
          | Edge
             ( location : Location
             , u        : term
             , v        : term
             , body     : body_literal*
             )
          | Heuristic
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             , bias     : term
             , priority : term
             , modifier : term
             )
          | ProjectAtom
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             )
          | ProjectSignature
             ( location : Location
             , name     : str
             , arity    : int
             , sign     : bool
             )
          | TheoryDefinition
             ( location : Location
             , name     : str
             , terms    : TheoryTermDefinition
                           ( location  : Location
                           , name      : str
                           , operators : TheoryOperatorDefinition
                                          ( location      : Location
                                          , name          : str
                                          , priority      : int
                                          , operator_type : TheoryOperatorType
                                          )*
                           )*
             , atoms    : TheoryAtomDefinition
                           ( location  : Location
                           , atom_type : TheoryAtomType
                           , name      : str
                           , arity     : int
                           , term      : str
                           , guard     : TheoryGuardDefinition
                                          ( operators : str*
                                          , term      : str
                                          )?
                           )*
             )
```

Examples
--------
The following example parses a program from a string and passes the resulting
`AST` to the builder:

    &gt;&gt;&gt; from clingo import Control, ast
    &gt;&gt;&gt; from clingo.ast import Location, ProgramBuilder, Position, parse_string
    &gt;&gt;&gt;
    &gt;&gt;&gt; ctl = Control()
    &gt;&gt;&gt;
    &gt;&gt;&gt; with ProgramBuilder(ctl) as bld:
    ...     # parse from string
    ...     parse_string(&#39;a.&#39;, bld.add)
    ...     # build rule manually
    ...     pos = Position(&#39;&lt;string&gt;&#39;, 1, 1)
    ...     loc = Location(pos, pos)
    ...     fun = ast.Function(loc, &#39;b&#39;, [], False)
    ...     atm = ast.SymbolicAtom(fun)
    ...     lit = ast.Literal(loc, ast.Sign.NoSign, atm)
    ...     bld.add(ast.Rule(loc, lit, []))
    ...
    &gt;&gt;&gt; ctl.ground([(&#39;base&#39;, [])])
    &gt;&gt;&gt; print(ctl.solve(on_model=print))
    a b
    SAT

The next example shows how to transform ASTs using the `Transformer` class:

    &gt;&gt;&gt; from clingo.ast import Transformer, Variable, parse_string
    &gt;&gt;&gt;
    &gt;&gt;&gt; class VariableRenamer(Transformer):
    ...     def visit_Variable(self, node):
    ...         return node.update(name=&#39;_&#39; + node.name)
    ...
    &gt;&gt;&gt; vrt = VariableRenamer()
    &gt;&gt;&gt; parse_string(&#39;p(X) :- q(X).&#39;, lambda stm: print(str(vrt(stm))))
    #program base.
    p(_X) :- q(_X).
&#39;&#39;&#39;

from enum import Enum, IntEnum
from typing import Any, Callable, ContextManager, Dict, List, MutableSequence, NamedTuple, Optional, Sequence, Tuple, Union
from collections import abc
from functools import total_ordering

from ._internal import (_CBData, _Error,
                        _cb_error_handler, _c_call, _ffi, _handle_error, _lib, _str, _to_str)
from .util import Slice, SlicedMutableSequence
from .core import Logger
from .control import Control
from .symbol import Symbol

__all__ = [ &#39;AST&#39;, &#39;ASTSequence&#39;, &#39;ASTType&#39;, &#39;ASTValue&#39;, &#39;Aggregate&#39;,
            &#39;AggregateFunction&#39;, &#39;AggregateGuard&#39;, &#39;BinaryOperation&#39;,
            &#39;BinaryOperator&#39;, &#39;BodyAggregate&#39;, &#39;BodyAggregateElement&#39;,
            &#39;BooleanConstant&#39;, &#39;Comparison&#39;, &#39;ComparisonOperator&#39;,
            &#39;ConditionalLiteral&#39;, &#39;CspGuard&#39;, &#39;CspLiteral&#39;, &#39;CspProduct&#39;,
            &#39;CspSum&#39;, &#39;Defined&#39;, &#39;Definition&#39;, &#39;Disjoint&#39;, &#39;DisjointElement&#39;,
            &#39;Disjunction&#39;, &#39;Edge&#39;, &#39;External&#39;, &#39;Function&#39;, &#39;HeadAggregate&#39;,
            &#39;HeadAggregateElement&#39;, &#39;Heuristic&#39;, &#39;Id&#39;, &#39;Interval&#39;, &#39;Literal&#39;,
            &#39;Location&#39;, &#39;Minimize&#39;, &#39;Pool&#39;, &#39;Position&#39;, &#39;Program&#39;,
            &#39;ProgramBuilder&#39;, &#39;ProjectAtom&#39;, &#39;ProjectSignature&#39;, &#39;Rule&#39;,
            &#39;Script&#39;, &#39;ShowSignature&#39;, &#39;ShowTerm&#39;, &#39;Sign&#39;, &#39;StrSequence&#39;,
            &#39;SymbolicTerm&#39;, &#39;TheoryAtom&#39;, &#39;TheoryAtomDefinition&#39;,
            &#39;TheoryAtomElement&#39;, &#39;TheoryAtomType&#39;, &#39;TheoryDefinition&#39;,
            &#39;TheoryFunction&#39;, &#39;TheoryGuard&#39;, &#39;TheoryGuardDefinition&#39;,
            &#39;TheoryOperatorDefinition&#39;, &#39;TheoryOperatorType&#39;, &#39;TheorySequence&#39;,
            &#39;TheorySequenceType&#39;, &#39;TheoryTermDefinition&#39;, &#39;TheoryUnparsedTerm&#39;,
            &#39;TheoryUnparsedTermElement&#39;, &#39;Transformer&#39;, &#39;UnaryOperation&#39;,
            &#39;UnaryOperator&#39;, &#39;Variable&#39;, &#39;parse_files&#39;, &#39;parse_string&#39; ]

# pylint: disable=protected-access,invalid-name,too-many-lines,too-many-ancestors

class ASTType(Enum):
    &#39;&#39;&#39;
    Enumeration of ast node types.
    &#39;&#39;&#39;
    Id = _lib.clingo_ast_type_id
    Variable = _lib.clingo_ast_type_variable
    SymbolicTerm = _lib.clingo_ast_type_symbolic_term
    UnaryOperation = _lib.clingo_ast_type_unary_operation
    BinaryOperation = _lib.clingo_ast_type_binary_operation
    Interval = _lib.clingo_ast_type_interval
    Function = _lib.clingo_ast_type_function
    Pool = _lib.clingo_ast_type_pool
    CspProduct = _lib.clingo_ast_type_csp_product
    CspSum = _lib.clingo_ast_type_csp_sum
    CspGuard = _lib.clingo_ast_type_csp_guard
    BooleanConstant = _lib.clingo_ast_type_boolean_constant
    SymbolicAtom = _lib.clingo_ast_type_symbolic_atom
    Comparison = _lib.clingo_ast_type_comparison
    CspLiteral = _lib.clingo_ast_type_csp_literal
    AggregateGuard = _lib.clingo_ast_type_aggregate_guard
    ConditionalLiteral = _lib.clingo_ast_type_conditional_literal
    Aggregate = _lib.clingo_ast_type_aggregate
    BodyAggregateElement = _lib.clingo_ast_type_body_aggregate_element
    BodyAggregate = _lib.clingo_ast_type_body_aggregate
    HeadAggregateElement = _lib.clingo_ast_type_head_aggregate_element
    HeadAggregate = _lib.clingo_ast_type_head_aggregate
    Disjunction = _lib.clingo_ast_type_disjunction
    DisjointElement = _lib.clingo_ast_type_disjoint_element
    Disjoint = _lib.clingo_ast_type_disjoint
    TheorySequence = _lib.clingo_ast_type_theory_sequence
    TheoryFunction = _lib.clingo_ast_type_theory_function
    TheoryUnparsedTermElement = _lib.clingo_ast_type_theory_unparsed_term_element
    TheoryUnparsedTerm = _lib.clingo_ast_type_theory_unparsed_term
    TheoryGuard = _lib.clingo_ast_type_theory_guard
    TheoryAtomElement = _lib.clingo_ast_type_theory_atom_element
    TheoryAtom = _lib.clingo_ast_type_theory_atom
    Literal = _lib.clingo_ast_type_literal
    TheoryOperatorDefinition = _lib.clingo_ast_type_theory_operator_definition
    TheoryTermDefinition = _lib.clingo_ast_type_theory_term_definition
    TheoryGuardDefinition = _lib.clingo_ast_type_theory_guard_definition
    TheoryAtomDefinition = _lib.clingo_ast_type_theory_atom_definition
    Rule = _lib.clingo_ast_type_rule
    Definition = _lib.clingo_ast_type_definition
    ShowSignature = _lib.clingo_ast_type_show_signature
    ShowTerm = _lib.clingo_ast_type_show_term
    Minimize = _lib.clingo_ast_type_minimize
    Script = _lib.clingo_ast_type_script
    Program = _lib.clingo_ast_type_program
    External = _lib.clingo_ast_type_external
    Edge = _lib.clingo_ast_type_edge
    Heuristic = _lib.clingo_ast_type_heuristic
    ProjectAtom = _lib.clingo_ast_type_project_atom
    ProjectSignature = _lib.clingo_ast_type_project_signature
    Defined = _lib.clingo_ast_type_defined
    TheoryDefinition = _lib.clingo_ast_type_theory_definition

class AggregateFunction(IntEnum):
    &#39;&#39;&#39;
    Enumeration of aggegate functions.
    &#39;&#39;&#39;
    Count = _lib.clingo_ast_aggregate_function_count
    &#39;&#39;&#39;
    The `#count` function.
    &#39;&#39;&#39;
    Max = _lib.clingo_ast_aggregate_function_max
    &#39;&#39;&#39;
    The `#max` function.
    &#39;&#39;&#39;
    Min = _lib.clingo_ast_aggregate_function_min
    &#39;&#39;&#39;
    The `#min` function.
    &#39;&#39;&#39;
    Sum = _lib.clingo_ast_aggregate_function_sum
    &#39;&#39;&#39;
    The `#sum` function.
    &#39;&#39;&#39;
    SumPlus = _lib.clingo_ast_aggregate_function_sump
    &#39;&#39;&#39;
    The `#sum+` function.
    &#39;&#39;&#39;

class BinaryOperator(IntEnum):
    &#39;&#39;&#39;
    Enumeration of binary operators.
    &#39;&#39;&#39;
    And = _lib.clingo_ast_binary_operator_and
    &#39;&#39;&#39;
    For bitwise and.
    &#39;&#39;&#39;
    Division = _lib.clingo_ast_binary_operator_division
    &#39;&#39;&#39;
    For arithmetic division.
    &#39;&#39;&#39;
    Minus = _lib.clingo_ast_binary_operator_minus
    &#39;&#39;&#39;
    For arithmetic subtraction.
    &#39;&#39;&#39;
    Modulo = _lib.clingo_ast_binary_operator_modulo
    &#39;&#39;&#39;
    For arithmetic modulo.
    &#39;&#39;&#39;
    Multiplication = _lib.clingo_ast_binary_operator_multiplication
    &#39;&#39;&#39;
    For arithmetic multipilcation.
    &#39;&#39;&#39;
    Or = _lib.clingo_ast_binary_operator_or
    &#39;&#39;&#39;
    For bitwise or.
    &#39;&#39;&#39;
    Plus = _lib.clingo_ast_binary_operator_plus
    &#39;&#39;&#39;
    For arithmetic addition.
    &#39;&#39;&#39;
    Power = _lib.clingo_ast_binary_operator_power
    &#39;&#39;&#39;
    For arithmetic exponentiation.
    &#39;&#39;&#39;
    XOr = _lib.clingo_ast_binary_operator_xor
    &#39;&#39;&#39;
    For bitwise exclusive or.
    &#39;&#39;&#39;

class ComparisonOperator(IntEnum):
    &#39;&#39;&#39;
    Enumeration of comparison operators.
    &#39;&#39;&#39;
    Equal = _lib.clingo_ast_comparison_operator_equal
    &#39;&#39;&#39;
    The `=` operator
    &#39;&#39;&#39;
    GreaterEqual = _lib.clingo_ast_comparison_operator_greater_equal
    &#39;&#39;&#39;
    The `&gt;=` operator.
    &#39;&#39;&#39;
    GreaterThan = _lib.clingo_ast_comparison_operator_greater_than
    &#39;&#39;&#39;
    The `&gt;` operator.
    &#39;&#39;&#39;
    LessEqual = _lib.clingo_ast_comparison_operator_less_equal
    &#39;&#39;&#39;
    The `&lt;=` operator.
    &#39;&#39;&#39;
    LessThan = _lib.clingo_ast_comparison_operator_less_than
    &#39;&#39;&#39;
    The `&lt;` operator.
    &#39;&#39;&#39;
    NotEqual = _lib.clingo_ast_comparison_operator_not_equal
    &#39;&#39;&#39;
    The `!=` operator.
    &#39;&#39;&#39;

class Sign(IntEnum):
    &#39;&#39;&#39;
    Enumeration of signs for literals.
    &#39;&#39;&#39;
    DoubleNegation = _lib.clingo_ast_sign_double_negation
    &#39;&#39;&#39;
    For double negated literals (with prefix `not not`)
    &#39;&#39;&#39;
    Negation = _lib.clingo_ast_sign_negation
    &#39;&#39;&#39;
    For negative literals (with prefix `not`).
    &#39;&#39;&#39;
    NoSign = _lib.clingo_ast_sign_no_sign
    &#39;&#39;&#39;
    For positive literals.
    &#39;&#39;&#39;

class TheoryAtomType(IntEnum):
    &#39;&#39;&#39;
    Enumeration of theory atom types.
    &#39;&#39;&#39;
    Any = _lib.clingo_ast_theory_atom_definition_type_any
    &#39;&#39;&#39;
    For atoms that can occur anywhere in a rule.
    &#39;&#39;&#39;
    Body = _lib.clingo_ast_theory_atom_definition_type_body
    &#39;&#39;&#39;
    For atoms that can only occur in rule bodies.
    &#39;&#39;&#39;
    Directive = _lib.clingo_ast_theory_atom_definition_type_directive
    &#39;&#39;&#39;
    For atoms that can only occur in facts.
    &#39;&#39;&#39;
    Head = _lib.clingo_ast_theory_atom_definition_type_head
    &#39;&#39;&#39;
    For atoms that can only occur in rule heads.
    &#39;&#39;&#39;

class TheoryOperatorType(IntEnum):
    &#39;&#39;&#39;
    Enumeration of operator types.
    &#39;&#39;&#39;
    BinaryLeft = _lib.clingo_ast_theory_operator_type_binary_left
    &#39;&#39;&#39;
    For binary left associative operators.
    &#39;&#39;&#39;
    BinaryRight = _lib.clingo_ast_theory_operator_type_binary_right
    &#39;&#39;&#39;
    For binary right associative operator.
    &#39;&#39;&#39;
    Unary = _lib.clingo_ast_theory_operator_type_unary
    &#39;&#39;&#39;
    For unary operators.
    &#39;&#39;&#39;

class TheorySequenceType(IntEnum):
    &#39;&#39;&#39;
    Enumeration of theory term sequence types.
    &#39;&#39;&#39;
    List = _lib.clingo_ast_theory_sequence_type_list
    &#39;&#39;&#39;
    For sequences enclosed in brackets.
    &#39;&#39;&#39;
    Set = _lib.clingo_ast_theory_sequence_type_set
    &#39;&#39;&#39;
    For sequences enclosed in braces.
    &#39;&#39;&#39;
    Tuple = _lib.clingo_ast_theory_sequence_type_tuple
    &#39;&#39;&#39;
    For sequences enclosed in parenthesis.
    &#39;&#39;&#39;

class UnaryOperator(IntEnum):
    &#39;&#39;&#39;
    Enumeration of signs for literals.
    &#39;&#39;&#39;
    Absolute = _lib.clingo_ast_unary_operator_absolute
    &#39;&#39;&#39;
    For taking the absolute value.
    &#39;&#39;&#39;
    Minus = _lib.clingo_ast_unary_operator_minus
    &#39;&#39;&#39;
    For unary minus and classical negation.
    &#39;&#39;&#39;
    Negation = _lib.clingo_ast_unary_operator_negation
    &#39;&#39;&#39;
    For bitwise negation.
    &#39;&#39;&#39;

class ASTSequence(abc.MutableSequence):
    &#39;&#39;&#39;
    A sequence holding `AST` nodes.
    &#39;&#39;&#39;
    def __init__(self, rep, attribute):
        self._rep = rep
        self._attribute = attribute
        _lib.clingo_ast_acquire(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __len__(self) -&gt; int:
        return _c_call(&#39;size_t&#39;, _lib.clingo_ast_attribute_size_ast_array, self._rep, self._attribute)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return SlicedMutableSequence(self, Slice(index))
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_ast_at, self._rep, self._attribute, index))

    def __iter__(self):
        for index in range(len(self)):
            yield AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_ast_at, self._rep, self._attribute, index))

    def __setitem__(self, index, ast):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        _handle_error(_lib.clingo_ast_attribute_set_ast_at(self._rep, self._attribute, index, ast._rep))

    def __delitem__(self, index):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        _handle_error(_lib.clingo_ast_attribute_delete_ast_at(self._rep, self._attribute, index))

    def insert(self, index, value):
        _handle_error(_lib.clingo_ast_attribute_insert_ast_at(self._rep, self._attribute, index, value._rep))

    def __str__(self):
        return str(list(self))

    def __repr__(self):
        return repr(list(self))

class StrSequence(abc.MutableSequence):
    &#39;&#39;&#39;
    A sequence holding strings.
    &#39;&#39;&#39;
    def __init__(self, rep, attribute):
        self._attribute = attribute
        self._rep = rep
        _lib.clingo_ast_acquire(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __len__(self) -&gt; int:
        return _c_call(&#39;size_t&#39;, _lib.clingo_ast_attribute_size_string_array, self._rep, self._attribute)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return SlicedMutableSequence(self, Slice(index))
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        return _to_str(_c_call(&#39;char*&#39;, _lib.clingo_ast_attribute_get_string_at, self._rep, self._attribute, index))

    def __iter__(self):
        for index in range(len(self)):
            yield _to_str(_c_call(&#39;char*&#39;, _lib.clingo_ast_attribute_get_string_at, self._rep, self._attribute, index))

    def __setitem__(self, index, value):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        _handle_error(_lib.clingo_str_attribute_set_string_at(self._rep, self._attribute, index, value.encode()))

    def __delitem__(self, index):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        _handle_error(_lib.clingo_ast_attribute_delete_string_at(self._rep, self._attribute, index))

    def insert(self, index, value):
        _handle_error(_lib.clingo_ast_attribute_insert_string_at(self._rep, self._attribute, index, value.encode()))

    def __str__(self):
        return str(list(self))

    def __repr__(self):
        return repr(list(self))

class Position(NamedTuple):
    &#39;&#39;&#39;
    Class to point to a position in a text file.
    &#39;&#39;&#39;
    filename: str
    &#39;&#39;&#39;
    The file name.
    &#39;&#39;&#39;
    line: int
    &#39;&#39;&#39;
    The line number in the file.
    &#39;&#39;&#39;
    column: int
    &#39;&#39;&#39;
    The column number in the line.
    &#39;&#39;&#39;

class Location(NamedTuple):
    &#39;&#39;&#39;
    Class to point to a range in a text file.
    &#39;&#39;&#39;
    begin: Position
    &#39;&#39;&#39;
    The beginning of the range.
    &#39;&#39;&#39;
    end: Position
    &#39;&#39;&#39;
    The end of the range.
    &#39;&#39;&#39;

def _c_location(loc: Location):
    mema = _ffi.new(&#39;char[]&#39;, loc.begin.filename.encode())
    memb = _ffi.new(&#39;char[]&#39;, loc.end.filename.encode())
    return (_ffi.new(&#39;clingo_location_t*&#39;, (mema,
                                            memb,
                                            loc.begin.line,
                                            loc.end.line,
                                            loc.begin.column,
                                            loc.end.column)), mema, memb)

def _py_location(rep):
    return Location(
        Position(_to_str(rep.begin_file), rep.begin_line, rep.begin_column),
        Position(_to_str(rep.end_file), rep.end_line, rep.end_column))

_attribute_names = { _to_str(_lib.g_clingo_ast_attribute_names.names[i]): i
                     for i in range(_lib.g_clingo_ast_attribute_names.size) }

ASTValue = Union[str, int, Symbol, Location, None, &#39;AST&#39;, StrSequence, ASTSequence]
ASTUpdate = Union[str, int, Symbol, Location, None, &#39;AST&#39;, Sequence[str], Sequence[&#39;AST&#39;]]

@total_ordering
class AST:
    &#39;&#39;&#39;
    Represents a node in the abstract syntax tree.

    The attributes of an `AST` are tied to its type. They correspond to the
    grammar in the description of the `clingo.ast` module. `AST` nodes can be
    constructed using one of the functions provided in this module.

    Furthermore, AST nodes implement Python&#39;s rich comparison operators and are
    ordered structurally ignoring the location. They can also be used as
    dictionary keys. Their string representation corresponds to their gringo
    representation. In fact, the string representation of any AST obtained from
    `parse_files` and `parse_string` can be parsed again. Note that it is
    possible to construct ASTs that are not parsable, though.
    &#39;&#39;&#39;
    def __init__(self, rep):
        super().__setattr__(&#39;_rep&#39;, rep)

    def __eq__(self, other):
        if not isinstance(other, AST):
            return NotImplemented
        return _lib.clingo_ast_equal(self._rep, other._rep)

    def __lt__(self, other):
        if not isinstance(other, AST):
            return NotImplemented
        return _lib.clingo_ast_less_than(self._rep, other._rep)

    def __hash__(self):
        return _lib.clingo_ast_hash(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __getattr__(self, name):
        attr_id = _attribute_names.get(name)
        if attr_id is None or not _c_call(&#39;bool&#39;, _lib.clingo_ast_has_attribute, self._rep, attr_id):
            raise AttributeError(f&#39;no attribute: {name}&#39;)
        attr_type = _c_call(&#39;clingo_ast_attribute_type_t&#39;, _lib.clingo_ast_attribute_type, self._rep, attr_id)
        if attr_type == _lib.clingo_ast_attribute_type_string:
            return _to_str(_c_call(&#39;char*&#39;, _lib.clingo_ast_attribute_get_string, self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_number:
            return _c_call(&#39;int&#39;, _lib.clingo_ast_attribute_get_number, self._rep, attr_id)
        if attr_type == _lib.clingo_ast_attribute_type_symbol:
            return Symbol(_c_call(&#39;clingo_symbol_t&#39;, _lib.clingo_ast_attribute_get_symbol,
                                                self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_location:
            return _py_location(_c_call(&#39;clingo_location_t&#39;, _lib.clingo_ast_attribute_get_location,
                                        self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_optional_ast:
            rep = _c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_optional_ast, self._rep, attr_id)
            return AST(rep) if rep != _ffi.NULL else None
        if attr_type == _lib.clingo_ast_attribute_type_ast:
            return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_ast, self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_string_array:
            return StrSequence(self._rep, attr_id)
        assert attr_type == _lib.clingo_ast_attribute_type_ast_array
        return ASTSequence(self._rep, attr_id)

    def __setattr__(self, name, value):
        attr_id = getattr(_lib, f&#39;clingo_ast_attribute_{name}&#39;)
        if not _c_call(&#39;bool&#39;, _lib.clingo_ast_has_attribute, self._rep, attr_id):
            raise AttributeError(f&#39;no attribute: {name}&#39;)
        attr_type = _c_call(&#39;clingo_ast_attribute_type_t&#39;, _lib.clingo_ast_attribute_type, self._rep, attr_id)
        if attr_type == _lib.clingo_ast_attribute_type_string:
            _handle_error(_lib.clingo_ast_attribute_set_string(self._rep, attr_id, value.encode()))
        elif attr_type == _lib.clingo_ast_attribute_type_number:
            _handle_error(_lib.clingo_ast_attribute_set_number(self._rep, attr_id, value))
        elif attr_type == _lib.clingo_ast_attribute_type_symbol:
            _handle_error(_lib.clingo_ast_attribute_set_symbol(self._rep, attr_id, value._rep))
        elif attr_type == _lib.clingo_ast_attribute_type_location:
            c_loc = _c_location(value)
            _handle_error(_lib.clingo_ast_attribute_set_location(self._rep, attr_id, c_loc[0]))
        elif attr_type == _lib.clingo_ast_attribute_type_optional_ast:
            _handle_error(_lib.clingo_ast_attribute_set_optional_ast(self._rep, attr_id,
                          _ffi.NULL if value is None else value._rep))
        elif attr_type == _lib.clingo_ast_attribute_type_ast:
            _handle_error(_lib.clingo_ast_attribute_set_ast(self._rep, attr_id, value._rep))
        elif attr_type == _lib.clingo_ast_attribute_type_string_array:
            if isinstance(value, StrSequence):
                if attr_id == value._attribute and self._rep == value._rep:
                    value = list(value)
            elif not isinstance(value, list):
                value = list(value)
            str_seq = StrSequence(self._rep, attr_id)
            str_seq.clear()
            str_seq.extend(value)
        else:
            assert attr_type == _lib.clingo_ast_attribute_type_ast_array
            if isinstance(value, ASTSequence):
                if attr_id == value._attribute and self._rep == value._rep:
                    value = list(value)
            elif not isinstance(value, list):
                value = list(value)
            ast_seq = ASTSequence(self._rep, attr_id)
            ast_seq.clear()
            ast_seq.extend(value)

    def __str__(self):
        return _str(_lib.clingo_ast_to_string_size, _lib.clingo_ast_to_string, self._rep)

    def __repr__(self):
        name = str(self.ast_type).replace(&#39;ASTType&#39;, &#39;ast&#39;)
        args = &#39;, &#39;.join(repr(x) for x in self.values())
        return f&#39;{name}({args})&#39;

    def __copy__(self) -&gt; &#39;AST&#39;:
        &#39;&#39;&#39;
        Return a shallow copy of the ast.
        &#39;&#39;&#39;
        return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_copy, self._rep))

    def __deepcopy__(self, memo) -&gt; &#39;AST&#39;:
        &#39;&#39;&#39;
        Return a deep copy of the ast.
        &#39;&#39;&#39;
        return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_deep_copy, self._rep))

    def update(self, **kwargs: ASTUpdate) -&gt; &#39;AST&#39;:
        &#39;&#39;&#39;
        Return a copy of the AST also updating the given attributes.

        Note that this function returns a reference to self if no arguments are
        given.
        &#39;&#39;&#39;
        if not kwargs:
            return self

        args = []
        for key in self.keys():
            if key in kwargs:
                args.append(kwargs[key])
            else:
                args.append(getattr(self, key))

        cons = globals()[str(self.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)]
        return cons(*args)

    def items(self) -&gt; List[Tuple[str, ASTValue]]:
        &#39;&#39;&#39;
        The list of items of the AST node.
        &#39;&#39;&#39;
        return [ (name, getattr(self, name)) for name in self.keys() ]

    def keys(self) -&gt; List[str]:
        &#39;&#39;&#39;
        The list of keys of the AST node.
        &#39;&#39;&#39;
        cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
        names = _lib.g_clingo_ast_attribute_names.names
        return [ _to_str(names[cons.arguments[j].attribute]) for j in range(cons.size) ]

    def values(self) -&gt; List[ASTValue]:
        &#39;&#39;&#39;
        The list of values of the AST node.
        &#39;&#39;&#39;
        return [ (getattr(self, name)) for name in self.keys() ]

    @property
    def ast_type(self) -&gt; ASTType:
        &#39;&#39;&#39;
        The type of the node.
        &#39;&#39;&#39;
        return ASTType(_c_call(&#39;clingo_ast_type_t&#39;, _lib.clingo_ast_get_type, self._rep))

    @property
    def child_keys(self) -&gt; List[str]:
        &#39;&#39;&#39;
        List of attribute names containing ASTs.
        &#39;&#39;&#39;
        cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
        names = _lib.g_clingo_ast_attribute_names.names
        return [ _to_str(names[cons.arguments[j].attribute])
                 for j in range(cons.size)
                 if cons.arguments[j].type in (_lib.clingo_ast_attribute_type_ast,
                                               _lib.clingo_ast_attribute_type_optional_ast,
                                               _lib.clingo_ast_attribute_type_ast_array) ]

    def unpool(self, other: bool=True, condition: bool=True) -&gt; List[&#39;AST&#39;]:
        &#39;&#39;&#39;
        Unpool the AST returning a list of ASTs without pool terms.

        Parameters
        ----------
        other
            Remove all pools except those in conditions of conditional
            literals.
        condition
            Only remove pools from conditions of conditional literals.
        &#39;&#39;&#39;
        unpool_type = 0
        if other:
            unpool_type |= _lib.clingo_ast_unpool_type_other
        if condition:
            unpool_type |= _lib.clingo_ast_unpool_type_condition

        ret: List[AST] = []
        error = _Error()
        cb_data = _CBData(ret.append, error)
        c_cb_data = _ffi.new_handle(cb_data)
        _handle_error(_lib.clingo_ast_unpool(self._rep, unpool_type, _lib.pyclingo_ast_callback, c_cb_data))
        return ret

@_ffi.def_extern(onerror=_cb_error_handler(&#39;data&#39;), name=&#39;pyclingo_ast_callback&#39;)
def _pyclingo_ast_callback(ast, data):
    &#39;&#39;&#39;
    Low-level ast callback.
    &#39;&#39;&#39;
    callback = _ffi.from_handle(data).data
    _lib.clingo_ast_acquire(ast)
    callback(AST(ast))

    return True

def parse_files(files: Sequence[str], callback: Callable[[AST], None],
                logger: Optional[Logger]=None, message_limit: int=20) -&gt; None:
    &#39;&#39;&#39;
    Parse the programs in the given files and return an abstract syntax tree for
    each statement via a callback.

    The function follows clingo&#39;s handling of files on the command line. Filename
    `&#34;-&#34;` is treated as stdin and if an empty list is given, then the parser will
    read from stdin.

    Parameters
    ----------
    files
        List of file names.
    callback
        Callable taking an ast as argument.
    logger
        Function to intercept messages normally printed to standard error.
    message_limit
        The maximum number of messages passed to the logger.

    See Also
    --------
    ProgramBuilder
    &#39;&#39;&#39;
    if logger is not None:
        c_logger_data = _ffi.new_handle(logger)
        c_logger = _lib.pyclingo_logger_callback
    else:
        c_logger_data = _ffi.NULL
        c_logger = _ffi.NULL

    error = _Error()
    cb_data = _CBData(callback, error)
    c_cb_data = _ffi.new_handle(cb_data)

    _handle_error(_lib.clingo_ast_parse_files([ _ffi.new(&#39;char[]&#39;, f.encode()) for f in files ], len(files),
                                              _lib.pyclingo_ast_callback, c_cb_data,
                                              c_logger, c_logger_data,
                                              message_limit), cb_data)

def parse_string(program: str, callback: Callable[[AST], None],
                 logger: Optional[Logger]=None, message_limit: int=20) -&gt; None:
    &#39;&#39;&#39;
    Parse the given program and return an abstract syntax tree for each
    statement via a callback.

    Parameters
    ----------
    program
        String representation of the program.
    callback
        Callable taking an ast as argument.
    logger
        Function to intercept messages normally printed to standard error.
    message_limit
        The maximum number of messages passed to the logger.

    See Also
    --------
    ProgramBuilder
    &#39;&#39;&#39;
    if logger is not None:
        c_logger_data = _ffi.new_handle(logger)
        c_logger = _lib.pyclingo_logger_callback
    else:
        c_logger_data = _ffi.NULL
        c_logger = _ffi.NULL

    error = _Error()
    cb_data = _CBData(callback, error)
    c_cb_data = _ffi.new_handle(cb_data)

    _handle_error(_lib.clingo_ast_parse_string(program.encode(),
                                               _lib.pyclingo_ast_callback, c_cb_data,
                                               c_logger, c_logger_data,
                                               message_limit), cb_data)

class ProgramBuilder(ContextManager[&#39;ProgramBuilder&#39;]):
    &#39;&#39;&#39;
    Object to build non-ground programs.

    Parameters
    ----------
    control
        The `clingo.control.Control` object to attach the builder to.

    See Also
    --------
    parse_string, parse_files

    Notes
    -----
    This class is a context manager and must be used with Python&#39;s `with`
    statement.
    &#39;&#39;&#39;
    def __init__(self, control: Control):
        self._rep = _c_call(&#39;clingo_program_builder_t*&#39;, _lib.clingo_control_program_builder, control._rep)

    def __enter__(self):
        _handle_error(_lib.clingo_program_builder_begin(self._rep))
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        _handle_error(_lib.clingo_program_builder_end(self._rep))
        return False

    def add(self, statement: AST) -&gt; None:
        &#39;&#39;&#39;
        Adds a statement in form of an `AST` node to the program.

        Parameters
        ----------
        statement
            The statement to add.
        &#39;&#39;&#39;
        _handle_error(_lib.clingo_program_builder_add(self._rep, statement._rep))

class Transformer:
    &#39;&#39;&#39;
    Utility class to transform ASTs.

    Classes should inherit from this class and implement functions with name
    `visit_&lt;ast_type&gt;` where `&lt;ast_type&gt;` is the type of the ASTs to visit and
    modify. Such a function should return an updated AST or the same AST if no
    change is necessary. The transformer will take care to copy all parent ASTs
    involving a modified child. Note that the class works like a visitor if
    only self references are returned from such functions.

    Any extra arguments passed to the visit method are passed on to child ASTs.
    &#39;&#39;&#39;
    def visit(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
        &#39;&#39;&#39;
        Dispatch to a visit method in a base class or visit and transform the
        children of the given AST if it is missing.
        &#39;&#39;&#39;
        attr = &#39;visit_&#39; + str(ast.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)
        if hasattr(self, attr):
            return getattr(self, attr)(ast, *args, **kwargs)
        return ast.update(**self.visit_children(ast, *args, **kwargs))

    def visit_children(self, ast: AST, *args: Any, **kwargs: Any) -&gt; Dict[str, ASTUpdate]:
        &#39;&#39;&#39;
        Visit and transform the children of the given AST.

        Returns
        -------
        The functions returns a dictionary that can be passed to `AST.update`.
        It contains the attributes and values that have been transformed.
        &#39;&#39;&#39;
        update: Dict[str, ASTUpdate] = dict()
        for key in ast.child_keys:
            old = getattr(ast, key)
            new = self._dispatch(old, *args, **kwargs)
            if new is not old:
                update[key] = new
        return update

    def visit_sequence(self, sequence: ASTSequence, *args: Any, **kwargs: Any) -&gt; MutableSequence[AST]:
        &#39;&#39;&#39;
        Transform a sequence of ASTs returning the same sequnce if there are no
        changes or a list of ASTs otherwise.
        &#39;&#39;&#39;
        ret: MutableSequence[AST]
        ret, lst = sequence, []
        for old in sequence:
            lst.append(self(old, *args, **kwargs))
            if lst[-1] is not old:
                ret = lst
        return ret

    def _dispatch(self, ast: Union[None, AST, ASTSequence], *args: Any, **kwargs: Any) -&gt; Union[None, AST, MutableSequence[AST]]:
        &#39;&#39;&#39;
        Visit and transform an (optional) AST or a sequence of ASTs.
        &#39;&#39;&#39;
        if ast is None:
            return ast

        if isinstance(ast, AST):
            return self.visit(ast, *args, **kwargs) # type: ignore

        if isinstance(ast, abc.Sequence):
            return self.visit_sequence(ast, *args, **kwargs)

        raise TypeError(&#39;unexpected type&#39;)

    def __call__(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
        &#39;&#39;&#39;
        Alternative way to call `Transformer.visit`.
        &#39;&#39;&#39;
        return self.visit(ast, *args, **kwargs)

def Id(location: Location, name: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Id`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_id, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode())))
    return AST(p_ast[0])

def Variable(location: Location, name: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Variable`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_variable, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode())))
    return AST(p_ast[0])

def SymbolicTerm(location: Location, symbol: Symbol) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.SymbolicTerm`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_symbolic_term, p_ast,
        c_location[0],
        _ffi.cast(&#39;clingo_symbol_t&#39;, symbol._rep)))
    return AST(p_ast[0])

def UnaryOperation(location: Location, operator_type: int, argument: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.UnaryOperation`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_unary_operation, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, operator_type),
        argument._rep))
    return AST(p_ast[0])

def BinaryOperation(location: Location, operator_type: int, left: AST, right: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BinaryOperation`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_binary_operation, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, operator_type),
        left._rep,
        right._rep))
    return AST(p_ast[0])

def Interval(location: Location, left: AST, right: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Interval`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_interval, p_ast,
        c_location[0],
        left._rep,
        right._rep))
    return AST(p_ast[0])

def Function(location: Location, name: str, arguments: Sequence[AST], external: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Function`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_function, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in arguments ]),
        _ffi.cast(&#39;size_t&#39;, len(arguments)),
        _ffi.cast(&#39;int&#39;, external)))
    return AST(p_ast[0])

def Pool(location: Location, arguments: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Pool`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_pool, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in arguments ]),
        _ffi.cast(&#39;size_t&#39;, len(arguments))))
    return AST(p_ast[0])

def CspProduct(location: Location, coefficient: AST, variable: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspProduct`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_product, p_ast,
        c_location[0],
        coefficient._rep,
        variable._rep))
    return AST(p_ast[0])

def CspSum(location: Location, coefficient: AST, variable: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspSum`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_sum, p_ast,
        c_location[0],
        coefficient._rep,
        variable._rep))
    return AST(p_ast[0])

def CspGuard(location: Location, comparison: int, term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspGuard`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_guard, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, comparison),
        term._rep))
    return AST(p_ast[0])

def BooleanConstant(value: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BooleanConstant`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_boolean_constant, p_ast,
        _ffi.cast(&#39;int&#39;, value)))
    return AST(p_ast[0])

def SymbolicAtom(symbol: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.SymbolicAtom`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_symbolic_atom, p_ast,
        symbol._rep))
    return AST(p_ast[0])

def Comparison(comparison: int, left: AST, right: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Comparison`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_comparison, p_ast,
        _ffi.cast(&#39;int&#39;, comparison),
        left._rep,
        right._rep))
    return AST(p_ast[0])

def CspLiteral(location: Location, term: AST, guards: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspLiteral`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_literal, p_ast,
        c_location[0],
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in guards ]),
        _ffi.cast(&#39;size_t&#39;, len(guards))))
    return AST(p_ast[0])

def AggregateGuard(comparison: int, term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.AggregateGuard`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_aggregate_guard, p_ast,
        _ffi.cast(&#39;int&#39;, comparison),
        term._rep))
    return AST(p_ast[0])

def ConditionalLiteral(location: Location, literal: AST, condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ConditionalLiteral`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_conditional_literal, p_ast,
        c_location[0],
        literal._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])

def Aggregate(location: Location, left_guard: Optional[AST], elements: Sequence[AST],
              right_guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Aggregate`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_aggregate, p_ast,
        c_location[0],
        _ffi.NULL if left_guard is None else left_guard._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if right_guard is None else right_guard._rep))
    return AST(p_ast[0])

def BodyAggregateElement(terms: Sequence[AST], condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BodyAggregateElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_body_aggregate_element, p_ast,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])

def BodyAggregate(location: Location, left_guard: Optional[AST], function: int, elements: Sequence[AST],
                  right_guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BodyAggregate`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_body_aggregate, p_ast,
        c_location[0],
        _ffi.NULL if left_guard is None else left_guard._rep,
        _ffi.cast(&#39;int&#39;, function),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if right_guard is None else right_guard._rep))
    return AST(p_ast[0])

def HeadAggregateElement(terms: Sequence[AST], condition: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.HeadAggregateElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_head_aggregate_element, p_ast,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        condition._rep))
    return AST(p_ast[0])

def HeadAggregate(location: Location, left_guard: Optional[AST], function: int, elements: Sequence[AST],
                  right_guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.HeadAggregate`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_head_aggregate, p_ast,
        c_location[0],
        _ffi.NULL if left_guard is None else left_guard._rep,
        _ffi.cast(&#39;int&#39;, function),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if right_guard is None else right_guard._rep))
    return AST(p_ast[0])

def Disjunction(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Disjunction`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_disjunction, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements))))
    return AST(p_ast[0])

def DisjointElement(location: Location, terms: Sequence[AST], term: AST, condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.DisjointElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_disjoint_element, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])

def Disjoint(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Disjoint`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_disjoint, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements))))
    return AST(p_ast[0])

def TheorySequence(location: Location, sequence_type: int, terms: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheorySequence`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_sequence, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, sequence_type),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms))))
    return AST(p_ast[0])

def TheoryFunction(location: Location, name: str, arguments: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryFunction`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_function, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in arguments ]),
        _ffi.cast(&#39;size_t&#39;, len(arguments))))
    return AST(p_ast[0])

def TheoryUnparsedTermElement(operators: Sequence[str], term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryUnparsedTermElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_operators = [ _ffi.new(&#39;char[]&#39;, x.encode()) for x in operators ]
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_unparsed_term_element, p_ast,
        _ffi.new(&#39;char*[]&#39;, c_operators),
        _ffi.cast(&#39;size_t&#39;, len(operators)),
        term._rep))
    return AST(p_ast[0])

def TheoryUnparsedTerm(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryUnparsedTerm`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_unparsed_term, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements))))
    return AST(p_ast[0])

def TheoryGuard(operator_name: str, term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryGuard`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_guard, p_ast,
        _ffi.new(&#39;char const[]&#39;, operator_name.encode()),
        term._rep))
    return AST(p_ast[0])

def TheoryAtomElement(terms: Sequence[AST], condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryAtomElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_atom_element, p_ast,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])

def TheoryAtom(location: Location, term: AST, elements: Sequence[AST], guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryAtom`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_atom, p_ast,
        c_location[0],
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if guard is None else guard._rep))
    return AST(p_ast[0])

def Literal(location: Location, sign: int, atom: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Literal`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_literal, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, sign),
        atom._rep))
    return AST(p_ast[0])

def TheoryOperatorDefinition(location: Location, name: str, priority: int, operator_type: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryOperatorDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_operator_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, priority),
        _ffi.cast(&#39;int&#39;, operator_type)))
    return AST(p_ast[0])

def TheoryTermDefinition(location: Location, name: str, operators: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryTermDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_term_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in operators ]),
        _ffi.cast(&#39;size_t&#39;, len(operators))))
    return AST(p_ast[0])

def TheoryGuardDefinition(operators: Sequence[str], term: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryGuardDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_operators = [ _ffi.new(&#39;char[]&#39;, x.encode()) for x in operators ]
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_guard_definition, p_ast,
        _ffi.new(&#39;char*[]&#39;, c_operators),
        _ffi.cast(&#39;size_t&#39;, len(operators)),
        _ffi.new(&#39;char const[]&#39;, term.encode())))
    return AST(p_ast[0])

def TheoryAtomDefinition(location: Location, atom_type: int, name: str, arity: int, term: str,
                         guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryAtomDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_atom_definition, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, atom_type),
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.new(&#39;char const[]&#39;, term.encode()),
        _ffi.NULL if guard is None else guard._rep))
    return AST(p_ast[0])

def Rule(location: Location, head: AST, body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Rule`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_rule, p_ast,
        c_location[0],
        head._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])

def Definition(location: Location, name: str, value: AST, is_default: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Definition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        value._rep,
        _ffi.cast(&#39;int&#39;, is_default)))
    return AST(p_ast[0])

def ShowSignature(location: Location, name: str, arity: int, positive: int, csp: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ShowSignature`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_show_signature, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.cast(&#39;int&#39;, positive),
        _ffi.cast(&#39;int&#39;, csp)))
    return AST(p_ast[0])

def ShowTerm(location: Location, term: AST, body: Sequence[AST], csp: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ShowTerm`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_show_term, p_ast,
        c_location[0],
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body)),
        _ffi.cast(&#39;int&#39;, csp)))
    return AST(p_ast[0])

def Minimize(location: Location, weight: AST, priority: AST, terms: Sequence[AST], body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Minimize`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_minimize, p_ast,
        c_location[0],
        weight._rep,
        priority._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])

def Script(location: Location, name: str, code: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Script`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_script, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;char const[]&#39;, code.encode())))
    return AST(p_ast[0])

def Program(location: Location, name: str, parameters: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Program`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_program, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in parameters ]),
        _ffi.cast(&#39;size_t&#39;, len(parameters))))
    return AST(p_ast[0])

def External(location: Location, atom: AST, body: Sequence[AST], external_type: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.External`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_external, p_ast,
        c_location[0],
        atom._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body)),
        external_type._rep))
    return AST(p_ast[0])

def Edge(location: Location, node_u: AST, node_v: AST, body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Edge`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_edge, p_ast,
        c_location[0],
        node_u._rep,
        node_v._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])

def Heuristic(location: Location, atom: AST, body: Sequence[AST], bias: AST, priority: AST, modifier: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Heuristic`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_heuristic, p_ast,
        c_location[0],
        atom._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body)),
        bias._rep,
        priority._rep,
        modifier._rep))
    return AST(p_ast[0])

def ProjectAtom(location: Location, atom: AST, body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ProjectAtom`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_project_atom, p_ast,
        c_location[0],
        atom._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])

def ProjectSignature(location: Location, name: str, arity: int, positive: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ProjectSignature`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_project_signature, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.cast(&#39;int&#39;, positive)))
    return AST(p_ast[0])

def Defined(location: Location, name: str, arity: int, positive: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Defined`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_defined, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.cast(&#39;int&#39;, positive)))
    return AST(p_ast[0])

def TheoryDefinition(location: Location, name: str, terms: Sequence[AST], atoms: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in atoms ]),
        _ffi.cast(&#39;size_t&#39;, len(atoms))))
    return AST(p_ast[0])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clingo.ast.Aggregate"><code class="name flex">
<span>def <span class="ident">Aggregate</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, left_guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType], elements:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], right_guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Aggregate" href="#clingo.ast.ASTType.Aggregate">ASTType.Aggregate</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Aggregate(location: Location, left_guard: Optional[AST], elements: Sequence[AST],
              right_guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Aggregate`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_aggregate, p_ast,
        c_location[0],
        _ffi.NULL if left_guard is None else left_guard._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if right_guard is None else right_guard._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.AggregateGuard"><code class="name flex">
<span>def <span class="ident">AggregateGuard</span></span>(<span>comparison:Â int, term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.AggregateGuard" href="#clingo.ast.ASTType.AggregateGuard">ASTType.AggregateGuard</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AggregateGuard(comparison: int, term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.AggregateGuard`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_aggregate_guard, p_ast,
        _ffi.cast(&#39;int&#39;, comparison),
        term._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.BinaryOperation"><code class="name flex">
<span>def <span class="ident">BinaryOperation</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, operator_type:Â int, left:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, right:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BinaryOperation" href="#clingo.ast.ASTType.BinaryOperation">ASTType.BinaryOperation</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BinaryOperation(location: Location, operator_type: int, left: AST, right: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BinaryOperation`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_binary_operation, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, operator_type),
        left._rep,
        right._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.BodyAggregate"><code class="name flex">
<span>def <span class="ident">BodyAggregate</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, left_guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType], function:Â int, elements:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], right_guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BodyAggregate" href="#clingo.ast.ASTType.BodyAggregate">ASTType.BodyAggregate</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BodyAggregate(location: Location, left_guard: Optional[AST], function: int, elements: Sequence[AST],
                  right_guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BodyAggregate`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_body_aggregate, p_ast,
        c_location[0],
        _ffi.NULL if left_guard is None else left_guard._rep,
        _ffi.cast(&#39;int&#39;, function),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if right_guard is None else right_guard._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.BodyAggregateElement"><code class="name flex">
<span>def <span class="ident">BodyAggregateElement</span></span>(<span>terms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], condition:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BodyAggregateElement" href="#clingo.ast.ASTType.BodyAggregateElement">ASTType.BodyAggregateElement</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BodyAggregateElement(terms: Sequence[AST], condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BodyAggregateElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_body_aggregate_element, p_ast,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.BooleanConstant"><code class="name flex">
<span>def <span class="ident">BooleanConstant</span></span>(<span>value:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BooleanConstant" href="#clingo.ast.ASTType.BooleanConstant">ASTType.BooleanConstant</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BooleanConstant(value: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.BooleanConstant`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_boolean_constant, p_ast,
        _ffi.cast(&#39;int&#39;, value)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Comparison"><code class="name flex">
<span>def <span class="ident">Comparison</span></span>(<span>comparison:Â int, left:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, right:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Comparison" href="#clingo.ast.ASTType.Comparison">ASTType.Comparison</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Comparison(comparison: int, left: AST, right: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Comparison`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_comparison, p_ast,
        _ffi.cast(&#39;int&#39;, comparison),
        left._rep,
        right._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.ConditionalLiteral"><code class="name flex">
<span>def <span class="ident">ConditionalLiteral</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, literal:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, condition:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ConditionalLiteral" href="#clingo.ast.ASTType.ConditionalLiteral">ASTType.ConditionalLiteral</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConditionalLiteral(location: Location, literal: AST, condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ConditionalLiteral`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_conditional_literal, p_ast,
        c_location[0],
        literal._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.CspGuard"><code class="name flex">
<span>def <span class="ident">CspGuard</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, comparison:Â int, term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.CspGuard" href="#clingo.ast.ASTType.CspGuard">ASTType.CspGuard</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CspGuard(location: Location, comparison: int, term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspGuard`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_guard, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, comparison),
        term._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.CspLiteral"><code class="name flex">
<span>def <span class="ident">CspLiteral</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, guards:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.CspLiteral" href="#clingo.ast.ASTType.CspLiteral">ASTType.CspLiteral</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CspLiteral(location: Location, term: AST, guards: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspLiteral`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_literal, p_ast,
        c_location[0],
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in guards ]),
        _ffi.cast(&#39;size_t&#39;, len(guards))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.CspProduct"><code class="name flex">
<span>def <span class="ident">CspProduct</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, coefficient:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, variable:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.CspProduct" href="#clingo.ast.ASTType.CspProduct">ASTType.CspProduct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CspProduct(location: Location, coefficient: AST, variable: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspProduct`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_product, p_ast,
        c_location[0],
        coefficient._rep,
        variable._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.CspSum"><code class="name flex">
<span>def <span class="ident">CspSum</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, coefficient:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, variable:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.CspSum" href="#clingo.ast.ASTType.CspSum">ASTType.CspSum</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CspSum(location: Location, coefficient: AST, variable: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.CspSum`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_csp_sum, p_ast,
        c_location[0],
        coefficient._rep,
        variable._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Defined"><code class="name flex">
<span>def <span class="ident">Defined</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, arity:Â int, positive:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Defined" href="#clingo.ast.ASTType.Defined">ASTType.Defined</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Defined(location: Location, name: str, arity: int, positive: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Defined`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_defined, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.cast(&#39;int&#39;, positive)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Definition"><code class="name flex">
<span>def <span class="ident">Definition</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, value:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, is_default:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Definition" href="#clingo.ast.ASTType.Definition">ASTType.Definition</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Definition(location: Location, name: str, value: AST, is_default: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Definition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        value._rep,
        _ffi.cast(&#39;int&#39;, is_default)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Disjoint"><code class="name flex">
<span>def <span class="ident">Disjoint</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, elements:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Disjoint" href="#clingo.ast.ASTType.Disjoint">ASTType.Disjoint</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Disjoint(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Disjoint`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_disjoint, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.DisjointElement"><code class="name flex">
<span>def <span class="ident">DisjointElement</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, terms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, condition:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.DisjointElement" href="#clingo.ast.ASTType.DisjointElement">ASTType.DisjointElement</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DisjointElement(location: Location, terms: Sequence[AST], term: AST, condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.DisjointElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_disjoint_element, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Disjunction"><code class="name flex">
<span>def <span class="ident">Disjunction</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, elements:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Disjunction" href="#clingo.ast.ASTType.Disjunction">ASTType.Disjunction</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Disjunction(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Disjunction`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_disjunction, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Edge"><code class="name flex">
<span>def <span class="ident">Edge</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, node_u:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, node_v:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, body:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Edge" href="#clingo.ast.ASTType.Edge">ASTType.Edge</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Edge(location: Location, node_u: AST, node_v: AST, body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Edge`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_edge, p_ast,
        c_location[0],
        node_u._rep,
        node_v._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.External"><code class="name flex">
<span>def <span class="ident">External</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, atom:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, body:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], external_type:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.External" href="#clingo.ast.ASTType.External">ASTType.External</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def External(location: Location, atom: AST, body: Sequence[AST], external_type: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.External`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_external, p_ast,
        c_location[0],
        atom._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body)),
        external_type._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Function"><code class="name flex">
<span>def <span class="ident">Function</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, arguments:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], external:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Function" href="#clingo.ast.ASTType.Function">ASTType.Function</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Function(location: Location, name: str, arguments: Sequence[AST], external: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Function`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_function, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in arguments ]),
        _ffi.cast(&#39;size_t&#39;, len(arguments)),
        _ffi.cast(&#39;int&#39;, external)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.HeadAggregate"><code class="name flex">
<span>def <span class="ident">HeadAggregate</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, left_guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType], function:Â int, elements:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], right_guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.HeadAggregate" href="#clingo.ast.ASTType.HeadAggregate">ASTType.HeadAggregate</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HeadAggregate(location: Location, left_guard: Optional[AST], function: int, elements: Sequence[AST],
                  right_guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.HeadAggregate`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_head_aggregate, p_ast,
        c_location[0],
        _ffi.NULL if left_guard is None else left_guard._rep,
        _ffi.cast(&#39;int&#39;, function),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if right_guard is None else right_guard._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.HeadAggregateElement"><code class="name flex">
<span>def <span class="ident">HeadAggregateElement</span></span>(<span>terms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], condition:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.HeadAggregateElement" href="#clingo.ast.ASTType.HeadAggregateElement">ASTType.HeadAggregateElement</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HeadAggregateElement(terms: Sequence[AST], condition: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.HeadAggregateElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_head_aggregate_element, p_ast,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        condition._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Heuristic"><code class="name flex">
<span>def <span class="ident">Heuristic</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, atom:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, body:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], bias:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, priority:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, modifier:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Heuristic" href="#clingo.ast.ASTType.Heuristic">ASTType.Heuristic</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Heuristic(location: Location, atom: AST, body: Sequence[AST], bias: AST, priority: AST, modifier: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Heuristic`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_heuristic, p_ast,
        c_location[0],
        atom._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body)),
        bias._rep,
        priority._rep,
        modifier._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Id"><code class="name flex">
<span>def <span class="ident">Id</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Id" href="#clingo.ast.ASTType.Id">ASTType.Id</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Id(location: Location, name: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Id`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_id, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode())))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Interval"><code class="name flex">
<span>def <span class="ident">Interval</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, left:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, right:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Interval" href="#clingo.ast.ASTType.Interval">ASTType.Interval</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Interval(location: Location, left: AST, right: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Interval`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_interval, p_ast,
        c_location[0],
        left._rep,
        right._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Literal"><code class="name flex">
<span>def <span class="ident">Literal</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, sign:Â int, atom:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Literal" href="#clingo.ast.ASTType.Literal">ASTType.Literal</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Literal(location: Location, sign: int, atom: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Literal`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_literal, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, sign),
        atom._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Minimize"><code class="name flex">
<span>def <span class="ident">Minimize</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, weight:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, priority:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, terms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], body:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Minimize" href="#clingo.ast.ASTType.Minimize">ASTType.Minimize</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Minimize(location: Location, weight: AST, priority: AST, terms: Sequence[AST], body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Minimize`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_minimize, p_ast,
        c_location[0],
        weight._rep,
        priority._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Pool"><code class="name flex">
<span>def <span class="ident">Pool</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, arguments:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Pool" href="#clingo.ast.ASTType.Pool">ASTType.Pool</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Pool(location: Location, arguments: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Pool`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_pool, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in arguments ]),
        _ffi.cast(&#39;size_t&#39;, len(arguments))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Program"><code class="name flex">
<span>def <span class="ident">Program</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, parameters:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Program" href="#clingo.ast.ASTType.Program">ASTType.Program</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Program(location: Location, name: str, parameters: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Program`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_program, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in parameters ]),
        _ffi.cast(&#39;size_t&#39;, len(parameters))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.ProjectAtom"><code class="name flex">
<span>def <span class="ident">ProjectAtom</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, atom:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, body:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ProjectAtom" href="#clingo.ast.ASTType.ProjectAtom">ASTType.ProjectAtom</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProjectAtom(location: Location, atom: AST, body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ProjectAtom`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_project_atom, p_ast,
        c_location[0],
        atom._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.ProjectSignature"><code class="name flex">
<span>def <span class="ident">ProjectSignature</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, arity:Â int, positive:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ProjectSignature" href="#clingo.ast.ASTType.ProjectSignature">ASTType.ProjectSignature</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProjectSignature(location: Location, name: str, arity: int, positive: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ProjectSignature`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_project_signature, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.cast(&#39;int&#39;, positive)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Rule"><code class="name flex">
<span>def <span class="ident">Rule</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, head:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, body:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Rule" href="#clingo.ast.ASTType.Rule">ASTType.Rule</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rule(location: Location, head: AST, body: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Rule`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_rule, p_ast,
        c_location[0],
        head._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Script"><code class="name flex">
<span>def <span class="ident">Script</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, code:Â str) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Script" href="#clingo.ast.ASTType.Script">ASTType.Script</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Script(location: Location, name: str, code: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Script`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_script, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;char const[]&#39;, code.encode())))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.ShowSignature"><code class="name flex">
<span>def <span class="ident">ShowSignature</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, arity:Â int, positive:Â int, csp:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ShowSignature" href="#clingo.ast.ASTType.ShowSignature">ASTType.ShowSignature</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShowSignature(location: Location, name: str, arity: int, positive: int, csp: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ShowSignature`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_show_signature, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.cast(&#39;int&#39;, positive),
        _ffi.cast(&#39;int&#39;, csp)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.ShowTerm"><code class="name flex">
<span>def <span class="ident">ShowTerm</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, body:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], csp:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ShowTerm" href="#clingo.ast.ASTType.ShowTerm">ASTType.ShowTerm</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShowTerm(location: Location, term: AST, body: Sequence[AST], csp: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.ShowTerm`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_show_term, p_ast,
        c_location[0],
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in body ]),
        _ffi.cast(&#39;size_t&#39;, len(body)),
        _ffi.cast(&#39;int&#39;, csp)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.SymbolicTerm"><code class="name flex">
<span>def <span class="ident">SymbolicTerm</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, symbol:Â <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.SymbolicTerm" href="#clingo.ast.ASTType.SymbolicTerm">ASTType.SymbolicTerm</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SymbolicTerm(location: Location, symbol: Symbol) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.SymbolicTerm`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_symbolic_term, p_ast,
        c_location[0],
        _ffi.cast(&#39;clingo_symbol_t&#39;, symbol._rep)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryAtom"><code class="name flex">
<span>def <span class="ident">TheoryAtom</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, elements:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryAtom" href="#clingo.ast.ASTType.TheoryAtom">ASTType.TheoryAtom</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryAtom(location: Location, term: AST, elements: Sequence[AST], guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryAtom`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_atom, p_ast,
        c_location[0],
        term._rep,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements)),
        _ffi.NULL if guard is None else guard._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryAtomDefinition"><code class="name flex">
<span>def <span class="ident">TheoryAtomDefinition</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, atom_type:Â int, name:Â str, arity:Â int, term:Â str, guard:Â Union[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â NoneType]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryAtomDefinition" href="#clingo.ast.ASTType.TheoryAtomDefinition">ASTType.TheoryAtomDefinition</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryAtomDefinition(location: Location, atom_type: int, name: str, arity: int, term: str,
                         guard: Optional[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryAtomDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_atom_definition, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, atom_type),
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, arity),
        _ffi.new(&#39;char const[]&#39;, term.encode()),
        _ffi.NULL if guard is None else guard._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryAtomElement"><code class="name flex">
<span>def <span class="ident">TheoryAtomElement</span></span>(<span>terms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], condition:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryAtomElement" href="#clingo.ast.ASTType.TheoryAtomElement">ASTType.TheoryAtomElement</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryAtomElement(terms: Sequence[AST], condition: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryAtomElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_atom_element, p_ast,
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in condition ]),
        _ffi.cast(&#39;size_t&#39;, len(condition))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryDefinition"><code class="name flex">
<span>def <span class="ident">TheoryDefinition</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, terms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], atoms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryDefinition" href="#clingo.ast.ASTType.TheoryDefinition">ASTType.TheoryDefinition</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryDefinition(location: Location, name: str, terms: Sequence[AST], atoms: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms)),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in atoms ]),
        _ffi.cast(&#39;size_t&#39;, len(atoms))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryFunction"><code class="name flex">
<span>def <span class="ident">TheoryFunction</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, arguments:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryFunction" href="#clingo.ast.ASTType.TheoryFunction">ASTType.TheoryFunction</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryFunction(location: Location, name: str, arguments: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryFunction`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_function, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in arguments ]),
        _ffi.cast(&#39;size_t&#39;, len(arguments))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryGuard"><code class="name flex">
<span>def <span class="ident">TheoryGuard</span></span>(<span>operator_name:Â str, term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryGuard" href="#clingo.ast.ASTType.TheoryGuard">ASTType.TheoryGuard</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryGuard(operator_name: str, term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryGuard`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_guard, p_ast,
        _ffi.new(&#39;char const[]&#39;, operator_name.encode()),
        term._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryGuardDefinition"><code class="name flex">
<span>def <span class="ident">TheoryGuardDefinition</span></span>(<span>operators:Â Sequence[str], term:Â str) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryGuardDefinition" href="#clingo.ast.ASTType.TheoryGuardDefinition">ASTType.TheoryGuardDefinition</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryGuardDefinition(operators: Sequence[str], term: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryGuardDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_operators = [ _ffi.new(&#39;char[]&#39;, x.encode()) for x in operators ]
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_guard_definition, p_ast,
        _ffi.new(&#39;char*[]&#39;, c_operators),
        _ffi.cast(&#39;size_t&#39;, len(operators)),
        _ffi.new(&#39;char const[]&#39;, term.encode())))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryOperatorDefinition"><code class="name flex">
<span>def <span class="ident">TheoryOperatorDefinition</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, priority:Â int, operator_type:Â int) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryOperatorDefinition" href="#clingo.ast.ASTType.TheoryOperatorDefinition">ASTType.TheoryOperatorDefinition</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryOperatorDefinition(location: Location, name: str, priority: int, operator_type: int) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryOperatorDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_operator_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.cast(&#39;int&#39;, priority),
        _ffi.cast(&#39;int&#39;, operator_type)))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheorySequence"><code class="name flex">
<span>def <span class="ident">TheorySequence</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, sequence_type:Â int, terms:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheorySequence" href="#clingo.ast.ASTType.TheorySequence">ASTType.TheorySequence</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheorySequence(location: Location, sequence_type: int, terms: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheorySequence`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_sequence, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, sequence_type),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in terms ]),
        _ffi.cast(&#39;size_t&#39;, len(terms))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryTermDefinition"><code class="name flex">
<span>def <span class="ident">TheoryTermDefinition</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str, operators:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryTermDefinition" href="#clingo.ast.ASTType.TheoryTermDefinition">ASTType.TheoryTermDefinition</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryTermDefinition(location: Location, name: str, operators: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryTermDefinition`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_term_definition, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode()),
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in operators ]),
        _ffi.cast(&#39;size_t&#39;, len(operators))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryUnparsedTerm"><code class="name flex">
<span>def <span class="ident">TheoryUnparsedTerm</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, elements:Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryUnparsedTerm" href="#clingo.ast.ASTType.TheoryUnparsedTerm">ASTType.TheoryUnparsedTerm</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryUnparsedTerm(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryUnparsedTerm`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_unparsed_term, p_ast,
        c_location[0],
        _ffi.new(&#39;clingo_ast_t*[]&#39;, [ x._rep for x in elements ]),
        _ffi.cast(&#39;size_t&#39;, len(elements))))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.TheoryUnparsedTermElement"><code class="name flex">
<span>def <span class="ident">TheoryUnparsedTermElement</span></span>(<span>operators:Â Sequence[str], term:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryUnparsedTermElement" href="#clingo.ast.ASTType.TheoryUnparsedTermElement">ASTType.TheoryUnparsedTermElement</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryUnparsedTermElement(operators: Sequence[str], term: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.TheoryUnparsedTermElement`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_operators = [ _ffi.new(&#39;char[]&#39;, x.encode()) for x in operators ]
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_theory_unparsed_term_element, p_ast,
        _ffi.new(&#39;char*[]&#39;, c_operators),
        _ffi.cast(&#39;size_t&#39;, len(operators)),
        term._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.UnaryOperation"><code class="name flex">
<span>def <span class="ident">UnaryOperation</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, operator_type:Â int, argument:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.UnaryOperation" href="#clingo.ast.ASTType.UnaryOperation">ASTType.UnaryOperation</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnaryOperation(location: Location, operator_type: int, argument: AST) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.UnaryOperation`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_unary_operation, p_ast,
        c_location[0],
        _ffi.cast(&#39;int&#39;, operator_type),
        argument._rep))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.Variable"><code class="name flex">
<span>def <span class="ident">Variable</span></span>(<span>location:Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>, name:Â str) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Variable" href="#clingo.ast.ASTType.Variable">ASTType.Variable</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Variable(location: Location, name: str) -&gt; AST:
    &#39;&#39;&#39;
    Construct an AST node of type `ASTType.Variable`.
    &#39;&#39;&#39;
    p_ast = _ffi.new(&#39;clingo_ast_t**&#39;)
    c_location = _c_location(location)
    _handle_error(_lib.clingo_ast_build(
        _lib.clingo_ast_type_variable, p_ast,
        c_location[0],
        _ffi.new(&#39;char const[]&#39;, name.encode())))
    return AST(p_ast[0])</code></pre>
</details>
</dd>
<dt id="clingo.ast.parse_files"><code class="name flex">
<span>def <span class="ident">parse_files</span></span>(<span>files:Â Sequence[str], callback:Â Callable[[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],Â NoneType], logger:Â Union[Callable[[<a title="clingo.core.MessageCode" href="core.html#clingo.core.MessageCode">MessageCode</a>,Â str],Â NoneType],Â NoneType]Â =Â None, message_limit:Â intÂ =Â 20) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the programs in the given files and return an abstract syntax tree for
each statement via a callback.</p>
<p>The function follows clingo's handling of files on the command line. Filename
<code>"-"</code> is treated as stdin and if an empty list is given, then the parser will
read from stdin.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong></dt>
<dd>List of file names.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>Callable taking an ast as argument.</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Function to intercept messages normally printed to standard error.</dd>
<dt><strong><code>message_limit</code></strong></dt>
<dd>The maximum number of messages passed to the logger.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ast.ProgramBuilder" href="#clingo.ast.ProgramBuilder">ProgramBuilder</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_files(files: Sequence[str], callback: Callable[[AST], None],
                logger: Optional[Logger]=None, message_limit: int=20) -&gt; None:
    &#39;&#39;&#39;
    Parse the programs in the given files and return an abstract syntax tree for
    each statement via a callback.

    The function follows clingo&#39;s handling of files on the command line. Filename
    `&#34;-&#34;` is treated as stdin and if an empty list is given, then the parser will
    read from stdin.

    Parameters
    ----------
    files
        List of file names.
    callback
        Callable taking an ast as argument.
    logger
        Function to intercept messages normally printed to standard error.
    message_limit
        The maximum number of messages passed to the logger.

    See Also
    --------
    ProgramBuilder
    &#39;&#39;&#39;
    if logger is not None:
        c_logger_data = _ffi.new_handle(logger)
        c_logger = _lib.pyclingo_logger_callback
    else:
        c_logger_data = _ffi.NULL
        c_logger = _ffi.NULL

    error = _Error()
    cb_data = _CBData(callback, error)
    c_cb_data = _ffi.new_handle(cb_data)

    _handle_error(_lib.clingo_ast_parse_files([ _ffi.new(&#39;char[]&#39;, f.encode()) for f in files ], len(files),
                                              _lib.pyclingo_ast_callback, c_cb_data,
                                              c_logger, c_logger_data,
                                              message_limit), cb_data)</code></pre>
</details>
</dd>
<dt id="clingo.ast.parse_string"><code class="name flex">
<span>def <span class="ident">parse_string</span></span>(<span>program:Â str, callback:Â Callable[[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],Â NoneType], logger:Â Union[Callable[[<a title="clingo.core.MessageCode" href="core.html#clingo.core.MessageCode">MessageCode</a>,Â str],Â NoneType],Â NoneType]Â =Â None, message_limit:Â intÂ =Â 20) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the given program and return an abstract syntax tree for each
statement via a callback.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>program</code></strong></dt>
<dd>String representation of the program.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>Callable taking an ast as argument.</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Function to intercept messages normally printed to standard error.</dd>
<dt><strong><code>message_limit</code></strong></dt>
<dd>The maximum number of messages passed to the logger.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ast.ProgramBuilder" href="#clingo.ast.ProgramBuilder">ProgramBuilder</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_string(program: str, callback: Callable[[AST], None],
                 logger: Optional[Logger]=None, message_limit: int=20) -&gt; None:
    &#39;&#39;&#39;
    Parse the given program and return an abstract syntax tree for each
    statement via a callback.

    Parameters
    ----------
    program
        String representation of the program.
    callback
        Callable taking an ast as argument.
    logger
        Function to intercept messages normally printed to standard error.
    message_limit
        The maximum number of messages passed to the logger.

    See Also
    --------
    ProgramBuilder
    &#39;&#39;&#39;
    if logger is not None:
        c_logger_data = _ffi.new_handle(logger)
        c_logger = _lib.pyclingo_logger_callback
    else:
        c_logger_data = _ffi.NULL
        c_logger = _ffi.NULL

    error = _Error()
    cb_data = _CBData(callback, error)
    c_cb_data = _ffi.new_handle(cb_data)

    _handle_error(_lib.clingo_ast_parse_string(program.encode(),
                                               _lib.pyclingo_ast_callback, c_cb_data,
                                               c_logger, c_logger_data,
                                               message_limit), cb_data)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingo.ast.AST"><code class="flex name class">
<span>class <span class="ident">AST</span></span>
<span>(</span><span>rep)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a node in the abstract syntax tree.</p>
<p>The attributes of an <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> are tied to its type. They correspond to the
grammar in the description of the <code><a title="clingo.ast" href="#clingo.ast">clingo.ast</a></code> module. <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> nodes can be
constructed using one of the functions provided in this module.</p>
<p>Furthermore, AST nodes implement Python's rich comparison operators and are
ordered structurally ignoring the location. They can also be used as
dictionary keys. Their string representation corresponds to their gringo
representation. In fact, the string representation of any AST obtained from
<code><a title="clingo.ast.parse_files" href="#clingo.ast.parse_files">parse_files()</a></code> and <code><a title="clingo.ast.parse_string" href="#clingo.ast.parse_string">parse_string()</a></code> can be parsed again. Note that it is
possible to construct ASTs that are not parsable, though.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AST:
    &#39;&#39;&#39;
    Represents a node in the abstract syntax tree.

    The attributes of an `AST` are tied to its type. They correspond to the
    grammar in the description of the `clingo.ast` module. `AST` nodes can be
    constructed using one of the functions provided in this module.

    Furthermore, AST nodes implement Python&#39;s rich comparison operators and are
    ordered structurally ignoring the location. They can also be used as
    dictionary keys. Their string representation corresponds to their gringo
    representation. In fact, the string representation of any AST obtained from
    `parse_files` and `parse_string` can be parsed again. Note that it is
    possible to construct ASTs that are not parsable, though.
    &#39;&#39;&#39;
    def __init__(self, rep):
        super().__setattr__(&#39;_rep&#39;, rep)

    def __eq__(self, other):
        if not isinstance(other, AST):
            return NotImplemented
        return _lib.clingo_ast_equal(self._rep, other._rep)

    def __lt__(self, other):
        if not isinstance(other, AST):
            return NotImplemented
        return _lib.clingo_ast_less_than(self._rep, other._rep)

    def __hash__(self):
        return _lib.clingo_ast_hash(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __getattr__(self, name):
        attr_id = _attribute_names.get(name)
        if attr_id is None or not _c_call(&#39;bool&#39;, _lib.clingo_ast_has_attribute, self._rep, attr_id):
            raise AttributeError(f&#39;no attribute: {name}&#39;)
        attr_type = _c_call(&#39;clingo_ast_attribute_type_t&#39;, _lib.clingo_ast_attribute_type, self._rep, attr_id)
        if attr_type == _lib.clingo_ast_attribute_type_string:
            return _to_str(_c_call(&#39;char*&#39;, _lib.clingo_ast_attribute_get_string, self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_number:
            return _c_call(&#39;int&#39;, _lib.clingo_ast_attribute_get_number, self._rep, attr_id)
        if attr_type == _lib.clingo_ast_attribute_type_symbol:
            return Symbol(_c_call(&#39;clingo_symbol_t&#39;, _lib.clingo_ast_attribute_get_symbol,
                                                self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_location:
            return _py_location(_c_call(&#39;clingo_location_t&#39;, _lib.clingo_ast_attribute_get_location,
                                        self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_optional_ast:
            rep = _c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_optional_ast, self._rep, attr_id)
            return AST(rep) if rep != _ffi.NULL else None
        if attr_type == _lib.clingo_ast_attribute_type_ast:
            return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_ast, self._rep, attr_id))
        if attr_type == _lib.clingo_ast_attribute_type_string_array:
            return StrSequence(self._rep, attr_id)
        assert attr_type == _lib.clingo_ast_attribute_type_ast_array
        return ASTSequence(self._rep, attr_id)

    def __setattr__(self, name, value):
        attr_id = getattr(_lib, f&#39;clingo_ast_attribute_{name}&#39;)
        if not _c_call(&#39;bool&#39;, _lib.clingo_ast_has_attribute, self._rep, attr_id):
            raise AttributeError(f&#39;no attribute: {name}&#39;)
        attr_type = _c_call(&#39;clingo_ast_attribute_type_t&#39;, _lib.clingo_ast_attribute_type, self._rep, attr_id)
        if attr_type == _lib.clingo_ast_attribute_type_string:
            _handle_error(_lib.clingo_ast_attribute_set_string(self._rep, attr_id, value.encode()))
        elif attr_type == _lib.clingo_ast_attribute_type_number:
            _handle_error(_lib.clingo_ast_attribute_set_number(self._rep, attr_id, value))
        elif attr_type == _lib.clingo_ast_attribute_type_symbol:
            _handle_error(_lib.clingo_ast_attribute_set_symbol(self._rep, attr_id, value._rep))
        elif attr_type == _lib.clingo_ast_attribute_type_location:
            c_loc = _c_location(value)
            _handle_error(_lib.clingo_ast_attribute_set_location(self._rep, attr_id, c_loc[0]))
        elif attr_type == _lib.clingo_ast_attribute_type_optional_ast:
            _handle_error(_lib.clingo_ast_attribute_set_optional_ast(self._rep, attr_id,
                          _ffi.NULL if value is None else value._rep))
        elif attr_type == _lib.clingo_ast_attribute_type_ast:
            _handle_error(_lib.clingo_ast_attribute_set_ast(self._rep, attr_id, value._rep))
        elif attr_type == _lib.clingo_ast_attribute_type_string_array:
            if isinstance(value, StrSequence):
                if attr_id == value._attribute and self._rep == value._rep:
                    value = list(value)
            elif not isinstance(value, list):
                value = list(value)
            str_seq = StrSequence(self._rep, attr_id)
            str_seq.clear()
            str_seq.extend(value)
        else:
            assert attr_type == _lib.clingo_ast_attribute_type_ast_array
            if isinstance(value, ASTSequence):
                if attr_id == value._attribute and self._rep == value._rep:
                    value = list(value)
            elif not isinstance(value, list):
                value = list(value)
            ast_seq = ASTSequence(self._rep, attr_id)
            ast_seq.clear()
            ast_seq.extend(value)

    def __str__(self):
        return _str(_lib.clingo_ast_to_string_size, _lib.clingo_ast_to_string, self._rep)

    def __repr__(self):
        name = str(self.ast_type).replace(&#39;ASTType&#39;, &#39;ast&#39;)
        args = &#39;, &#39;.join(repr(x) for x in self.values())
        return f&#39;{name}({args})&#39;

    def __copy__(self) -&gt; &#39;AST&#39;:
        &#39;&#39;&#39;
        Return a shallow copy of the ast.
        &#39;&#39;&#39;
        return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_copy, self._rep))

    def __deepcopy__(self, memo) -&gt; &#39;AST&#39;:
        &#39;&#39;&#39;
        Return a deep copy of the ast.
        &#39;&#39;&#39;
        return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_deep_copy, self._rep))

    def update(self, **kwargs: ASTUpdate) -&gt; &#39;AST&#39;:
        &#39;&#39;&#39;
        Return a copy of the AST also updating the given attributes.

        Note that this function returns a reference to self if no arguments are
        given.
        &#39;&#39;&#39;
        if not kwargs:
            return self

        args = []
        for key in self.keys():
            if key in kwargs:
                args.append(kwargs[key])
            else:
                args.append(getattr(self, key))

        cons = globals()[str(self.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)]
        return cons(*args)

    def items(self) -&gt; List[Tuple[str, ASTValue]]:
        &#39;&#39;&#39;
        The list of items of the AST node.
        &#39;&#39;&#39;
        return [ (name, getattr(self, name)) for name in self.keys() ]

    def keys(self) -&gt; List[str]:
        &#39;&#39;&#39;
        The list of keys of the AST node.
        &#39;&#39;&#39;
        cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
        names = _lib.g_clingo_ast_attribute_names.names
        return [ _to_str(names[cons.arguments[j].attribute]) for j in range(cons.size) ]

    def values(self) -&gt; List[ASTValue]:
        &#39;&#39;&#39;
        The list of values of the AST node.
        &#39;&#39;&#39;
        return [ (getattr(self, name)) for name in self.keys() ]

    @property
    def ast_type(self) -&gt; ASTType:
        &#39;&#39;&#39;
        The type of the node.
        &#39;&#39;&#39;
        return ASTType(_c_call(&#39;clingo_ast_type_t&#39;, _lib.clingo_ast_get_type, self._rep))

    @property
    def child_keys(self) -&gt; List[str]:
        &#39;&#39;&#39;
        List of attribute names containing ASTs.
        &#39;&#39;&#39;
        cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
        names = _lib.g_clingo_ast_attribute_names.names
        return [ _to_str(names[cons.arguments[j].attribute])
                 for j in range(cons.size)
                 if cons.arguments[j].type in (_lib.clingo_ast_attribute_type_ast,
                                               _lib.clingo_ast_attribute_type_optional_ast,
                                               _lib.clingo_ast_attribute_type_ast_array) ]

    def unpool(self, other: bool=True, condition: bool=True) -&gt; List[&#39;AST&#39;]:
        &#39;&#39;&#39;
        Unpool the AST returning a list of ASTs without pool terms.

        Parameters
        ----------
        other
            Remove all pools except those in conditions of conditional
            literals.
        condition
            Only remove pools from conditions of conditional literals.
        &#39;&#39;&#39;
        unpool_type = 0
        if other:
            unpool_type |= _lib.clingo_ast_unpool_type_other
        if condition:
            unpool_type |= _lib.clingo_ast_unpool_type_condition

        ret: List[AST] = []
        error = _Error()
        cb_data = _CBData(ret.append, error)
        c_cb_data = _ffi.new_handle(cb_data)
        _handle_error(_lib.clingo_ast_unpool(self._rep, unpool_type, _lib.pyclingo_ast_callback, c_cb_data))
        return ret</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.ast.AST.ast_type"><code class="name">var <span class="ident">ast_type</span> :Â <a title="clingo.ast.ASTType" href="#clingo.ast.ASTType">ASTType</a></code></dt>
<dd>
<div class="desc"><p>The type of the node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ast_type(self) -&gt; ASTType:
    &#39;&#39;&#39;
    The type of the node.
    &#39;&#39;&#39;
    return ASTType(_c_call(&#39;clingo_ast_type_t&#39;, _lib.clingo_ast_get_type, self._rep))</code></pre>
</details>
</dd>
<dt id="clingo.ast.AST.child_keys"><code class="name">var <span class="ident">child_keys</span> :Â List[str]</code></dt>
<dd>
<div class="desc"><p>List of attribute names containing ASTs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def child_keys(self) -&gt; List[str]:
    &#39;&#39;&#39;
    List of attribute names containing ASTs.
    &#39;&#39;&#39;
    cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
    names = _lib.g_clingo_ast_attribute_names.names
    return [ _to_str(names[cons.arguments[j].attribute])
             for j in range(cons.size)
             if cons.arguments[j].type in (_lib.clingo_ast_attribute_type_ast,
                                           _lib.clingo_ast_attribute_type_optional_ast,
                                           _lib.clingo_ast_attribute_type_ast_array) ]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.AST.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self) â€‘>Â List[Tuple[str,Â Union[str,Â int,Â <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a>,Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,Â NoneType,Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â <a title="clingo.ast.StrSequence" href="#clingo.ast.StrSequence">StrSequence</a>,Â <a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a>]]]</span>
</code></dt>
<dd>
<div class="desc"><p>The list of items of the AST node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self) -&gt; List[Tuple[str, ASTValue]]:
    &#39;&#39;&#39;
    The list of items of the AST node.
    &#39;&#39;&#39;
    return [ (name, getattr(self, name)) for name in self.keys() ]</code></pre>
</details>
</dd>
<dt id="clingo.ast.AST.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self) â€‘>Â List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>The list of keys of the AST node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self) -&gt; List[str]:
    &#39;&#39;&#39;
    The list of keys of the AST node.
    &#39;&#39;&#39;
    cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
    names = _lib.g_clingo_ast_attribute_names.names
    return [ _to_str(names[cons.arguments[j].attribute]) for j in range(cons.size) ]</code></pre>
</details>
</dd>
<dt id="clingo.ast.AST.unpool"><code class="name flex">
<span>def <span class="ident">unpool</span></span>(<span>self, other:Â boolÂ =Â True, condition:Â boolÂ =Â True) â€‘>Â List[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Unpool the AST returning a list of ASTs without pool terms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>Remove all pools except those in conditions of conditional
literals.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Only remove pools from conditions of conditional literals.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpool(self, other: bool=True, condition: bool=True) -&gt; List[&#39;AST&#39;]:
    &#39;&#39;&#39;
    Unpool the AST returning a list of ASTs without pool terms.

    Parameters
    ----------
    other
        Remove all pools except those in conditions of conditional
        literals.
    condition
        Only remove pools from conditions of conditional literals.
    &#39;&#39;&#39;
    unpool_type = 0
    if other:
        unpool_type |= _lib.clingo_ast_unpool_type_other
    if condition:
        unpool_type |= _lib.clingo_ast_unpool_type_condition

    ret: List[AST] = []
    error = _Error()
    cb_data = _CBData(ret.append, error)
    c_cb_data = _ffi.new_handle(cb_data)
    _handle_error(_lib.clingo_ast_unpool(self._rep, unpool_type, _lib.pyclingo_ast_callback, c_cb_data))
    return ret</code></pre>
</details>
</dd>
<dt id="clingo.ast.AST.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs:Â Union[str,Â int,Â <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a>,Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,Â NoneType,Â ForwardRef('<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>'),Â Sequence[str],Â Sequence[ForwardRef('<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>')]]) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a copy of the AST also updating the given attributes.</p>
<p>Note that this function returns a reference to self if no arguments are
given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs: ASTUpdate) -&gt; &#39;AST&#39;:
    &#39;&#39;&#39;
    Return a copy of the AST also updating the given attributes.

    Note that this function returns a reference to self if no arguments are
    given.
    &#39;&#39;&#39;
    if not kwargs:
        return self

    args = []
    for key in self.keys():
        if key in kwargs:
            args.append(kwargs[key])
        else:
            args.append(getattr(self, key))

    cons = globals()[str(self.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)]
    return cons(*args)</code></pre>
</details>
</dd>
<dt id="clingo.ast.AST.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self) â€‘>Â List[Union[str,Â int,Â <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a>,Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,Â NoneType,Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â <a title="clingo.ast.StrSequence" href="#clingo.ast.StrSequence">StrSequence</a>,Â <a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>The list of values of the AST node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self) -&gt; List[ASTValue]:
    &#39;&#39;&#39;
    The list of values of the AST node.
    &#39;&#39;&#39;
    return [ (getattr(self, name)) for name in self.keys() ]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ASTSequence"><code class="flex name class">
<span>class <span class="ident">ASTSequence</span></span>
<span>(</span><span>rep, attribute)</span>
</code></dt>
<dd>
<div class="desc"><p>A sequence holding <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ASTSequence(abc.MutableSequence):
    &#39;&#39;&#39;
    A sequence holding `AST` nodes.
    &#39;&#39;&#39;
    def __init__(self, rep, attribute):
        self._rep = rep
        self._attribute = attribute
        _lib.clingo_ast_acquire(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __len__(self) -&gt; int:
        return _c_call(&#39;size_t&#39;, _lib.clingo_ast_attribute_size_ast_array, self._rep, self._attribute)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return SlicedMutableSequence(self, Slice(index))
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        return AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_ast_at, self._rep, self._attribute, index))

    def __iter__(self):
        for index in range(len(self)):
            yield AST(_c_call(&#39;clingo_ast_t*&#39;, _lib.clingo_ast_attribute_get_ast_at, self._rep, self._attribute, index))

    def __setitem__(self, index, ast):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        _handle_error(_lib.clingo_ast_attribute_set_ast_at(self._rep, self._attribute, index, ast._rep))

    def __delitem__(self, index):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        _handle_error(_lib.clingo_ast_attribute_delete_ast_at(self._rep, self._attribute, index))

    def insert(self, index, value):
        _handle_error(_lib.clingo_ast_attribute_insert_ast_at(self._rep, self._attribute, index, value._rep))

    def __str__(self):
        return str(list(self))

    def __repr__(self):
        return repr(list(self))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.ASTSequence.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, index, value)</span>
</code></dt>
<dd>
<div class="desc"><p>S.insert(index, value) &ndash; insert value before index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, index, value):
    _handle_error(_lib.clingo_ast_attribute_insert_ast_at(self._rep, self._attribute, index, value._rep))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ASTType"><code class="flex name class">
<span>class <span class="ident">ASTType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of ast node types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ASTType(Enum):
    &#39;&#39;&#39;
    Enumeration of ast node types.
    &#39;&#39;&#39;
    Id = _lib.clingo_ast_type_id
    Variable = _lib.clingo_ast_type_variable
    SymbolicTerm = _lib.clingo_ast_type_symbolic_term
    UnaryOperation = _lib.clingo_ast_type_unary_operation
    BinaryOperation = _lib.clingo_ast_type_binary_operation
    Interval = _lib.clingo_ast_type_interval
    Function = _lib.clingo_ast_type_function
    Pool = _lib.clingo_ast_type_pool
    CspProduct = _lib.clingo_ast_type_csp_product
    CspSum = _lib.clingo_ast_type_csp_sum
    CspGuard = _lib.clingo_ast_type_csp_guard
    BooleanConstant = _lib.clingo_ast_type_boolean_constant
    SymbolicAtom = _lib.clingo_ast_type_symbolic_atom
    Comparison = _lib.clingo_ast_type_comparison
    CspLiteral = _lib.clingo_ast_type_csp_literal
    AggregateGuard = _lib.clingo_ast_type_aggregate_guard
    ConditionalLiteral = _lib.clingo_ast_type_conditional_literal
    Aggregate = _lib.clingo_ast_type_aggregate
    BodyAggregateElement = _lib.clingo_ast_type_body_aggregate_element
    BodyAggregate = _lib.clingo_ast_type_body_aggregate
    HeadAggregateElement = _lib.clingo_ast_type_head_aggregate_element
    HeadAggregate = _lib.clingo_ast_type_head_aggregate
    Disjunction = _lib.clingo_ast_type_disjunction
    DisjointElement = _lib.clingo_ast_type_disjoint_element
    Disjoint = _lib.clingo_ast_type_disjoint
    TheorySequence = _lib.clingo_ast_type_theory_sequence
    TheoryFunction = _lib.clingo_ast_type_theory_function
    TheoryUnparsedTermElement = _lib.clingo_ast_type_theory_unparsed_term_element
    TheoryUnparsedTerm = _lib.clingo_ast_type_theory_unparsed_term
    TheoryGuard = _lib.clingo_ast_type_theory_guard
    TheoryAtomElement = _lib.clingo_ast_type_theory_atom_element
    TheoryAtom = _lib.clingo_ast_type_theory_atom
    Literal = _lib.clingo_ast_type_literal
    TheoryOperatorDefinition = _lib.clingo_ast_type_theory_operator_definition
    TheoryTermDefinition = _lib.clingo_ast_type_theory_term_definition
    TheoryGuardDefinition = _lib.clingo_ast_type_theory_guard_definition
    TheoryAtomDefinition = _lib.clingo_ast_type_theory_atom_definition
    Rule = _lib.clingo_ast_type_rule
    Definition = _lib.clingo_ast_type_definition
    ShowSignature = _lib.clingo_ast_type_show_signature
    ShowTerm = _lib.clingo_ast_type_show_term
    Minimize = _lib.clingo_ast_type_minimize
    Script = _lib.clingo_ast_type_script
    Program = _lib.clingo_ast_type_program
    External = _lib.clingo_ast_type_external
    Edge = _lib.clingo_ast_type_edge
    Heuristic = _lib.clingo_ast_type_heuristic
    ProjectAtom = _lib.clingo_ast_type_project_atom
    ProjectSignature = _lib.clingo_ast_type_project_signature
    Defined = _lib.clingo_ast_type_defined
    TheoryDefinition = _lib.clingo_ast_type_theory_definition</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.ASTType.Aggregate"><code class="name">var <span class="ident">Aggregate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.AggregateGuard"><code class="name">var <span class="ident">AggregateGuard</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BinaryOperation"><code class="name">var <span class="ident">BinaryOperation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BodyAggregate"><code class="name">var <span class="ident">BodyAggregate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BodyAggregateElement"><code class="name">var <span class="ident">BodyAggregateElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BooleanConstant"><code class="name">var <span class="ident">BooleanConstant</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Comparison"><code class="name">var <span class="ident">Comparison</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ConditionalLiteral"><code class="name">var <span class="ident">ConditionalLiteral</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.CspGuard"><code class="name">var <span class="ident">CspGuard</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.CspLiteral"><code class="name">var <span class="ident">CspLiteral</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.CspProduct"><code class="name">var <span class="ident">CspProduct</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.CspSum"><code class="name">var <span class="ident">CspSum</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Defined"><code class="name">var <span class="ident">Defined</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Definition"><code class="name">var <span class="ident">Definition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Disjoint"><code class="name">var <span class="ident">Disjoint</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.DisjointElement"><code class="name">var <span class="ident">DisjointElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Disjunction"><code class="name">var <span class="ident">Disjunction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Edge"><code class="name">var <span class="ident">Edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.External"><code class="name">var <span class="ident">External</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Function"><code class="name">var <span class="ident">Function</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.HeadAggregate"><code class="name">var <span class="ident">HeadAggregate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.HeadAggregateElement"><code class="name">var <span class="ident">HeadAggregateElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Heuristic"><code class="name">var <span class="ident">Heuristic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Id"><code class="name">var <span class="ident">Id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Interval"><code class="name">var <span class="ident">Interval</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Literal"><code class="name">var <span class="ident">Literal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Minimize"><code class="name">var <span class="ident">Minimize</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Pool"><code class="name">var <span class="ident">Pool</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Program"><code class="name">var <span class="ident">Program</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ProjectAtom"><code class="name">var <span class="ident">ProjectAtom</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ProjectSignature"><code class="name">var <span class="ident">ProjectSignature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Rule"><code class="name">var <span class="ident">Rule</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Script"><code class="name">var <span class="ident">Script</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ShowSignature"><code class="name">var <span class="ident">ShowSignature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ShowTerm"><code class="name">var <span class="ident">ShowTerm</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.SymbolicAtom"><code class="name">var <span class="ident">SymbolicAtom</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.SymbolicTerm"><code class="name">var <span class="ident">SymbolicTerm</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryAtom"><code class="name">var <span class="ident">TheoryAtom</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryAtomDefinition"><code class="name">var <span class="ident">TheoryAtomDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryAtomElement"><code class="name">var <span class="ident">TheoryAtomElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryDefinition"><code class="name">var <span class="ident">TheoryDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryFunction"><code class="name">var <span class="ident">TheoryFunction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryGuard"><code class="name">var <span class="ident">TheoryGuard</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryGuardDefinition"><code class="name">var <span class="ident">TheoryGuardDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryOperatorDefinition"><code class="name">var <span class="ident">TheoryOperatorDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheorySequence"><code class="name">var <span class="ident">TheorySequence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryTermDefinition"><code class="name">var <span class="ident">TheoryTermDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryUnparsedTerm"><code class="name">var <span class="ident">TheoryUnparsedTerm</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryUnparsedTermElement"><code class="name">var <span class="ident">TheoryUnparsedTermElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.UnaryOperation"><code class="name">var <span class="ident">UnaryOperation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Variable"><code class="name">var <span class="ident">Variable</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.AggregateFunction"><code class="flex name class">
<span>class <span class="ident">AggregateFunction</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of aggegate functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AggregateFunction(IntEnum):
    &#39;&#39;&#39;
    Enumeration of aggegate functions.
    &#39;&#39;&#39;
    Count = _lib.clingo_ast_aggregate_function_count
    &#39;&#39;&#39;
    The `#count` function.
    &#39;&#39;&#39;
    Max = _lib.clingo_ast_aggregate_function_max
    &#39;&#39;&#39;
    The `#max` function.
    &#39;&#39;&#39;
    Min = _lib.clingo_ast_aggregate_function_min
    &#39;&#39;&#39;
    The `#min` function.
    &#39;&#39;&#39;
    Sum = _lib.clingo_ast_aggregate_function_sum
    &#39;&#39;&#39;
    The `#sum` function.
    &#39;&#39;&#39;
    SumPlus = _lib.clingo_ast_aggregate_function_sump
    &#39;&#39;&#39;
    The `#sum+` function.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.AggregateFunction.Count"><code class="name">var <span class="ident">Count</span></code></dt>
<dd>
<div class="desc"><p>The <code>#count</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.Max"><code class="name">var <span class="ident">Max</span></code></dt>
<dd>
<div class="desc"><p>The <code>#max</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.Min"><code class="name">var <span class="ident">Min</span></code></dt>
<dd>
<div class="desc"><p>The <code>#min</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.Sum"><code class="name">var <span class="ident">Sum</span></code></dt>
<dd>
<div class="desc"><p>The <code>#sum</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.SumPlus"><code class="name">var <span class="ident">SumPlus</span></code></dt>
<dd>
<div class="desc"><p>The <code>#sum+</code> function.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.BinaryOperator"><code class="flex name class">
<span>class <span class="ident">BinaryOperator</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of binary operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryOperator(IntEnum):
    &#39;&#39;&#39;
    Enumeration of binary operators.
    &#39;&#39;&#39;
    And = _lib.clingo_ast_binary_operator_and
    &#39;&#39;&#39;
    For bitwise and.
    &#39;&#39;&#39;
    Division = _lib.clingo_ast_binary_operator_division
    &#39;&#39;&#39;
    For arithmetic division.
    &#39;&#39;&#39;
    Minus = _lib.clingo_ast_binary_operator_minus
    &#39;&#39;&#39;
    For arithmetic subtraction.
    &#39;&#39;&#39;
    Modulo = _lib.clingo_ast_binary_operator_modulo
    &#39;&#39;&#39;
    For arithmetic modulo.
    &#39;&#39;&#39;
    Multiplication = _lib.clingo_ast_binary_operator_multiplication
    &#39;&#39;&#39;
    For arithmetic multipilcation.
    &#39;&#39;&#39;
    Or = _lib.clingo_ast_binary_operator_or
    &#39;&#39;&#39;
    For bitwise or.
    &#39;&#39;&#39;
    Plus = _lib.clingo_ast_binary_operator_plus
    &#39;&#39;&#39;
    For arithmetic addition.
    &#39;&#39;&#39;
    Power = _lib.clingo_ast_binary_operator_power
    &#39;&#39;&#39;
    For arithmetic exponentiation.
    &#39;&#39;&#39;
    XOr = _lib.clingo_ast_binary_operator_xor
    &#39;&#39;&#39;
    For bitwise exclusive or.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.BinaryOperator.And"><code class="name">var <span class="ident">And</span></code></dt>
<dd>
<div class="desc"><p>For bitwise and.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Division"><code class="name">var <span class="ident">Division</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic division.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Minus"><code class="name">var <span class="ident">Minus</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic subtraction.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Modulo"><code class="name">var <span class="ident">Modulo</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic modulo.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Multiplication"><code class="name">var <span class="ident">Multiplication</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic multipilcation.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Or"><code class="name">var <span class="ident">Or</span></code></dt>
<dd>
<div class="desc"><p>For bitwise or.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Plus"><code class="name">var <span class="ident">Plus</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic addition.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Power"><code class="name">var <span class="ident">Power</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic exponentiation.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.XOr"><code class="name">var <span class="ident">XOr</span></code></dt>
<dd>
<div class="desc"><p>For bitwise exclusive or.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ComparisonOperator"><code class="flex name class">
<span>class <span class="ident">ComparisonOperator</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of comparison operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComparisonOperator(IntEnum):
    &#39;&#39;&#39;
    Enumeration of comparison operators.
    &#39;&#39;&#39;
    Equal = _lib.clingo_ast_comparison_operator_equal
    &#39;&#39;&#39;
    The `=` operator
    &#39;&#39;&#39;
    GreaterEqual = _lib.clingo_ast_comparison_operator_greater_equal
    &#39;&#39;&#39;
    The `&gt;=` operator.
    &#39;&#39;&#39;
    GreaterThan = _lib.clingo_ast_comparison_operator_greater_than
    &#39;&#39;&#39;
    The `&gt;` operator.
    &#39;&#39;&#39;
    LessEqual = _lib.clingo_ast_comparison_operator_less_equal
    &#39;&#39;&#39;
    The `&lt;=` operator.
    &#39;&#39;&#39;
    LessThan = _lib.clingo_ast_comparison_operator_less_than
    &#39;&#39;&#39;
    The `&lt;` operator.
    &#39;&#39;&#39;
    NotEqual = _lib.clingo_ast_comparison_operator_not_equal
    &#39;&#39;&#39;
    The `!=` operator.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.ComparisonOperator.Equal"><code class="name">var <span class="ident">Equal</span></code></dt>
<dd>
<div class="desc"><p>The <code>=</code> operator</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.GreaterEqual"><code class="name">var <span class="ident">GreaterEqual</span></code></dt>
<dd>
<div class="desc"><p>The <code>&gt;=</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.GreaterThan"><code class="name">var <span class="ident">GreaterThan</span></code></dt>
<dd>
<div class="desc"><p>The <code>&gt;</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.LessEqual"><code class="name">var <span class="ident">LessEqual</span></code></dt>
<dd>
<div class="desc"><p>The <code>&lt;=</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.LessThan"><code class="name">var <span class="ident">LessThan</span></code></dt>
<dd>
<div class="desc"><p>The <code>&lt;</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.NotEqual"><code class="name">var <span class="ident">NotEqual</span></code></dt>
<dd>
<div class="desc"><p>The <code>!=</code> operator.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>begin:Â <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a>, end:Â <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to point to a range in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#39;&#39;&#39;
    Class to point to a range in a text file.
    &#39;&#39;&#39;
    begin: Position
    &#39;&#39;&#39;
    The beginning of the range.
    &#39;&#39;&#39;
    end: Position
    &#39;&#39;&#39;
    The end of the range.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.ast.Location.begin"><code class="name">var <span class="ident">begin</span> :Â <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a></code></dt>
<dd>
<div class="desc"><p>The beginning of the range.</p></div>
</dd>
<dt id="clingo.ast.Location.end"><code class="name">var <span class="ident">end</span> :Â <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a></code></dt>
<dd>
<div class="desc"><p>The end of the range.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Position"><code class="flex name class">
<span>class <span class="ident">Position</span></span>
<span>(</span><span>filename:Â str, line:Â int, column:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to point to a position in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position(NamedTuple):
    &#39;&#39;&#39;
    Class to point to a position in a text file.
    &#39;&#39;&#39;
    filename: str
    &#39;&#39;&#39;
    The file name.
    &#39;&#39;&#39;
    line: int
    &#39;&#39;&#39;
    The line number in the file.
    &#39;&#39;&#39;
    column: int
    &#39;&#39;&#39;
    The column number in the line.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.ast.Position.column"><code class="name">var <span class="ident">column</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The column number in the line.</p></div>
</dd>
<dt id="clingo.ast.Position.filename"><code class="name">var <span class="ident">filename</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The file name.</p></div>
</dd>
<dt id="clingo.ast.Position.line"><code class="name">var <span class="ident">line</span> :Â int</code></dt>
<dd>
<div class="desc"><p>The line number in the file.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ProgramBuilder"><code class="flex name class">
<span>class <span class="ident">ProgramBuilder</span></span>
<span>(</span><span>control:Â <a title="clingo.control.Control" href="control.html#clingo.control.Control">Control</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Object to build non-ground programs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>control</code></strong></dt>
<dd>The <code><a title="clingo.control.Control" href="control.html#clingo.control.Control">Control</a></code> object to attach the builder to.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ast.parse_string" href="#clingo.ast.parse_string">parse_string()</a></code>, <code><a title="clingo.ast.parse_files" href="#clingo.ast.parse_files">parse_files()</a></code></p>
<h2 id="notes">Notes</h2>
<p>This class is a context manager and must be used with Python's <code>with</code>
statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgramBuilder(ContextManager[&#39;ProgramBuilder&#39;]):
    &#39;&#39;&#39;
    Object to build non-ground programs.

    Parameters
    ----------
    control
        The `clingo.control.Control` object to attach the builder to.

    See Also
    --------
    parse_string, parse_files

    Notes
    -----
    This class is a context manager and must be used with Python&#39;s `with`
    statement.
    &#39;&#39;&#39;
    def __init__(self, control: Control):
        self._rep = _c_call(&#39;clingo_program_builder_t*&#39;, _lib.clingo_control_program_builder, control._rep)

    def __enter__(self):
        _handle_error(_lib.clingo_program_builder_begin(self._rep))
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        _handle_error(_lib.clingo_program_builder_end(self._rep))
        return False

    def add(self, statement: AST) -&gt; None:
        &#39;&#39;&#39;
        Adds a statement in form of an `AST` node to the program.

        Parameters
        ----------
        statement
            The statement to add.
        &#39;&#39;&#39;
        _handle_error(_lib.clingo_program_builder_add(self._rep, statement._rep))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>contextlib.AbstractContextManager</li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.ProgramBuilder.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, statement:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a statement in form of an <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> node to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement to add.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, statement: AST) -&gt; None:
    &#39;&#39;&#39;
    Adds a statement in form of an `AST` node to the program.

    Parameters
    ----------
    statement
        The statement to add.
    &#39;&#39;&#39;
    _handle_error(_lib.clingo_program_builder_add(self._rep, statement._rep))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Sign"><code class="flex name class">
<span>class <span class="ident">Sign</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of signs for literals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sign(IntEnum):
    &#39;&#39;&#39;
    Enumeration of signs for literals.
    &#39;&#39;&#39;
    DoubleNegation = _lib.clingo_ast_sign_double_negation
    &#39;&#39;&#39;
    For double negated literals (with prefix `not not`)
    &#39;&#39;&#39;
    Negation = _lib.clingo_ast_sign_negation
    &#39;&#39;&#39;
    For negative literals (with prefix `not`).
    &#39;&#39;&#39;
    NoSign = _lib.clingo_ast_sign_no_sign
    &#39;&#39;&#39;
    For positive literals.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.Sign.DoubleNegation"><code class="name">var <span class="ident">DoubleNegation</span></code></dt>
<dd>
<div class="desc"><p>For double negated literals (with prefix <code>not not</code>)</p></div>
</dd>
<dt id="clingo.ast.Sign.Negation"><code class="name">var <span class="ident">Negation</span></code></dt>
<dd>
<div class="desc"><p>For negative literals (with prefix <code>not</code>).</p></div>
</dd>
<dt id="clingo.ast.Sign.NoSign"><code class="name">var <span class="ident">NoSign</span></code></dt>
<dd>
<div class="desc"><p>For positive literals.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.StrSequence"><code class="flex name class">
<span>class <span class="ident">StrSequence</span></span>
<span>(</span><span>rep, attribute)</span>
</code></dt>
<dd>
<div class="desc"><p>A sequence holding strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrSequence(abc.MutableSequence):
    &#39;&#39;&#39;
    A sequence holding strings.
    &#39;&#39;&#39;
    def __init__(self, rep, attribute):
        self._attribute = attribute
        self._rep = rep
        _lib.clingo_ast_acquire(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __len__(self) -&gt; int:
        return _c_call(&#39;size_t&#39;, _lib.clingo_ast_attribute_size_string_array, self._rep, self._attribute)

    def __getitem__(self, index):
        if isinstance(index, slice):
            return SlicedMutableSequence(self, Slice(index))
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        return _to_str(_c_call(&#39;char*&#39;, _lib.clingo_ast_attribute_get_string_at, self._rep, self._attribute, index))

    def __iter__(self):
        for index in range(len(self)):
            yield _to_str(_c_call(&#39;char*&#39;, _lib.clingo_ast_attribute_get_string_at, self._rep, self._attribute, index))

    def __setitem__(self, index, value):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        _handle_error(_lib.clingo_str_attribute_set_string_at(self._rep, self._attribute, index, value.encode()))

    def __delitem__(self, index):
        if isinstance(index, slice):
            raise TypeError(&#39;slicing not implemented&#39;)
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#39;invalid index&#39;)
        _handle_error(_lib.clingo_ast_attribute_delete_string_at(self._rep, self._attribute, index))

    def insert(self, index, value):
        _handle_error(_lib.clingo_ast_attribute_insert_string_at(self._rep, self._attribute, index, value.encode()))

    def __str__(self):
        return str(list(self))

    def __repr__(self):
        return repr(list(self))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.StrSequence.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, index, value)</span>
</code></dt>
<dd>
<div class="desc"><p>S.insert(index, value) &ndash; insert value before index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, index, value):
    _handle_error(_lib.clingo_ast_attribute_insert_string_at(self._rep, self._attribute, index, value.encode()))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingo.ast.TheoryAtomType"><code class="flex name class">
<span>class <span class="ident">TheoryAtomType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of theory atom types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryAtomType(IntEnum):
    &#39;&#39;&#39;
    Enumeration of theory atom types.
    &#39;&#39;&#39;
    Any = _lib.clingo_ast_theory_atom_definition_type_any
    &#39;&#39;&#39;
    For atoms that can occur anywhere in a rule.
    &#39;&#39;&#39;
    Body = _lib.clingo_ast_theory_atom_definition_type_body
    &#39;&#39;&#39;
    For atoms that can only occur in rule bodies.
    &#39;&#39;&#39;
    Directive = _lib.clingo_ast_theory_atom_definition_type_directive
    &#39;&#39;&#39;
    For atoms that can only occur in facts.
    &#39;&#39;&#39;
    Head = _lib.clingo_ast_theory_atom_definition_type_head
    &#39;&#39;&#39;
    For atoms that can only occur in rule heads.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.TheoryAtomType.Any"><code class="name">var <span class="ident">Any</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can occur anywhere in a rule.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomType.Body"><code class="name">var <span class="ident">Body</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can only occur in rule bodies.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomType.Directive"><code class="name">var <span class="ident">Directive</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can only occur in facts.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomType.Head"><code class="name">var <span class="ident">Head</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can only occur in rule heads.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.TheoryOperatorType"><code class="flex name class">
<span>class <span class="ident">TheoryOperatorType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of operator types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryOperatorType(IntEnum):
    &#39;&#39;&#39;
    Enumeration of operator types.
    &#39;&#39;&#39;
    BinaryLeft = _lib.clingo_ast_theory_operator_type_binary_left
    &#39;&#39;&#39;
    For binary left associative operators.
    &#39;&#39;&#39;
    BinaryRight = _lib.clingo_ast_theory_operator_type_binary_right
    &#39;&#39;&#39;
    For binary right associative operator.
    &#39;&#39;&#39;
    Unary = _lib.clingo_ast_theory_operator_type_unary
    &#39;&#39;&#39;
    For unary operators.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.TheoryOperatorType.BinaryLeft"><code class="name">var <span class="ident">BinaryLeft</span></code></dt>
<dd>
<div class="desc"><p>For binary left associative operators.</p></div>
</dd>
<dt id="clingo.ast.TheoryOperatorType.BinaryRight"><code class="name">var <span class="ident">BinaryRight</span></code></dt>
<dd>
<div class="desc"><p>For binary right associative operator.</p></div>
</dd>
<dt id="clingo.ast.TheoryOperatorType.Unary"><code class="name">var <span class="ident">Unary</span></code></dt>
<dd>
<div class="desc"><p>For unary operators.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.TheorySequenceType"><code class="flex name class">
<span>class <span class="ident">TheorySequenceType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of theory term sequence types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheorySequenceType(IntEnum):
    &#39;&#39;&#39;
    Enumeration of theory term sequence types.
    &#39;&#39;&#39;
    List = _lib.clingo_ast_theory_sequence_type_list
    &#39;&#39;&#39;
    For sequences enclosed in brackets.
    &#39;&#39;&#39;
    Set = _lib.clingo_ast_theory_sequence_type_set
    &#39;&#39;&#39;
    For sequences enclosed in braces.
    &#39;&#39;&#39;
    Tuple = _lib.clingo_ast_theory_sequence_type_tuple
    &#39;&#39;&#39;
    For sequences enclosed in parenthesis.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.TheorySequenceType.List"><code class="name">var <span class="ident">List</span></code></dt>
<dd>
<div class="desc"><p>For sequences enclosed in brackets.</p></div>
</dd>
<dt id="clingo.ast.TheorySequenceType.Set"><code class="name">var <span class="ident">Set</span></code></dt>
<dd>
<div class="desc"><p>For sequences enclosed in braces.</p></div>
</dd>
<dt id="clingo.ast.TheorySequenceType.Tuple"><code class="name">var <span class="ident">Tuple</span></code></dt>
<dd>
<div class="desc"><p>For sequences enclosed in parenthesis.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Transformer"><code class="flex name class">
<span>class <span class="ident">Transformer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Utility class to transform ASTs.</p>
<p>Classes should inherit from this class and implement functions with name
<code>visit_&lt;ast_type&gt;</code> where <code>&lt;ast_type&gt;</code> is the type of the ASTs to visit and
modify. Such a function should return an updated AST or the same AST if no
change is necessary. The transformer will take care to copy all parent ASTs
involving a modified child. Note that the class works like a visitor if
only self references are returned from such functions.</p>
<p>Any extra arguments passed to the visit method are passed on to child ASTs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformer:
    &#39;&#39;&#39;
    Utility class to transform ASTs.

    Classes should inherit from this class and implement functions with name
    `visit_&lt;ast_type&gt;` where `&lt;ast_type&gt;` is the type of the ASTs to visit and
    modify. Such a function should return an updated AST or the same AST if no
    change is necessary. The transformer will take care to copy all parent ASTs
    involving a modified child. Note that the class works like a visitor if
    only self references are returned from such functions.

    Any extra arguments passed to the visit method are passed on to child ASTs.
    &#39;&#39;&#39;
    def visit(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
        &#39;&#39;&#39;
        Dispatch to a visit method in a base class or visit and transform the
        children of the given AST if it is missing.
        &#39;&#39;&#39;
        attr = &#39;visit_&#39; + str(ast.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)
        if hasattr(self, attr):
            return getattr(self, attr)(ast, *args, **kwargs)
        return ast.update(**self.visit_children(ast, *args, **kwargs))

    def visit_children(self, ast: AST, *args: Any, **kwargs: Any) -&gt; Dict[str, ASTUpdate]:
        &#39;&#39;&#39;
        Visit and transform the children of the given AST.

        Returns
        -------
        The functions returns a dictionary that can be passed to `AST.update`.
        It contains the attributes and values that have been transformed.
        &#39;&#39;&#39;
        update: Dict[str, ASTUpdate] = dict()
        for key in ast.child_keys:
            old = getattr(ast, key)
            new = self._dispatch(old, *args, **kwargs)
            if new is not old:
                update[key] = new
        return update

    def visit_sequence(self, sequence: ASTSequence, *args: Any, **kwargs: Any) -&gt; MutableSequence[AST]:
        &#39;&#39;&#39;
        Transform a sequence of ASTs returning the same sequnce if there are no
        changes or a list of ASTs otherwise.
        &#39;&#39;&#39;
        ret: MutableSequence[AST]
        ret, lst = sequence, []
        for old in sequence:
            lst.append(self(old, *args, **kwargs))
            if lst[-1] is not old:
                ret = lst
        return ret

    def _dispatch(self, ast: Union[None, AST, ASTSequence], *args: Any, **kwargs: Any) -&gt; Union[None, AST, MutableSequence[AST]]:
        &#39;&#39;&#39;
        Visit and transform an (optional) AST or a sequence of ASTs.
        &#39;&#39;&#39;
        if ast is None:
            return ast

        if isinstance(ast, AST):
            return self.visit(ast, *args, **kwargs) # type: ignore

        if isinstance(ast, abc.Sequence):
            return self.visit_sequence(ast, *args, **kwargs)

        raise TypeError(&#39;unexpected type&#39;)

    def __call__(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
        &#39;&#39;&#39;
        Alternative way to call `Transformer.visit`.
        &#39;&#39;&#39;
        return self.visit(ast, *args, **kwargs)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clingox.ast.SymbolicAtomRenamer" href="../clingox/ast.html#clingox.ast.SymbolicAtomRenamer">SymbolicAtomRenamer</a></li>
<li><a title="clingox.ast.TheoryParser" href="../clingox/ast.html#clingox.ast.TheoryParser">TheoryParser</a></li>
<li><a title="clingox.ast.TheoryTermParser" href="../clingox/ast.html#clingox.ast.TheoryTermParser">TheoryTermParser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.Transformer.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self, ast:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, *args:Â Any, **kwargs:Â Any) â€‘>Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<div class="desc"><p>Dispatch to a visit method in a base class or visit and transform the
children of the given AST if it is missing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
    &#39;&#39;&#39;
    Dispatch to a visit method in a base class or visit and transform the
    children of the given AST if it is missing.
    &#39;&#39;&#39;
    attr = &#39;visit_&#39; + str(ast.ast_type).replace(&#39;ASTType.&#39;, &#39;&#39;)
    if hasattr(self, attr):
        return getattr(self, attr)(ast, *args, **kwargs)
    return ast.update(**self.visit_children(ast, *args, **kwargs))</code></pre>
</details>
</dd>
<dt id="clingo.ast.Transformer.visit_children"><code class="name flex">
<span>def <span class="ident">visit_children</span></span>(<span>self, ast:Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>, *args:Â Any, **kwargs:Â Any) â€‘>Â Dict[str,Â Union[str,Â int,Â <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a>,Â <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,Â NoneType,Â <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,Â Sequence[str],Â Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Visit and transform the children of the given AST.</p>
<h2 id="returns">Returns</h2>
<p>The functions returns a dictionary that can be passed to <code><a title="clingo.ast.AST.update" href="#clingo.ast.AST.update">AST.update()</a></code>.
It contains the attributes and values that have been transformed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_children(self, ast: AST, *args: Any, **kwargs: Any) -&gt; Dict[str, ASTUpdate]:
    &#39;&#39;&#39;
    Visit and transform the children of the given AST.

    Returns
    -------
    The functions returns a dictionary that can be passed to `AST.update`.
    It contains the attributes and values that have been transformed.
    &#39;&#39;&#39;
    update: Dict[str, ASTUpdate] = dict()
    for key in ast.child_keys:
        old = getattr(ast, key)
        new = self._dispatch(old, *args, **kwargs)
        if new is not old:
            update[key] = new
    return update</code></pre>
</details>
</dd>
<dt id="clingo.ast.Transformer.visit_sequence"><code class="name flex">
<span>def <span class="ident">visit_sequence</span></span>(<span>self, sequence:Â <a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a>, *args:Â Any, **kwargs:Â Any) â€‘>Â MutableSequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a sequence of ASTs returning the same sequnce if there are no
changes or a list of ASTs otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_sequence(self, sequence: ASTSequence, *args: Any, **kwargs: Any) -&gt; MutableSequence[AST]:
    &#39;&#39;&#39;
    Transform a sequence of ASTs returning the same sequnce if there are no
    changes or a list of ASTs otherwise.
    &#39;&#39;&#39;
    ret: MutableSequence[AST]
    ret, lst = sequence, []
    for old in sequence:
        lst.append(self(old, *args, **kwargs))
        if lst[-1] is not old:
            ret = lst
    return ret</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="clingo.ast.UnaryOperator"><code class="flex name class">
<span>class <span class="ident">UnaryOperator</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumeration of signs for literals.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryOperator(IntEnum):
    &#39;&#39;&#39;
    Enumeration of signs for literals.
    &#39;&#39;&#39;
    Absolute = _lib.clingo_ast_unary_operator_absolute
    &#39;&#39;&#39;
    For taking the absolute value.
    &#39;&#39;&#39;
    Minus = _lib.clingo_ast_unary_operator_minus
    &#39;&#39;&#39;
    For unary minus and classical negation.
    &#39;&#39;&#39;
    Negation = _lib.clingo_ast_unary_operator_negation
    &#39;&#39;&#39;
    For bitwise negation.
    &#39;&#39;&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.UnaryOperator.Absolute"><code class="name">var <span class="ident">Absolute</span></code></dt>
<dd>
<div class="desc"><p>For taking the absolute value.</p></div>
</dd>
<dt id="clingo.ast.UnaryOperator.Minus"><code class="name">var <span class="ident">Minus</span></code></dt>
<dd>
<div class="desc"><p>For unary minus and classical negation.</p></div>
</dd>
<dt id="clingo.ast.UnaryOperator.Negation"><code class="name">var <span class="ident">Negation</span></code></dt>
<dd>
<div class="desc"><p>For bitwise negation.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#grammar">Grammar</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clingo" href="index.html">clingo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clingo.ast.Aggregate" href="#clingo.ast.Aggregate">Aggregate</a></code></li>
<li><code><a title="clingo.ast.AggregateGuard" href="#clingo.ast.AggregateGuard">AggregateGuard</a></code></li>
<li><code><a title="clingo.ast.BinaryOperation" href="#clingo.ast.BinaryOperation">BinaryOperation</a></code></li>
<li><code><a title="clingo.ast.BodyAggregate" href="#clingo.ast.BodyAggregate">BodyAggregate</a></code></li>
<li><code><a title="clingo.ast.BodyAggregateElement" href="#clingo.ast.BodyAggregateElement">BodyAggregateElement</a></code></li>
<li><code><a title="clingo.ast.BooleanConstant" href="#clingo.ast.BooleanConstant">BooleanConstant</a></code></li>
<li><code><a title="clingo.ast.Comparison" href="#clingo.ast.Comparison">Comparison</a></code></li>
<li><code><a title="clingo.ast.ConditionalLiteral" href="#clingo.ast.ConditionalLiteral">ConditionalLiteral</a></code></li>
<li><code><a title="clingo.ast.CspGuard" href="#clingo.ast.CspGuard">CspGuard</a></code></li>
<li><code><a title="clingo.ast.CspLiteral" href="#clingo.ast.CspLiteral">CspLiteral</a></code></li>
<li><code><a title="clingo.ast.CspProduct" href="#clingo.ast.CspProduct">CspProduct</a></code></li>
<li><code><a title="clingo.ast.CspSum" href="#clingo.ast.CspSum">CspSum</a></code></li>
<li><code><a title="clingo.ast.Defined" href="#clingo.ast.Defined">Defined</a></code></li>
<li><code><a title="clingo.ast.Definition" href="#clingo.ast.Definition">Definition</a></code></li>
<li><code><a title="clingo.ast.Disjoint" href="#clingo.ast.Disjoint">Disjoint</a></code></li>
<li><code><a title="clingo.ast.DisjointElement" href="#clingo.ast.DisjointElement">DisjointElement</a></code></li>
<li><code><a title="clingo.ast.Disjunction" href="#clingo.ast.Disjunction">Disjunction</a></code></li>
<li><code><a title="clingo.ast.Edge" href="#clingo.ast.Edge">Edge</a></code></li>
<li><code><a title="clingo.ast.External" href="#clingo.ast.External">External</a></code></li>
<li><code><a title="clingo.ast.Function" href="#clingo.ast.Function">Function</a></code></li>
<li><code><a title="clingo.ast.HeadAggregate" href="#clingo.ast.HeadAggregate">HeadAggregate</a></code></li>
<li><code><a title="clingo.ast.HeadAggregateElement" href="#clingo.ast.HeadAggregateElement">HeadAggregateElement</a></code></li>
<li><code><a title="clingo.ast.Heuristic" href="#clingo.ast.Heuristic">Heuristic</a></code></li>
<li><code><a title="clingo.ast.Id" href="#clingo.ast.Id">Id</a></code></li>
<li><code><a title="clingo.ast.Interval" href="#clingo.ast.Interval">Interval</a></code></li>
<li><code><a title="clingo.ast.Literal" href="#clingo.ast.Literal">Literal</a></code></li>
<li><code><a title="clingo.ast.Minimize" href="#clingo.ast.Minimize">Minimize</a></code></li>
<li><code><a title="clingo.ast.Pool" href="#clingo.ast.Pool">Pool</a></code></li>
<li><code><a title="clingo.ast.Program" href="#clingo.ast.Program">Program</a></code></li>
<li><code><a title="clingo.ast.ProjectAtom" href="#clingo.ast.ProjectAtom">ProjectAtom</a></code></li>
<li><code><a title="clingo.ast.ProjectSignature" href="#clingo.ast.ProjectSignature">ProjectSignature</a></code></li>
<li><code><a title="clingo.ast.Rule" href="#clingo.ast.Rule">Rule</a></code></li>
<li><code><a title="clingo.ast.Script" href="#clingo.ast.Script">Script</a></code></li>
<li><code><a title="clingo.ast.ShowSignature" href="#clingo.ast.ShowSignature">ShowSignature</a></code></li>
<li><code><a title="clingo.ast.ShowTerm" href="#clingo.ast.ShowTerm">ShowTerm</a></code></li>
<li><code><a title="clingo.ast.SymbolicTerm" href="#clingo.ast.SymbolicTerm">SymbolicTerm</a></code></li>
<li><code><a title="clingo.ast.TheoryAtom" href="#clingo.ast.TheoryAtom">TheoryAtom</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomDefinition" href="#clingo.ast.TheoryAtomDefinition">TheoryAtomDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomElement" href="#clingo.ast.TheoryAtomElement">TheoryAtomElement</a></code></li>
<li><code><a title="clingo.ast.TheoryDefinition" href="#clingo.ast.TheoryDefinition">TheoryDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryFunction" href="#clingo.ast.TheoryFunction">TheoryFunction</a></code></li>
<li><code><a title="clingo.ast.TheoryGuard" href="#clingo.ast.TheoryGuard">TheoryGuard</a></code></li>
<li><code><a title="clingo.ast.TheoryGuardDefinition" href="#clingo.ast.TheoryGuardDefinition">TheoryGuardDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryOperatorDefinition" href="#clingo.ast.TheoryOperatorDefinition">TheoryOperatorDefinition</a></code></li>
<li><code><a title="clingo.ast.TheorySequence" href="#clingo.ast.TheorySequence">TheorySequence</a></code></li>
<li><code><a title="clingo.ast.TheoryTermDefinition" href="#clingo.ast.TheoryTermDefinition">TheoryTermDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryUnparsedTerm" href="#clingo.ast.TheoryUnparsedTerm">TheoryUnparsedTerm</a></code></li>
<li><code><a title="clingo.ast.TheoryUnparsedTermElement" href="#clingo.ast.TheoryUnparsedTermElement">TheoryUnparsedTermElement</a></code></li>
<li><code><a title="clingo.ast.UnaryOperation" href="#clingo.ast.UnaryOperation">UnaryOperation</a></code></li>
<li><code><a title="clingo.ast.Variable" href="#clingo.ast.Variable">Variable</a></code></li>
<li><code><a title="clingo.ast.parse_files" href="#clingo.ast.parse_files">parse_files</a></code></li>
<li><code><a title="clingo.ast.parse_string" href="#clingo.ast.parse_string">parse_string</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ast.AST.ast_type" href="#clingo.ast.AST.ast_type">ast_type</a></code></li>
<li><code><a title="clingo.ast.AST.child_keys" href="#clingo.ast.AST.child_keys">child_keys</a></code></li>
<li><code><a title="clingo.ast.AST.items" href="#clingo.ast.AST.items">items</a></code></li>
<li><code><a title="clingo.ast.AST.keys" href="#clingo.ast.AST.keys">keys</a></code></li>
<li><code><a title="clingo.ast.AST.unpool" href="#clingo.ast.AST.unpool">unpool</a></code></li>
<li><code><a title="clingo.ast.AST.update" href="#clingo.ast.AST.update">update</a></code></li>
<li><code><a title="clingo.ast.AST.values" href="#clingo.ast.AST.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.ASTSequence.insert" href="#clingo.ast.ASTSequence.insert">insert</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ASTType" href="#clingo.ast.ASTType">ASTType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.ASTType.Aggregate" href="#clingo.ast.ASTType.Aggregate">Aggregate</a></code></li>
<li><code><a title="clingo.ast.ASTType.AggregateGuard" href="#clingo.ast.ASTType.AggregateGuard">AggregateGuard</a></code></li>
<li><code><a title="clingo.ast.ASTType.BinaryOperation" href="#clingo.ast.ASTType.BinaryOperation">BinaryOperation</a></code></li>
<li><code><a title="clingo.ast.ASTType.BodyAggregate" href="#clingo.ast.ASTType.BodyAggregate">BodyAggregate</a></code></li>
<li><code><a title="clingo.ast.ASTType.BodyAggregateElement" href="#clingo.ast.ASTType.BodyAggregateElement">BodyAggregateElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.BooleanConstant" href="#clingo.ast.ASTType.BooleanConstant">BooleanConstant</a></code></li>
<li><code><a title="clingo.ast.ASTType.Comparison" href="#clingo.ast.ASTType.Comparison">Comparison</a></code></li>
<li><code><a title="clingo.ast.ASTType.ConditionalLiteral" href="#clingo.ast.ASTType.ConditionalLiteral">ConditionalLiteral</a></code></li>
<li><code><a title="clingo.ast.ASTType.CspGuard" href="#clingo.ast.ASTType.CspGuard">CspGuard</a></code></li>
<li><code><a title="clingo.ast.ASTType.CspLiteral" href="#clingo.ast.ASTType.CspLiteral">CspLiteral</a></code></li>
<li><code><a title="clingo.ast.ASTType.CspProduct" href="#clingo.ast.ASTType.CspProduct">CspProduct</a></code></li>
<li><code><a title="clingo.ast.ASTType.CspSum" href="#clingo.ast.ASTType.CspSum">CspSum</a></code></li>
<li><code><a title="clingo.ast.ASTType.Defined" href="#clingo.ast.ASTType.Defined">Defined</a></code></li>
<li><code><a title="clingo.ast.ASTType.Definition" href="#clingo.ast.ASTType.Definition">Definition</a></code></li>
<li><code><a title="clingo.ast.ASTType.Disjoint" href="#clingo.ast.ASTType.Disjoint">Disjoint</a></code></li>
<li><code><a title="clingo.ast.ASTType.DisjointElement" href="#clingo.ast.ASTType.DisjointElement">DisjointElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.Disjunction" href="#clingo.ast.ASTType.Disjunction">Disjunction</a></code></li>
<li><code><a title="clingo.ast.ASTType.Edge" href="#clingo.ast.ASTType.Edge">Edge</a></code></li>
<li><code><a title="clingo.ast.ASTType.External" href="#clingo.ast.ASTType.External">External</a></code></li>
<li><code><a title="clingo.ast.ASTType.Function" href="#clingo.ast.ASTType.Function">Function</a></code></li>
<li><code><a title="clingo.ast.ASTType.HeadAggregate" href="#clingo.ast.ASTType.HeadAggregate">HeadAggregate</a></code></li>
<li><code><a title="clingo.ast.ASTType.HeadAggregateElement" href="#clingo.ast.ASTType.HeadAggregateElement">HeadAggregateElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.Heuristic" href="#clingo.ast.ASTType.Heuristic">Heuristic</a></code></li>
<li><code><a title="clingo.ast.ASTType.Id" href="#clingo.ast.ASTType.Id">Id</a></code></li>
<li><code><a title="clingo.ast.ASTType.Interval" href="#clingo.ast.ASTType.Interval">Interval</a></code></li>
<li><code><a title="clingo.ast.ASTType.Literal" href="#clingo.ast.ASTType.Literal">Literal</a></code></li>
<li><code><a title="clingo.ast.ASTType.Minimize" href="#clingo.ast.ASTType.Minimize">Minimize</a></code></li>
<li><code><a title="clingo.ast.ASTType.Pool" href="#clingo.ast.ASTType.Pool">Pool</a></code></li>
<li><code><a title="clingo.ast.ASTType.Program" href="#clingo.ast.ASTType.Program">Program</a></code></li>
<li><code><a title="clingo.ast.ASTType.ProjectAtom" href="#clingo.ast.ASTType.ProjectAtom">ProjectAtom</a></code></li>
<li><code><a title="clingo.ast.ASTType.ProjectSignature" href="#clingo.ast.ASTType.ProjectSignature">ProjectSignature</a></code></li>
<li><code><a title="clingo.ast.ASTType.Rule" href="#clingo.ast.ASTType.Rule">Rule</a></code></li>
<li><code><a title="clingo.ast.ASTType.Script" href="#clingo.ast.ASTType.Script">Script</a></code></li>
<li><code><a title="clingo.ast.ASTType.ShowSignature" href="#clingo.ast.ASTType.ShowSignature">ShowSignature</a></code></li>
<li><code><a title="clingo.ast.ASTType.ShowTerm" href="#clingo.ast.ASTType.ShowTerm">ShowTerm</a></code></li>
<li><code><a title="clingo.ast.ASTType.SymbolicAtom" href="#clingo.ast.ASTType.SymbolicAtom">SymbolicAtom</a></code></li>
<li><code><a title="clingo.ast.ASTType.SymbolicTerm" href="#clingo.ast.ASTType.SymbolicTerm">SymbolicTerm</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryAtom" href="#clingo.ast.ASTType.TheoryAtom">TheoryAtom</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryAtomDefinition" href="#clingo.ast.ASTType.TheoryAtomDefinition">TheoryAtomDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryAtomElement" href="#clingo.ast.ASTType.TheoryAtomElement">TheoryAtomElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryDefinition" href="#clingo.ast.ASTType.TheoryDefinition">TheoryDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryFunction" href="#clingo.ast.ASTType.TheoryFunction">TheoryFunction</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryGuard" href="#clingo.ast.ASTType.TheoryGuard">TheoryGuard</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryGuardDefinition" href="#clingo.ast.ASTType.TheoryGuardDefinition">TheoryGuardDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryOperatorDefinition" href="#clingo.ast.ASTType.TheoryOperatorDefinition">TheoryOperatorDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheorySequence" href="#clingo.ast.ASTType.TheorySequence">TheorySequence</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryTermDefinition" href="#clingo.ast.ASTType.TheoryTermDefinition">TheoryTermDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryUnparsedTerm" href="#clingo.ast.ASTType.TheoryUnparsedTerm">TheoryUnparsedTerm</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryUnparsedTermElement" href="#clingo.ast.ASTType.TheoryUnparsedTermElement">TheoryUnparsedTermElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.UnaryOperation" href="#clingo.ast.ASTType.UnaryOperation">UnaryOperation</a></code></li>
<li><code><a title="clingo.ast.ASTType.Variable" href="#clingo.ast.ASTType.Variable">Variable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.AggregateFunction" href="#clingo.ast.AggregateFunction">AggregateFunction</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.AggregateFunction.Count" href="#clingo.ast.AggregateFunction.Count">Count</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.Max" href="#clingo.ast.AggregateFunction.Max">Max</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.Min" href="#clingo.ast.AggregateFunction.Min">Min</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.Sum" href="#clingo.ast.AggregateFunction.Sum">Sum</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.SumPlus" href="#clingo.ast.AggregateFunction.SumPlus">SumPlus</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.BinaryOperator" href="#clingo.ast.BinaryOperator">BinaryOperator</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ast.BinaryOperator.And" href="#clingo.ast.BinaryOperator.And">And</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Division" href="#clingo.ast.BinaryOperator.Division">Division</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Minus" href="#clingo.ast.BinaryOperator.Minus">Minus</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Modulo" href="#clingo.ast.BinaryOperator.Modulo">Modulo</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Multiplication" href="#clingo.ast.BinaryOperator.Multiplication">Multiplication</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Or" href="#clingo.ast.BinaryOperator.Or">Or</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Plus" href="#clingo.ast.BinaryOperator.Plus">Plus</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Power" href="#clingo.ast.BinaryOperator.Power">Power</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.XOr" href="#clingo.ast.BinaryOperator.XOr">XOr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ComparisonOperator" href="#clingo.ast.ComparisonOperator">ComparisonOperator</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ast.ComparisonOperator.Equal" href="#clingo.ast.ComparisonOperator.Equal">Equal</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.GreaterEqual" href="#clingo.ast.ComparisonOperator.GreaterEqual">GreaterEqual</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.GreaterThan" href="#clingo.ast.ComparisonOperator.GreaterThan">GreaterThan</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.LessEqual" href="#clingo.ast.ComparisonOperator.LessEqual">LessEqual</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.LessThan" href="#clingo.ast.ComparisonOperator.LessThan">LessThan</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.NotEqual" href="#clingo.ast.ComparisonOperator.NotEqual">NotEqual</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Location.begin" href="#clingo.ast.Location.begin">begin</a></code></li>
<li><code><a title="clingo.ast.Location.end" href="#clingo.ast.Location.end">end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Position.column" href="#clingo.ast.Position.column">column</a></code></li>
<li><code><a title="clingo.ast.Position.filename" href="#clingo.ast.Position.filename">filename</a></code></li>
<li><code><a title="clingo.ast.Position.line" href="#clingo.ast.Position.line">line</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ProgramBuilder" href="#clingo.ast.ProgramBuilder">ProgramBuilder</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.ProgramBuilder.add" href="#clingo.ast.ProgramBuilder.add">add</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Sign" href="#clingo.ast.Sign">Sign</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Sign.DoubleNegation" href="#clingo.ast.Sign.DoubleNegation">DoubleNegation</a></code></li>
<li><code><a title="clingo.ast.Sign.Negation" href="#clingo.ast.Sign.Negation">Negation</a></code></li>
<li><code><a title="clingo.ast.Sign.NoSign" href="#clingo.ast.Sign.NoSign">NoSign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.StrSequence" href="#clingo.ast.StrSequence">StrSequence</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.StrSequence.insert" href="#clingo.ast.StrSequence.insert">insert</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.TheoryAtomType" href="#clingo.ast.TheoryAtomType">TheoryAtomType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.TheoryAtomType.Any" href="#clingo.ast.TheoryAtomType.Any">Any</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomType.Body" href="#clingo.ast.TheoryAtomType.Body">Body</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomType.Directive" href="#clingo.ast.TheoryAtomType.Directive">Directive</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomType.Head" href="#clingo.ast.TheoryAtomType.Head">Head</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.TheoryOperatorType" href="#clingo.ast.TheoryOperatorType">TheoryOperatorType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.TheoryOperatorType.BinaryLeft" href="#clingo.ast.TheoryOperatorType.BinaryLeft">BinaryLeft</a></code></li>
<li><code><a title="clingo.ast.TheoryOperatorType.BinaryRight" href="#clingo.ast.TheoryOperatorType.BinaryRight">BinaryRight</a></code></li>
<li><code><a title="clingo.ast.TheoryOperatorType.Unary" href="#clingo.ast.TheoryOperatorType.Unary">Unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.TheorySequenceType" href="#clingo.ast.TheorySequenceType">TheorySequenceType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.TheorySequenceType.List" href="#clingo.ast.TheorySequenceType.List">List</a></code></li>
<li><code><a title="clingo.ast.TheorySequenceType.Set" href="#clingo.ast.TheorySequenceType.Set">Set</a></code></li>
<li><code><a title="clingo.ast.TheorySequenceType.Tuple" href="#clingo.ast.TheorySequenceType.Tuple">Tuple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Transformer" href="#clingo.ast.Transformer">Transformer</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Transformer.visit" href="#clingo.ast.Transformer.visit">visit</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_children" href="#clingo.ast.Transformer.visit_children">visit_children</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_sequence" href="#clingo.ast.Transformer.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.UnaryOperator" href="#clingo.ast.UnaryOperator">UnaryOperator</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.UnaryOperator.Absolute" href="#clingo.ast.UnaryOperator.Absolute">Absolute</a></code></li>
<li><code><a title="clingo.ast.UnaryOperator.Minus" href="#clingo.ast.UnaryOperator.Minus">Minus</a></code></li>
<li><code><a title="clingo.ast.UnaryOperator.Negation" href="#clingo.ast.UnaryOperator.Negation">Negation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
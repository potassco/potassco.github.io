<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>clingo.ast API documentation</title>
<meta name="description" content="Module to work with clingo&#39;s non-ground program representation …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<nav class="http-server-breadcrumbs">
<a href="https://potassco.org/clingo/python-api/5.8/">All packages</a>
:: <a href="https://potassco.org/clingo/python-api/5.8/clingo/">clingo</a>
</nav>
<h1 class="title">Module <code>clingo.ast</code></h1>
</header>
<section id="section-intro">
<p>Module to work with clingo's non-ground program representation.</p>
<h2 id="grammar">Grammar</h2>
<p>The grammar below defines valid ASTs. For each upper case identifier there is a
matching function in the module. Arguments follow in parenthesis: each having a
type given on the right-hand side of the colon. The symbols <code>?</code>, <code>*</code>, and <code>+</code>
are used to denote optional arguments (<code>None</code> encodes abscence), list
arguments, and non-empty list arguments.</p>
<pre><code># Terms

term = SymbolicTerm
        ( location : Location
        , symbol   : clingo.Symbol
        )
     | Variable
        ( location : Location
        , name     : str
        )
     | UnaryOperation
        ( location      : Location
        , operator_type : UnaryOperator
        , argument      : term
        )
     | BinaryOperation
        ( location      : Location
        , operator_type : BinaryOperator
        , left          : term
        , right         : term
        )
     | Interval
        ( location : Location
        , left     : term
        , right    : term
        )
     | Function
        ( location  : Location
        , name      : str
        , arguments : term*
        , external  : bool
        )
     | Pool
        ( location  : Location
        , arguments : term*
        )

theory_term = SymbolicTerm
               ( location : Location
               , symbol   : clingo.Symbol
               )
            | Variable
               ( location : Location
               , name     : str
               )
            | TheorySequence
               ( location : Location
               , sequence_type : TheorySequenceType
               , terms         : theory_term*
               )
            | TheoryFunction
               ( location  : Location
               , name      : str
               , arguments : theory_term*
               )
            | TheoryUnparsedTerm
               ( location : Location
               , elements : TheoryUnparsedTermElement
                             ( operators : str*
                             , term      : theory_term
                             )+
               )

# Literals

symbolic_atom = SymbolicAtom
                 ( symbol : term
                 )

guard = Guard
         ( comparison : ComparisonOperator
         , term       : term
         )

literal = Literal
           ( location : Location
           , sign     : Sign
           , atom     : Comparison
                         ( term   : term
                         , guards : guard+
                         )
                      | BooleanConstant
                         ( value : bool
                         )
                      | symbolic_atom
           )

# Head and Body Literals

conditional_literal = ConditionalLiteral
                       ( location  : Location
                       , literal   : Literal
                       , condition : Literal*
                       )

aggregate = Aggregate
             ( location    : Location
             , left_guard  : guard?
             , elements    : conditional_literal*
             , right_guard : guard?
             )

theory_atom = TheoryAtom
               ( location : Location
               , term     : term
               , elements : TheoryAtomElement
                             ( terms     : theory_term*
                             , condition : literal*
                             )*
               , guard    : TheoryGuard
                             ( operator_name : str
                             , term          : theory_term
                             )?
               )

body_atom = aggregate
          | BodyAggregate
             ( location    : Location
             , left_guard  : guard?
             , function    : AggregateFunction
             , elements    : BodyAggregateElement
                              ( terms     : term*
                              , condition : literal*
                              )*
             , right_guard : guard?
             )
          | theory_atom

body_literal = literal
             | conditional_literal
             | Literal
                ( location : Location
                , sign     : Sign
                , atom     : body_atom
                )

head = literal
     | aggregate
     | HeadAggregate
        ( location    : Location
        , left_guard  : guard?
        , function    : AggregateFunction
        , elements    : HeadAggregateElement
                         ( terms     : term*
                         , condition : conditional_literal
                         )*
        , right_guard : guard?
        )
     | Disjunction
        ( location : Location
        , elements : conditional_literal*
        )
     | theory_atom

# Statements

statement = Rule
             ( location : Location
             , head     : head
             , body     : body_literal*
             )
          | Definition
             ( location   : Location
             , name       : str
             , value      : term
             , is_default : bool
             )
          | ShowSignature
             ( location   : Location
             , name       : str
             , arity      : int
             , sign       : bool
             )
          | Defined
             ( location   : Location
             , name       : str
             , arity      : int
             , sign       : bool
             )
          | ShowTerm
             ( location : Location
             , term     : term
             , body     : body_literal*
             )
          | Minimize
             ( location : Location
             , weight   : term
             , priority : term
             , terms    : term*
             , body     : body_literal*
             )
          | Script
             ( location : Location
             , name     : str
             , code     : str
             )
          | Program
             ( location   : Location
             , name       : str
             , parameters : Id
                             ( location : Location
                             , id       : str
                             )*
             )
          | External
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             , type     : term
             )
          | Edge
             ( location : Location
             , u        : term
             , v        : term
             , body     : body_literal*
             )
          | Heuristic
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             , bias     : term
             , priority : term
             , modifier : term
             )
          | ProjectAtom
             ( location : Location
             , atom     : symbolic_atom
             , body     : body_literal*
             )
          | ProjectSignature
             ( location : Location
             , name     : str
             , arity    : int
             , sign     : bool
             )
          | TheoryDefinition
             ( location : Location
             , name     : str
             , terms    : TheoryTermDefinition
                           ( location  : Location
                           , name      : str
                           , operators : TheoryOperatorDefinition
                                          ( location      : Location
                                          , name          : str
                                          , priority      : int
                                          , operator_type : TheoryOperatorType
                                          )*
                           )*
             , atoms    : TheoryAtomDefinition
                           ( location  : Location
                           , atom_type : TheoryAtomType
                           , name      : str
                           , arity     : int
                           , term      : str
                           , guard     : TheoryGuardDefinition
                                          ( operators : str*
                                          , term      : str
                                          )?
                           )*
             )
          | Comment
             ( location     : Location
             , value        : str
             , comment_type : CommentType
             )
</code></pre>
<h2 id="examples">Examples</h2>
<p>The following example parses a program from a string and passes the resulting
<code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> to the builder:</p>
<pre><code>&gt;&gt;&gt; from clingo import Control, ast
&gt;&gt;&gt; from clingo.ast import Location, ProgramBuilder, Position, parse_string
&gt;&gt;&gt;
&gt;&gt;&gt; ctl = Control()
&gt;&gt;&gt;
&gt;&gt;&gt; with ProgramBuilder(ctl) as bld:
...     # parse from string
...     parse_string('a.', bld.add)
...     # build rule manually
...     pos = Position('&lt;string&gt;', 1, 1)
...     loc = Location(pos, pos)
...     fun = ast.Function(loc, 'b', [], False)
...     atm = ast.SymbolicAtom(fun)
...     lit = ast.Literal(loc, ast.Sign.NoSign, atm)
...     bld.add(ast.Rule(loc, lit, []))
...
&gt;&gt;&gt; ctl.ground([('base', [])])
&gt;&gt;&gt; print(ctl.solve(on_model=print))
a b
SAT
</code></pre>
<p>The next example shows how to transform ASTs using the <code><a title="clingo.ast.Transformer" href="#clingo.ast.Transformer">Transformer</a></code> class:</p>
<pre><code>&gt;&gt;&gt; from clingo.ast import Transformer, Variable, parse_string
&gt;&gt;&gt;
&gt;&gt;&gt; class VariableRenamer(Transformer):
...     def visit_Variable(self, node):
...         return node.update(name='_' + node.name)
...
&gt;&gt;&gt; vrt = VariableRenamer()
&gt;&gt;&gt; parse_string('p(X) :- q(X).', lambda stm: print(str(vrt(stm))))
#program base.
p(_X) :- q(_X).
</code></pre>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clingo.ast.Aggregate"><code class="name flex">
<span>def <span class="ident">Aggregate</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>left_guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None,<br>elements: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>right_guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Aggregate(
    location: Location,
    left_guard: Optional[AST],
    elements: Sequence[AST],
    right_guard: Optional[AST],
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Aggregate`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_aggregate,
            p_ast,
            c_location[0],
            _ffi.NULL if left_guard is None else left_guard._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in elements]),
            _ffi.cast(&#34;size_t&#34;, len(elements)),
            _ffi.NULL if right_guard is None else right_guard._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Aggregate" href="#clingo.ast.ASTType.Aggregate">ASTType.Aggregate</a></code>.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperation"><code class="name flex">
<span>def <span class="ident">BinaryOperation</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>operator_type: int,<br>left: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>right: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BinaryOperation(
    location: Location, operator_type: int, left: AST, right: AST
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.BinaryOperation`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_binary_operation,
            p_ast,
            c_location[0],
            _ffi.cast(&#34;int&#34;, operator_type),
            left._rep,
            right._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BinaryOperation" href="#clingo.ast.ASTType.BinaryOperation">ASTType.BinaryOperation</a></code>.</p></div>
</dd>
<dt id="clingo.ast.BodyAggregate"><code class="name flex">
<span>def <span class="ident">BodyAggregate</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>left_guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None,<br>function: int,<br>elements: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>right_guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BodyAggregate(
    location: Location,
    left_guard: Optional[AST],
    function: int,
    elements: Sequence[AST],
    right_guard: Optional[AST],
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.BodyAggregate`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_body_aggregate,
            p_ast,
            c_location[0],
            _ffi.NULL if left_guard is None else left_guard._rep,
            _ffi.cast(&#34;int&#34;, function),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in elements]),
            _ffi.cast(&#34;size_t&#34;, len(elements)),
            _ffi.NULL if right_guard is None else right_guard._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BodyAggregate" href="#clingo.ast.ASTType.BodyAggregate">ASTType.BodyAggregate</a></code>.</p></div>
</dd>
<dt id="clingo.ast.BodyAggregateElement"><code class="name flex">
<span>def <span class="ident">BodyAggregateElement</span></span>(<span>terms: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>condition: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BodyAggregateElement(terms: Sequence[AST], condition: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.BodyAggregateElement`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_body_aggregate_element,
            p_ast,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in terms]),
            _ffi.cast(&#34;size_t&#34;, len(terms)),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in condition]),
            _ffi.cast(&#34;size_t&#34;, len(condition)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BodyAggregateElement" href="#clingo.ast.ASTType.BodyAggregateElement">ASTType.BodyAggregateElement</a></code>.</p></div>
</dd>
<dt id="clingo.ast.BooleanConstant"><code class="name flex">
<span>def <span class="ident">BooleanConstant</span></span>(<span>value: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BooleanConstant(value: int) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.BooleanConstant`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_boolean_constant, p_ast, _ffi.cast(&#34;int&#34;, value)
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.BooleanConstant" href="#clingo.ast.ASTType.BooleanConstant">ASTType.BooleanConstant</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Comment"><code class="name flex">
<span>def <span class="ident">Comment</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>value: str,<br>comment_type: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Comment(location: Location, value: str, comment_type: int) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Comment`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_comment,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, value.encode()),
            _ffi.cast(&#34;int&#34;, comment_type),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Comment" href="#clingo.ast.ASTType.Comment">ASTType.Comment</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Comparison"><code class="name flex">
<span>def <span class="ident">Comparison</span></span>(<span>term: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>guards: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Comparison(term: AST, guards: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Comparison`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_comparison,
            p_ast,
            term._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in guards]),
            _ffi.cast(&#34;size_t&#34;, len(guards)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Comparison" href="#clingo.ast.ASTType.Comparison">ASTType.Comparison</a></code>.</p></div>
</dd>
<dt id="clingo.ast.ConditionalLiteral"><code class="name flex">
<span>def <span class="ident">ConditionalLiteral</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>literal: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>condition: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConditionalLiteral(
    location: Location, literal: AST, condition: Sequence[AST]
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.ConditionalLiteral`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_conditional_literal,
            p_ast,
            c_location[0],
            literal._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in condition]),
            _ffi.cast(&#34;size_t&#34;, len(condition)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ConditionalLiteral" href="#clingo.ast.ASTType.ConditionalLiteral">ASTType.ConditionalLiteral</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Defined"><code class="name flex">
<span>def <span class="ident">Defined</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>arity: int,<br>positive: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Defined(location: Location, name: str, arity: int, positive: int) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Defined`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_defined,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.cast(&#34;int&#34;, arity),
            _ffi.cast(&#34;int&#34;, positive),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Defined" href="#clingo.ast.ASTType.Defined">ASTType.Defined</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Definition"><code class="name flex">
<span>def <span class="ident">Definition</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>value: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>is_default: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Definition(location: Location, name: str, value: AST, is_default: int) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Definition`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_definition,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            value._rep,
            _ffi.cast(&#34;int&#34;, is_default),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Definition" href="#clingo.ast.ASTType.Definition">ASTType.Definition</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Disjunction"><code class="name flex">
<span>def <span class="ident">Disjunction</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>elements: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Disjunction(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Disjunction`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_disjunction,
            p_ast,
            c_location[0],
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in elements]),
            _ffi.cast(&#34;size_t&#34;, len(elements)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Disjunction" href="#clingo.ast.ASTType.Disjunction">ASTType.Disjunction</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Edge"><code class="name flex">
<span>def <span class="ident">Edge</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>node_u: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>node_v: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>body: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Edge(location: Location, node_u: AST, node_v: AST, body: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Edge`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_edge,
            p_ast,
            c_location[0],
            node_u._rep,
            node_v._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in body]),
            _ffi.cast(&#34;size_t&#34;, len(body)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Edge" href="#clingo.ast.ASTType.Edge">ASTType.Edge</a></code>.</p></div>
</dd>
<dt id="clingo.ast.External"><code class="name flex">
<span>def <span class="ident">External</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>atom: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>body: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>external_type: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def External(
    location: Location, atom: AST, body: Sequence[AST], external_type: AST
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.External`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_external,
            p_ast,
            c_location[0],
            atom._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in body]),
            _ffi.cast(&#34;size_t&#34;, len(body)),
            external_type._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.External" href="#clingo.ast.ASTType.External">ASTType.External</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Function"><code class="name flex">
<span>def <span class="ident">Function</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>arguments: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>external: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Function(
    location: Location, name: str, arguments: Sequence[AST], external: int
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Function`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_function,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in arguments]),
            _ffi.cast(&#34;size_t&#34;, len(arguments)),
            _ffi.cast(&#34;int&#34;, external),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Function" href="#clingo.ast.ASTType.Function">ASTType.Function</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Guard"><code class="name flex">
<span>def <span class="ident">Guard</span></span>(<span>comparison: int,<br>term: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Guard(comparison: int, term: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Guard`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_guard, p_ast, _ffi.cast(&#34;int&#34;, comparison), term._rep
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Guard" href="#clingo.ast.ASTType.Guard">ASTType.Guard</a></code>.</p></div>
</dd>
<dt id="clingo.ast.HeadAggregate"><code class="name flex">
<span>def <span class="ident">HeadAggregate</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>left_guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None,<br>function: int,<br>elements: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>right_guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HeadAggregate(
    location: Location,
    left_guard: Optional[AST],
    function: int,
    elements: Sequence[AST],
    right_guard: Optional[AST],
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.HeadAggregate`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_head_aggregate,
            p_ast,
            c_location[0],
            _ffi.NULL if left_guard is None else left_guard._rep,
            _ffi.cast(&#34;int&#34;, function),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in elements]),
            _ffi.cast(&#34;size_t&#34;, len(elements)),
            _ffi.NULL if right_guard is None else right_guard._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.HeadAggregate" href="#clingo.ast.ASTType.HeadAggregate">ASTType.HeadAggregate</a></code>.</p></div>
</dd>
<dt id="clingo.ast.HeadAggregateElement"><code class="name flex">
<span>def <span class="ident">HeadAggregateElement</span></span>(<span>terms: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>condition: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HeadAggregateElement(terms: Sequence[AST], condition: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.HeadAggregateElement`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_head_aggregate_element,
            p_ast,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in terms]),
            _ffi.cast(&#34;size_t&#34;, len(terms)),
            condition._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.HeadAggregateElement" href="#clingo.ast.ASTType.HeadAggregateElement">ASTType.HeadAggregateElement</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Heuristic"><code class="name flex">
<span>def <span class="ident">Heuristic</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>atom: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>body: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>bias: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>priority: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>modifier: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Heuristic(
    location: Location,
    atom: AST,
    body: Sequence[AST],
    bias: AST,
    priority: AST,
    modifier: AST,
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Heuristic`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_heuristic,
            p_ast,
            c_location[0],
            atom._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in body]),
            _ffi.cast(&#34;size_t&#34;, len(body)),
            bias._rep,
            priority._rep,
            modifier._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Heuristic" href="#clingo.ast.ASTType.Heuristic">ASTType.Heuristic</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Id"><code class="name flex">
<span>def <span class="ident">Id</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Id(location: Location, name: str) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Id`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_id,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Id" href="#clingo.ast.ASTType.Id">ASTType.Id</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Interval"><code class="name flex">
<span>def <span class="ident">Interval</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>left: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>right: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Interval(location: Location, left: AST, right: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Interval`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_interval, p_ast, c_location[0], left._rep, right._rep
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Interval" href="#clingo.ast.ASTType.Interval">ASTType.Interval</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Literal"><code class="name flex">
<span>def <span class="ident">Literal</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>sign: int,<br>atom: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Literal(location: Location, sign: int, atom: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Literal`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_literal,
            p_ast,
            c_location[0],
            _ffi.cast(&#34;int&#34;, sign),
            atom._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Literal" href="#clingo.ast.ASTType.Literal">ASTType.Literal</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Minimize"><code class="name flex">
<span>def <span class="ident">Minimize</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>weight: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>priority: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>terms: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>body: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Minimize(
    location: Location,
    weight: AST,
    priority: AST,
    terms: Sequence[AST],
    body: Sequence[AST],
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Minimize`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_minimize,
            p_ast,
            c_location[0],
            weight._rep,
            priority._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in terms]),
            _ffi.cast(&#34;size_t&#34;, len(terms)),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in body]),
            _ffi.cast(&#34;size_t&#34;, len(body)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Minimize" href="#clingo.ast.ASTType.Minimize">ASTType.Minimize</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Pool"><code class="name flex">
<span>def <span class="ident">Pool</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>arguments: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Pool(location: Location, arguments: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Pool`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_pool,
            p_ast,
            c_location[0],
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in arguments]),
            _ffi.cast(&#34;size_t&#34;, len(arguments)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Pool" href="#clingo.ast.ASTType.Pool">ASTType.Pool</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Program"><code class="name flex">
<span>def <span class="ident">Program</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>parameters: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Program(location: Location, name: str, parameters: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Program`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_program,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in parameters]),
            _ffi.cast(&#34;size_t&#34;, len(parameters)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Program" href="#clingo.ast.ASTType.Program">ASTType.Program</a></code>.</p></div>
</dd>
<dt id="clingo.ast.ProjectAtom"><code class="name flex">
<span>def <span class="ident">ProjectAtom</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>atom: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>body: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProjectAtom(location: Location, atom: AST, body: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.ProjectAtom`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_project_atom,
            p_ast,
            c_location[0],
            atom._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in body]),
            _ffi.cast(&#34;size_t&#34;, len(body)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ProjectAtom" href="#clingo.ast.ASTType.ProjectAtom">ASTType.ProjectAtom</a></code>.</p></div>
</dd>
<dt id="clingo.ast.ProjectSignature"><code class="name flex">
<span>def <span class="ident">ProjectSignature</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>arity: int,<br>positive: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ProjectSignature(location: Location, name: str, arity: int, positive: int) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.ProjectSignature`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_project_signature,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.cast(&#34;int&#34;, arity),
            _ffi.cast(&#34;int&#34;, positive),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ProjectSignature" href="#clingo.ast.ASTType.ProjectSignature">ASTType.ProjectSignature</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Rule"><code class="name flex">
<span>def <span class="ident">Rule</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>head: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>body: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rule(location: Location, head: AST, body: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Rule`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_rule,
            p_ast,
            c_location[0],
            head._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in body]),
            _ffi.cast(&#34;size_t&#34;, len(body)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Rule" href="#clingo.ast.ASTType.Rule">ASTType.Rule</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Script"><code class="name flex">
<span>def <span class="ident">Script</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>code: str) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Script(location: Location, name: str, code: str) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Script`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_script,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.new(&#34;char const[]&#34;, code.encode()),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Script" href="#clingo.ast.ASTType.Script">ASTType.Script</a></code>.</p></div>
</dd>
<dt id="clingo.ast.ShowSignature"><code class="name flex">
<span>def <span class="ident">ShowSignature</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>arity: int,<br>positive: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShowSignature(location: Location, name: str, arity: int, positive: int) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.ShowSignature`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_show_signature,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.cast(&#34;int&#34;, arity),
            _ffi.cast(&#34;int&#34;, positive),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ShowSignature" href="#clingo.ast.ASTType.ShowSignature">ASTType.ShowSignature</a></code>.</p></div>
</dd>
<dt id="clingo.ast.ShowTerm"><code class="name flex">
<span>def <span class="ident">ShowTerm</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>term: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>body: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShowTerm(location: Location, term: AST, body: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.ShowTerm`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_show_term,
            p_ast,
            c_location[0],
            term._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in body]),
            _ffi.cast(&#34;size_t&#34;, len(body)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.ShowTerm" href="#clingo.ast.ASTType.ShowTerm">ASTType.ShowTerm</a></code>.</p></div>
</dd>
<dt id="clingo.ast.SymbolicAtom"><code class="name flex">
<span>def <span class="ident">SymbolicAtom</span></span>(<span>symbol: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SymbolicAtom(symbol: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.SymbolicAtom`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(_lib.clingo_ast_type_symbolic_atom, p_ast, symbol._rep)
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.SymbolicAtom" href="#clingo.ast.ASTType.SymbolicAtom">ASTType.SymbolicAtom</a></code>.</p></div>
</dd>
<dt id="clingo.ast.SymbolicTerm"><code class="name flex">
<span>def <span class="ident">SymbolicTerm</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>symbol: <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SymbolicTerm(location: Location, symbol: Symbol) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.SymbolicTerm`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_symbolic_term,
            p_ast,
            c_location[0],
            _ffi.cast(&#34;clingo_symbol_t&#34;, symbol._rep),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.SymbolicTerm" href="#clingo.ast.ASTType.SymbolicTerm">ASTType.SymbolicTerm</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtom"><code class="name flex">
<span>def <span class="ident">TheoryAtom</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>term: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>elements: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryAtom(
    location: Location, term: AST, elements: Sequence[AST], guard: Optional[AST]
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryAtom`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_atom,
            p_ast,
            c_location[0],
            term._rep,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in elements]),
            _ffi.cast(&#34;size_t&#34;, len(elements)),
            _ffi.NULL if guard is None else guard._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryAtom" href="#clingo.ast.ASTType.TheoryAtom">ASTType.TheoryAtom</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomDefinition"><code class="name flex">
<span>def <span class="ident">TheoryAtomDefinition</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>atom_type: int,<br>name: str,<br>arity: int,<br>term: str,<br>guard: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | None) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryAtomDefinition(
    location: Location,
    atom_type: int,
    name: str,
    arity: int,
    term: str,
    guard: Optional[AST],
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryAtomDefinition`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_atom_definition,
            p_ast,
            c_location[0],
            _ffi.cast(&#34;int&#34;, atom_type),
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.cast(&#34;int&#34;, arity),
            _ffi.new(&#34;char const[]&#34;, term.encode()),
            _ffi.NULL if guard is None else guard._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryAtomDefinition" href="#clingo.ast.ASTType.TheoryAtomDefinition">ASTType.TheoryAtomDefinition</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomElement"><code class="name flex">
<span>def <span class="ident">TheoryAtomElement</span></span>(<span>terms: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>condition: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryAtomElement(terms: Sequence[AST], condition: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryAtomElement`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_atom_element,
            p_ast,
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in terms]),
            _ffi.cast(&#34;size_t&#34;, len(terms)),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in condition]),
            _ffi.cast(&#34;size_t&#34;, len(condition)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryAtomElement" href="#clingo.ast.ASTType.TheoryAtomElement">ASTType.TheoryAtomElement</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryDefinition"><code class="name flex">
<span>def <span class="ident">TheoryDefinition</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>terms: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>],<br>atoms: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryDefinition(
    location: Location, name: str, terms: Sequence[AST], atoms: Sequence[AST]
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryDefinition`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_definition,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in terms]),
            _ffi.cast(&#34;size_t&#34;, len(terms)),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in atoms]),
            _ffi.cast(&#34;size_t&#34;, len(atoms)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryDefinition" href="#clingo.ast.ASTType.TheoryDefinition">ASTType.TheoryDefinition</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryFunction"><code class="name flex">
<span>def <span class="ident">TheoryFunction</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>arguments: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryFunction(location: Location, name: str, arguments: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryFunction`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_function,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in arguments]),
            _ffi.cast(&#34;size_t&#34;, len(arguments)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryFunction" href="#clingo.ast.ASTType.TheoryFunction">ASTType.TheoryFunction</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryGuard"><code class="name flex">
<span>def <span class="ident">TheoryGuard</span></span>(<span>operator_name: str,<br>term: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryGuard(operator_name: str, term: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryGuard`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_guard,
            p_ast,
            _ffi.new(&#34;char const[]&#34;, operator_name.encode()),
            term._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryGuard" href="#clingo.ast.ASTType.TheoryGuard">ASTType.TheoryGuard</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryGuardDefinition"><code class="name flex">
<span>def <span class="ident">TheoryGuardDefinition</span></span>(<span>operators: Sequence[str], term: str) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryGuardDefinition(operators: Sequence[str], term: str) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryGuardDefinition`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_operators = [_ffi.new(&#34;char[]&#34;, x.encode()) for x in operators]
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_guard_definition,
            p_ast,
            _ffi.new(&#34;char*[]&#34;, c_operators),
            _ffi.cast(&#34;size_t&#34;, len(operators)),
            _ffi.new(&#34;char const[]&#34;, term.encode()),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryGuardDefinition" href="#clingo.ast.ASTType.TheoryGuardDefinition">ASTType.TheoryGuardDefinition</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryOperatorDefinition"><code class="name flex">
<span>def <span class="ident">TheoryOperatorDefinition</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>priority: int,<br>operator_type: int) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryOperatorDefinition(
    location: Location, name: str, priority: int, operator_type: int
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryOperatorDefinition`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_operator_definition,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.cast(&#34;int&#34;, priority),
            _ffi.cast(&#34;int&#34;, operator_type),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryOperatorDefinition" href="#clingo.ast.ASTType.TheoryOperatorDefinition">ASTType.TheoryOperatorDefinition</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheorySequence"><code class="name flex">
<span>def <span class="ident">TheorySequence</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>sequence_type: int,<br>terms: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheorySequence(location: Location, sequence_type: int, terms: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheorySequence`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_sequence,
            p_ast,
            c_location[0],
            _ffi.cast(&#34;int&#34;, sequence_type),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in terms]),
            _ffi.cast(&#34;size_t&#34;, len(terms)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheorySequence" href="#clingo.ast.ASTType.TheorySequence">ASTType.TheorySequence</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryTermDefinition"><code class="name flex">
<span>def <span class="ident">TheoryTermDefinition</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str,<br>operators: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryTermDefinition(
    location: Location, name: str, operators: Sequence[AST]
) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryTermDefinition`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_term_definition,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in operators]),
            _ffi.cast(&#34;size_t&#34;, len(operators)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryTermDefinition" href="#clingo.ast.ASTType.TheoryTermDefinition">ASTType.TheoryTermDefinition</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryUnparsedTerm"><code class="name flex">
<span>def <span class="ident">TheoryUnparsedTerm</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>elements: Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryUnparsedTerm(location: Location, elements: Sequence[AST]) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryUnparsedTerm`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_unparsed_term,
            p_ast,
            c_location[0],
            _ffi.new(&#34;clingo_ast_t*[]&#34;, [x._rep for x in elements]),
            _ffi.cast(&#34;size_t&#34;, len(elements)),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryUnparsedTerm" href="#clingo.ast.ASTType.TheoryUnparsedTerm">ASTType.TheoryUnparsedTerm</a></code>.</p></div>
</dd>
<dt id="clingo.ast.TheoryUnparsedTermElement"><code class="name flex">
<span>def <span class="ident">TheoryUnparsedTermElement</span></span>(<span>operators: Sequence[str],<br>term: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TheoryUnparsedTermElement(operators: Sequence[str], term: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.TheoryUnparsedTermElement`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_operators = [_ffi.new(&#34;char[]&#34;, x.encode()) for x in operators]
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_theory_unparsed_term_element,
            p_ast,
            _ffi.new(&#34;char*[]&#34;, c_operators),
            _ffi.cast(&#34;size_t&#34;, len(operators)),
            term._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.TheoryUnparsedTermElement" href="#clingo.ast.ASTType.TheoryUnparsedTermElement">ASTType.TheoryUnparsedTermElement</a></code>.</p></div>
</dd>
<dt id="clingo.ast.UnaryOperation"><code class="name flex">
<span>def <span class="ident">UnaryOperation</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>operator_type: int,<br>argument: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnaryOperation(location: Location, operator_type: int, argument: AST) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.UnaryOperation`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_unary_operation,
            p_ast,
            c_location[0],
            _ffi.cast(&#34;int&#34;, operator_type),
            argument._rep,
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.UnaryOperation" href="#clingo.ast.ASTType.UnaryOperation">ASTType.UnaryOperation</a></code>.</p></div>
</dd>
<dt id="clingo.ast.Variable"><code class="name flex">
<span>def <span class="ident">Variable</span></span>(<span>location: <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a>,<br>name: str) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Variable(location: Location, name: str) -&gt; AST:
    &#34;&#34;&#34;
    Construct an AST node of type `ASTType.Variable`.
    &#34;&#34;&#34;
    p_ast = _ffi.new(&#34;clingo_ast_t**&#34;)
    c_location = _c_location(location)
    _handle_error(
        _lib.clingo_ast_build(
            _lib.clingo_ast_type_variable,
            p_ast,
            c_location[0],
            _ffi.new(&#34;char const[]&#34;, name.encode()),
        )
    )
    return AST(p_ast[0])</code></pre>
</details>
<div class="desc"><p>Construct an AST node of type <code><a title="clingo.ast.ASTType.Variable" href="#clingo.ast.ASTType.Variable">ASTType.Variable</a></code>.</p></div>
</dd>
<dt id="clingo.ast.parse_files"><code class="name flex">
<span>def <span class="ident">parse_files</span></span>(<span>files: Sequence[str],<br>callback: Callable[[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], None],<br>control: <a title="clingo.control.Control" href="control.html#clingo.control.Control">Control</a> | None = None,<br>logger: Callable[[<a title="clingo.core.MessageCode" href="core.html#clingo.core.MessageCode">MessageCode</a>, str], None] | None = None,<br>message_limit: int = 20) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_files(
    files: Sequence[str],
    callback: Callable[[AST], None],
    control: Optional[Control] = None,
    logger: Optional[Logger] = None,
    message_limit: int = 20,
) -&gt; None:
    &#34;&#34;&#34;
    Parse the programs in the given files and return an abstract syntax tree for
    each statement via a callback.

    The function follows clingo&#39;s handling of files on the command line. Filename
    `&#34;-&#34;` is treated as stdin and if an empty list is given, then the parser will
    read from stdin.

    The optional control object can be added to enable parsing of files in
    ASPIF format. The ground statements will be added to the control object.

    Parameters
    ----------
    files
        List of file names.
    callback
        Callable taking an ast as argument.
    control
        Control object to add ground rules to.
    logger
        Function to intercept messages normally printed to standard error.
    message_limit
        The maximum number of messages passed to the logger.

    See Also
    --------
    ProgramBuilder
    &#34;&#34;&#34;
    c_control = control._rep if control is not None else _ffi.NULL

    if logger is not None:
        c_logger_data = _ffi.new_handle(logger)
        c_logger = _lib.pyclingo_logger_callback
    else:
        c_logger_data = _ffi.NULL
        c_logger = _ffi.NULL

    error = _Error()
    cb_data = _CBData(callback, error)
    c_cb_data = _ffi.new_handle(cb_data)

    _handle_error(
        _lib.clingo_ast_parse_files(
            [_ffi.new(&#34;char[]&#34;, f.encode()) for f in files],
            len(files),
            _lib.pyclingo_ast_callback,
            c_cb_data,
            c_control,
            c_logger,
            c_logger_data,
            message_limit,
        ),
        cb_data,
    )</code></pre>
</details>
<div class="desc"><p>Parse the programs in the given files and return an abstract syntax tree for
each statement via a callback.</p>
<p>The function follows clingo's handling of files on the command line. Filename
<code>"-"</code> is treated as stdin and if an empty list is given, then the parser will
read from stdin.</p>
<p>The optional control object can be added to enable parsing of files in
ASPIF format. The ground statements will be added to the control object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong></dt>
<dd>List of file names.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>Callable taking an ast as argument.</dd>
<dt><strong><code>control</code></strong></dt>
<dd>Control object to add ground rules to.</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Function to intercept messages normally printed to standard error.</dd>
<dt><strong><code>message_limit</code></strong></dt>
<dd>The maximum number of messages passed to the logger.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ast.ProgramBuilder" href="#clingo.ast.ProgramBuilder">ProgramBuilder</a></code></p></div>
</dd>
<dt id="clingo.ast.parse_string"><code class="name flex">
<span>def <span class="ident">parse_string</span></span>(<span>program: str,<br>callback: Callable[[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>], None],<br>control: <a title="clingo.control.Control" href="control.html#clingo.control.Control">Control</a> | None = None,<br>logger: Callable[[<a title="clingo.core.MessageCode" href="core.html#clingo.core.MessageCode">MessageCode</a>, str], None] | None = None,<br>message_limit: int = 20) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_string(
    program: str,
    callback: Callable[[AST], None],
    control: Optional[Control] = None,
    logger: Optional[Logger] = None,
    message_limit: int = 20,
) -&gt; None:
    &#34;&#34;&#34;
    Parse the given program and return an abstract syntax tree for each
    statement via a callback.

    The optional control object can be added to enable parsing of files in
    ASPIF format. The ground statements will be added to the control object.

    Parameters
    ----------
    program
        String representation of the program.
    callback
        Callable taking an ast as argument.
    control
        Control object to add ground rules to.
    logger
        Function to intercept messages normally printed to standard error.
    message_limit
        The maximum number of messages passed to the logger.

    See Also
    --------
    ProgramBuilder
    &#34;&#34;&#34;
    c_control = control._rep if control is not None else _ffi.NULL

    if logger is not None:
        c_logger_data = _ffi.new_handle(logger)
        c_logger = _lib.pyclingo_logger_callback
    else:
        c_logger_data = _ffi.NULL
        c_logger = _ffi.NULL

    error = _Error()
    cb_data = _CBData(callback, error)
    c_cb_data = _ffi.new_handle(cb_data)

    _handle_error(
        _lib.clingo_ast_parse_string(
            program.encode(),
            _lib.pyclingo_ast_callback,
            c_cb_data,
            c_control,
            c_logger,
            c_logger_data,
            message_limit,
        ),
        cb_data,
    )</code></pre>
</details>
<div class="desc"><p>Parse the given program and return an abstract syntax tree for each
statement via a callback.</p>
<p>The optional control object can be added to enable parsing of files in
ASPIF format. The ground statements will be added to the control object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>program</code></strong></dt>
<dd>String representation of the program.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>Callable taking an ast as argument.</dd>
<dt><strong><code>control</code></strong></dt>
<dd>Control object to add ground rules to.</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Function to intercept messages normally printed to standard error.</dd>
<dt><strong><code>message_limit</code></strong></dt>
<dd>The maximum number of messages passed to the logger.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ast.ProgramBuilder" href="#clingo.ast.ProgramBuilder">ProgramBuilder</a></code></p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingo.ast.AST"><code class="flex name class">
<span>class <span class="ident">AST</span></span>
<span>(</span><span>rep)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@total_ordering
class AST:
    &#34;&#34;&#34;
    Represents a node in the abstract syntax tree.

    The attributes of an `AST` are tied to its type. They correspond to the
    grammar in the description of the `clingo.ast` module. `AST` nodes can be
    constructed using one of the functions provided in this module.

    Furthermore, AST nodes implement Python&#39;s rich comparison operators and are
    ordered structurally ignoring the location. They can also be used as
    dictionary keys. Their string representation corresponds to their gringo
    representation. In fact, the string representation of any AST obtained from
    `parse_files` and `parse_string` can be parsed again. Note that it is
    possible to construct ASTs that are not parsable, though.
    &#34;&#34;&#34;

    def __init__(self, rep):
        super().__setattr__(&#34;_rep&#34;, rep)

    def __eq__(self, other):
        if not isinstance(other, AST):
            return NotImplemented
        return _lib.clingo_ast_equal(self._rep, other._rep)

    def __lt__(self, other):
        if not isinstance(other, AST):
            return NotImplemented
        return _lib.clingo_ast_less_than(self._rep, other._rep)

    def __hash__(self):
        return _lib.clingo_ast_hash(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __getattr__(self, name):
        attr_id = _attribute_names.get(name)
        if attr_id is None or not _c_call(
            &#34;bool&#34;, _lib.clingo_ast_has_attribute, self._rep, attr_id
        ):
            raise AttributeError(f&#34;no attribute: {name}&#34;)
        attr_type = _c_call(
            &#34;clingo_ast_attribute_type_t&#34;,
            _lib.clingo_ast_attribute_type,
            self._rep,
            attr_id,
        )
        if attr_type == _lib.clingo_ast_attribute_type_string:
            return _to_str(
                _c_call(
                    &#34;char*&#34;, _lib.clingo_ast_attribute_get_string, self._rep, attr_id
                )
            )
        if attr_type == _lib.clingo_ast_attribute_type_number:
            return _c_call(
                &#34;int&#34;, _lib.clingo_ast_attribute_get_number, self._rep, attr_id
            )
        if attr_type == _lib.clingo_ast_attribute_type_symbol:
            return Symbol(
                _c_call(
                    &#34;clingo_symbol_t&#34;,
                    _lib.clingo_ast_attribute_get_symbol,
                    self._rep,
                    attr_id,
                )
            )
        if attr_type == _lib.clingo_ast_attribute_type_location:
            return _py_location(
                _c_call(
                    &#34;clingo_location_t&#34;,
                    _lib.clingo_ast_attribute_get_location,
                    self._rep,
                    attr_id,
                )
            )
        if attr_type == _lib.clingo_ast_attribute_type_optional_ast:
            rep = _c_call(
                &#34;clingo_ast_t*&#34;,
                _lib.clingo_ast_attribute_get_optional_ast,
                self._rep,
                attr_id,
            )
            return AST(rep) if rep != _ffi.NULL else None
        if attr_type == _lib.clingo_ast_attribute_type_ast:
            return AST(
                _c_call(
                    &#34;clingo_ast_t*&#34;,
                    _lib.clingo_ast_attribute_get_ast,
                    self._rep,
                    attr_id,
                )
            )
        if attr_type == _lib.clingo_ast_attribute_type_string_array:
            return StrSequence(self._rep, attr_id)
        assert attr_type == _lib.clingo_ast_attribute_type_ast_array
        return ASTSequence(self._rep, attr_id)

    def __setattr__(self, name, value):
        attr_id = getattr(_lib, f&#34;clingo_ast_attribute_{name}&#34;)
        if not _c_call(&#34;bool&#34;, _lib.clingo_ast_has_attribute, self._rep, attr_id):
            raise AttributeError(f&#34;no attribute: {name}&#34;)
        attr_type = _c_call(
            &#34;clingo_ast_attribute_type_t&#34;,
            _lib.clingo_ast_attribute_type,
            self._rep,
            attr_id,
        )
        if attr_type == _lib.clingo_ast_attribute_type_string:
            _handle_error(
                _lib.clingo_ast_attribute_set_string(self._rep, attr_id, value.encode())
            )
        elif attr_type == _lib.clingo_ast_attribute_type_number:
            _handle_error(
                _lib.clingo_ast_attribute_set_number(self._rep, attr_id, value)
            )
        elif attr_type == _lib.clingo_ast_attribute_type_symbol:
            _handle_error(
                _lib.clingo_ast_attribute_set_symbol(self._rep, attr_id, value._rep)
            )
        elif attr_type == _lib.clingo_ast_attribute_type_location:
            c_loc = _c_location(value)
            _handle_error(
                _lib.clingo_ast_attribute_set_location(self._rep, attr_id, c_loc[0])
            )
        elif attr_type == _lib.clingo_ast_attribute_type_optional_ast:
            _handle_error(
                _lib.clingo_ast_attribute_set_optional_ast(
                    self._rep, attr_id, _ffi.NULL if value is None else value._rep
                )
            )
        elif attr_type == _lib.clingo_ast_attribute_type_ast:
            _handle_error(
                _lib.clingo_ast_attribute_set_ast(self._rep, attr_id, value._rep)
            )
        elif attr_type == _lib.clingo_ast_attribute_type_string_array:
            if isinstance(value, StrSequence):
                if attr_id == value._attribute and self._rep == value._rep:
                    value = list(value)
            elif not isinstance(value, list):
                value = list(value)
            str_seq = StrSequence(self._rep, attr_id)
            str_seq.clear()
            str_seq.extend(value)
        else:
            assert attr_type == _lib.clingo_ast_attribute_type_ast_array
            if isinstance(value, ASTSequence):
                if attr_id == value._attribute and self._rep == value._rep:
                    value = list(value)
            elif not isinstance(value, list):
                value = list(value)
            ast_seq = ASTSequence(self._rep, attr_id)
            ast_seq.clear()
            ast_seq.extend(value)

    def __str__(self):
        return _str(
            _lib.clingo_ast_to_string_size, _lib.clingo_ast_to_string, self._rep
        )

    def __repr__(self):
        name = str(self.ast_type).replace(&#34;ASTType&#34;, &#34;ast&#34;)
        args = &#34;, &#34;.join(repr(x) for x in self.values())
        return f&#34;{name}({args})&#34;

    def __copy__(self) -&gt; &#34;AST&#34;:
        &#34;&#34;&#34;
        Return a shallow copy of the ast.
        &#34;&#34;&#34;
        return AST(_c_call(&#34;clingo_ast_t*&#34;, _lib.clingo_ast_copy, self._rep))

    def __deepcopy__(self, memo) -&gt; &#34;AST&#34;:
        &#34;&#34;&#34;
        Return a deep copy of the ast.
        &#34;&#34;&#34;
        return AST(_c_call(&#34;clingo_ast_t*&#34;, _lib.clingo_ast_deep_copy, self._rep))

    def update(self, **kwargs: ASTUpdate) -&gt; &#34;AST&#34;:
        &#34;&#34;&#34;
        Return a copy of the AST also updating the given attributes.

        Note that this function returns a reference to self if no arguments are
        given.
        &#34;&#34;&#34;
        if not kwargs:
            return self

        args = []
        for key in self.keys():
            if key in kwargs:
                args.append(kwargs[key])
            else:
                args.append(getattr(self, key))

        cons = globals()[str(self.ast_type).replace(&#34;ASTType.&#34;, &#34;&#34;)]
        return cons(*args)

    def items(self) -&gt; List[Tuple[str, ASTValue]]:
        &#34;&#34;&#34;
        The list of items of the AST node.
        &#34;&#34;&#34;
        return [(name, getattr(self, name)) for name in self.keys()]

    def keys(self) -&gt; List[str]:
        &#34;&#34;&#34;
        The list of keys of the AST node.
        &#34;&#34;&#34;
        cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
        names = _lib.g_clingo_ast_attribute_names.names
        return [_to_str(names[cons.arguments[j].attribute]) for j in range(cons.size)]

    def values(self) -&gt; List[ASTValue]:
        &#34;&#34;&#34;
        The list of values of the AST node.
        &#34;&#34;&#34;
        return [(getattr(self, name)) for name in self.keys()]

    @property
    def ast_type(self) -&gt; ASTType:
        &#34;&#34;&#34;
        The type of the node.
        &#34;&#34;&#34;
        return ASTType(
            _c_call(&#34;clingo_ast_type_t&#34;, _lib.clingo_ast_get_type, self._rep)
        )

    @property
    def child_keys(self) -&gt; List[str]:
        &#34;&#34;&#34;
        List of attribute names containing ASTs.
        &#34;&#34;&#34;
        cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
        names = _lib.g_clingo_ast_attribute_names.names
        return [
            _to_str(names[cons.arguments[j].attribute])
            for j in range(cons.size)
            if cons.arguments[j].type
            in (
                _lib.clingo_ast_attribute_type_ast,
                _lib.clingo_ast_attribute_type_optional_ast,
                _lib.clingo_ast_attribute_type_ast_array,
            )
        ]

    def unpool(self, other: bool = True, condition: bool = True) -&gt; List[&#34;AST&#34;]:
        &#34;&#34;&#34;
        Unpool the AST returning a list of ASTs without pool terms.

        Parameters
        ----------
        other
            Remove all pools except those in conditions of conditional
            literals.
        condition
            Only remove pools from conditions of conditional literals.
        &#34;&#34;&#34;
        unpool_type = 0
        if other:
            unpool_type |= _lib.clingo_ast_unpool_type_other
        if condition:
            unpool_type |= _lib.clingo_ast_unpool_type_condition

        ret: List[AST] = []
        error = _Error()
        cb_data = _CBData(ret.append, error)
        c_cb_data = _ffi.new_handle(cb_data)
        _handle_error(
            _lib.clingo_ast_unpool(
                self._rep, unpool_type, _lib.pyclingo_ast_callback, c_cb_data
            )
        )
        return ret</code></pre>
</details>
<div class="desc"><p>Represents a node in the abstract syntax tree.</p>
<p>The attributes of an <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> are tied to its type. They correspond to the
grammar in the description of the <code><a title="clingo.ast" href="#clingo.ast">clingo.ast</a></code> module. <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> nodes can be
constructed using one of the functions provided in this module.</p>
<p>Furthermore, AST nodes implement Python's rich comparison operators and are
ordered structurally ignoring the location. They can also be used as
dictionary keys. Their string representation corresponds to their gringo
representation. In fact, the string representation of any AST obtained from
<code><a title="clingo.ast.parse_files" href="#clingo.ast.parse_files">parse_files()</a></code> and <code><a title="clingo.ast.parse_string" href="#clingo.ast.parse_string">parse_string()</a></code> can be parsed again. Note that it is
possible to construct ASTs that are not parsable, though.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.ast.AST.ast_type"><code class="name">prop <span class="ident">ast_type</span> : <a title="clingo.ast.ASTType" href="#clingo.ast.ASTType">ASTType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ast_type(self) -&gt; ASTType:
    &#34;&#34;&#34;
    The type of the node.
    &#34;&#34;&#34;
    return ASTType(
        _c_call(&#34;clingo_ast_type_t&#34;, _lib.clingo_ast_get_type, self._rep)
    )</code></pre>
</details>
<div class="desc"><p>The type of the node.</p></div>
</dd>
<dt id="clingo.ast.AST.child_keys"><code class="name">prop <span class="ident">child_keys</span> : List[str]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def child_keys(self) -&gt; List[str]:
    &#34;&#34;&#34;
    List of attribute names containing ASTs.
    &#34;&#34;&#34;
    cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
    names = _lib.g_clingo_ast_attribute_names.names
    return [
        _to_str(names[cons.arguments[j].attribute])
        for j in range(cons.size)
        if cons.arguments[j].type
        in (
            _lib.clingo_ast_attribute_type_ast,
            _lib.clingo_ast_attribute_type_optional_ast,
            _lib.clingo_ast_attribute_type_ast_array,
        )
    ]</code></pre>
</details>
<div class="desc"><p>List of attribute names containing ASTs.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.AST.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self) ‑> List[Tuple[str, str | int | <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a> | <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a> | <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | <a title="clingo.ast.StrSequence" href="#clingo.ast.StrSequence">StrSequence</a> | <a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a> | None]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self) -&gt; List[Tuple[str, ASTValue]]:
    &#34;&#34;&#34;
    The list of items of the AST node.
    &#34;&#34;&#34;
    return [(name, getattr(self, name)) for name in self.keys()]</code></pre>
</details>
<div class="desc"><p>The list of items of the AST node.</p></div>
</dd>
<dt id="clingo.ast.AST.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self) -&gt; List[str]:
    &#34;&#34;&#34;
    The list of keys of the AST node.
    &#34;&#34;&#34;
    cons = _lib.g_clingo_ast_constructors.constructors[self.ast_type.value]
    names = _lib.g_clingo_ast_attribute_names.names
    return [_to_str(names[cons.arguments[j].attribute]) for j in range(cons.size)]</code></pre>
</details>
<div class="desc"><p>The list of keys of the AST node.</p></div>
</dd>
<dt id="clingo.ast.AST.unpool"><code class="name flex">
<span>def <span class="ident">unpool</span></span>(<span>self, other: bool = True, condition: bool = True) ‑> List[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpool(self, other: bool = True, condition: bool = True) -&gt; List[&#34;AST&#34;]:
    &#34;&#34;&#34;
    Unpool the AST returning a list of ASTs without pool terms.

    Parameters
    ----------
    other
        Remove all pools except those in conditions of conditional
        literals.
    condition
        Only remove pools from conditions of conditional literals.
    &#34;&#34;&#34;
    unpool_type = 0
    if other:
        unpool_type |= _lib.clingo_ast_unpool_type_other
    if condition:
        unpool_type |= _lib.clingo_ast_unpool_type_condition

    ret: List[AST] = []
    error = _Error()
    cb_data = _CBData(ret.append, error)
    c_cb_data = _ffi.new_handle(cb_data)
    _handle_error(
        _lib.clingo_ast_unpool(
            self._rep, unpool_type, _lib.pyclingo_ast_callback, c_cb_data
        )
    )
    return ret</code></pre>
</details>
<div class="desc"><p>Unpool the AST returning a list of ASTs without pool terms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>Remove all pools except those in conditions of conditional
literals.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Only remove pools from conditions of conditional literals.</dd>
</dl></div>
</dd>
<dt id="clingo.ast.AST.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self,<br>**kwargs: str | int | <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a> | <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a> | ForwardRef('<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>') | Sequence[str] | Sequence[ForwardRef('<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>')] | None) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs: ASTUpdate) -&gt; &#34;AST&#34;:
    &#34;&#34;&#34;
    Return a copy of the AST also updating the given attributes.

    Note that this function returns a reference to self if no arguments are
    given.
    &#34;&#34;&#34;
    if not kwargs:
        return self

    args = []
    for key in self.keys():
        if key in kwargs:
            args.append(kwargs[key])
        else:
            args.append(getattr(self, key))

    cons = globals()[str(self.ast_type).replace(&#34;ASTType.&#34;, &#34;&#34;)]
    return cons(*args)</code></pre>
</details>
<div class="desc"><p>Return a copy of the AST also updating the given attributes.</p>
<p>Note that this function returns a reference to self if no arguments are
given.</p></div>
</dd>
<dt id="clingo.ast.AST.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self) ‑> List[str | int | <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a> | <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a> | <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | <a title="clingo.ast.StrSequence" href="#clingo.ast.StrSequence">StrSequence</a> | <a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a> | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self) -&gt; List[ASTValue]:
    &#34;&#34;&#34;
    The list of values of the AST node.
    &#34;&#34;&#34;
    return [(getattr(self, name)) for name in self.keys()]</code></pre>
</details>
<div class="desc"><p>The list of values of the AST node.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ASTSequence"><code class="flex name class">
<span>class <span class="ident">ASTSequence</span></span>
<span>(</span><span>rep, attribute)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ASTSequence(abc.MutableSequence):
    &#34;&#34;&#34;
    A sequence holding `AST` nodes.

    Sequences implement Python&#39;s rich comparison operators and are ordered
    structurally ignoring the location. They can also be used as dictionary
    keys.
    &#34;&#34;&#34;

    def __init__(self, rep, attribute):
        self._rep = rep
        self._attribute = attribute
        _lib.clingo_ast_acquire(self._rep)

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __lt__(self, other):
        return tuple(self) &lt; tuple(other)

    def __hash__(self):
        return hash(tuple(self))

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __len__(self) -&gt; int:
        return _c_call(
            &#34;size_t&#34;,
            _lib.clingo_ast_attribute_size_ast_array,
            self._rep,
            self._attribute,
        )

    def __getitem__(self, index):
        if isinstance(index, slice):
            return SlicedMutableSequence(self, Slice(index))
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#34;invalid index&#34;)
        return AST(
            _c_call(
                &#34;clingo_ast_t*&#34;,
                _lib.clingo_ast_attribute_get_ast_at,
                self._rep,
                self._attribute,
                index,
            )
        )

    def __iter__(self):
        for index in range(len(self)):
            yield AST(
                _c_call(
                    &#34;clingo_ast_t*&#34;,
                    _lib.clingo_ast_attribute_get_ast_at,
                    self._rep,
                    self._attribute,
                    index,
                )
            )

    def __setitem__(self, index, ast):
        if isinstance(index, slice):
            raise TypeError(&#34;slicing not implemented&#34;)
        _handle_error(
            _lib.clingo_ast_attribute_set_ast_at(
                self._rep, self._attribute, index, ast._rep
            )
        )

    def __delitem__(self, index):
        if isinstance(index, slice):
            raise TypeError(&#34;slicing not implemented&#34;)
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#34;invalid index&#34;)
        _handle_error(
            _lib.clingo_ast_attribute_delete_ast_at(self._rep, self._attribute, index)
        )

    def insert(self, index, value):
        _handle_error(
            _lib.clingo_ast_attribute_insert_ast_at(
                self._rep, self._attribute, index, value._rep
            )
        )

    def clear(self):
        &#34;&#34;&#34;
        Remove all elements from the sequence.
        &#34;&#34;&#34;
        for i in range(len(self), 0, -1):
            del self[i - 1]

    def __str__(self):
        return str(list(self))

    def __repr__(self):
        return repr(list(self))</code></pre>
</details>
<div class="desc"><p>A sequence holding <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> nodes.</p>
<p>Sequences implement Python's rich comparison operators and are ordered
structurally ignoring the location. They can also be used as dictionary
keys.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.ASTSequence.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Remove all elements from the sequence.
    &#34;&#34;&#34;
    for i in range(len(self), 0, -1):
        del self[i - 1]</code></pre>
</details>
<div class="desc"><p>Remove all elements from the sequence.</p></div>
</dd>
<dt id="clingo.ast.ASTSequence.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, index, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, index, value):
    _handle_error(
        _lib.clingo_ast_attribute_insert_ast_at(
            self._rep, self._attribute, index, value._rep
        )
    )</code></pre>
</details>
<div class="desc"><p>S.insert(index, value) &ndash; insert value before index</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ASTType"><code class="flex name class">
<span>class <span class="ident">ASTType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ASTType(OrderedEnum):
    &#34;&#34;&#34;
    Enumeration of ast node types.
    &#34;&#34;&#34;

    Id = _lib.clingo_ast_type_id
    Variable = _lib.clingo_ast_type_variable
    SymbolicTerm = _lib.clingo_ast_type_symbolic_term
    UnaryOperation = _lib.clingo_ast_type_unary_operation
    BinaryOperation = _lib.clingo_ast_type_binary_operation
    Interval = _lib.clingo_ast_type_interval
    Function = _lib.clingo_ast_type_function
    Pool = _lib.clingo_ast_type_pool
    BooleanConstant = _lib.clingo_ast_type_boolean_constant
    SymbolicAtom = _lib.clingo_ast_type_symbolic_atom
    Comparison = _lib.clingo_ast_type_comparison
    Guard = _lib.clingo_ast_type_guard
    ConditionalLiteral = _lib.clingo_ast_type_conditional_literal
    Aggregate = _lib.clingo_ast_type_aggregate
    BodyAggregateElement = _lib.clingo_ast_type_body_aggregate_element
    BodyAggregate = _lib.clingo_ast_type_body_aggregate
    HeadAggregateElement = _lib.clingo_ast_type_head_aggregate_element
    HeadAggregate = _lib.clingo_ast_type_head_aggregate
    Disjunction = _lib.clingo_ast_type_disjunction
    TheorySequence = _lib.clingo_ast_type_theory_sequence
    TheoryFunction = _lib.clingo_ast_type_theory_function
    TheoryUnparsedTermElement = _lib.clingo_ast_type_theory_unparsed_term_element
    TheoryUnparsedTerm = _lib.clingo_ast_type_theory_unparsed_term
    TheoryGuard = _lib.clingo_ast_type_theory_guard
    TheoryAtomElement = _lib.clingo_ast_type_theory_atom_element
    TheoryAtom = _lib.clingo_ast_type_theory_atom
    Literal = _lib.clingo_ast_type_literal
    TheoryOperatorDefinition = _lib.clingo_ast_type_theory_operator_definition
    TheoryTermDefinition = _lib.clingo_ast_type_theory_term_definition
    TheoryGuardDefinition = _lib.clingo_ast_type_theory_guard_definition
    TheoryAtomDefinition = _lib.clingo_ast_type_theory_atom_definition
    Rule = _lib.clingo_ast_type_rule
    Definition = _lib.clingo_ast_type_definition
    ShowSignature = _lib.clingo_ast_type_show_signature
    ShowTerm = _lib.clingo_ast_type_show_term
    Minimize = _lib.clingo_ast_type_minimize
    Script = _lib.clingo_ast_type_script
    Program = _lib.clingo_ast_type_program
    External = _lib.clingo_ast_type_external
    Edge = _lib.clingo_ast_type_edge
    Heuristic = _lib.clingo_ast_type_heuristic
    ProjectAtom = _lib.clingo_ast_type_project_atom
    ProjectSignature = _lib.clingo_ast_type_project_signature
    Defined = _lib.clingo_ast_type_defined
    TheoryDefinition = _lib.clingo_ast_type_theory_definition
    Comment = _lib.clingo_ast_type_comment</code></pre>
</details>
<div class="desc"><p>Enumeration of ast node types.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clingo.core.OrderedEnum" href="core.html#clingo.core.OrderedEnum">OrderedEnum</a></li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.ASTType.Aggregate"><code class="name">var <span class="ident">Aggregate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BinaryOperation"><code class="name">var <span class="ident">BinaryOperation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BodyAggregate"><code class="name">var <span class="ident">BodyAggregate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BodyAggregateElement"><code class="name">var <span class="ident">BodyAggregateElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.BooleanConstant"><code class="name">var <span class="ident">BooleanConstant</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Comment"><code class="name">var <span class="ident">Comment</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Comparison"><code class="name">var <span class="ident">Comparison</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ConditionalLiteral"><code class="name">var <span class="ident">ConditionalLiteral</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Defined"><code class="name">var <span class="ident">Defined</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Definition"><code class="name">var <span class="ident">Definition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Disjunction"><code class="name">var <span class="ident">Disjunction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Edge"><code class="name">var <span class="ident">Edge</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.External"><code class="name">var <span class="ident">External</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Function"><code class="name">var <span class="ident">Function</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Guard"><code class="name">var <span class="ident">Guard</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.HeadAggregate"><code class="name">var <span class="ident">HeadAggregate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.HeadAggregateElement"><code class="name">var <span class="ident">HeadAggregateElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Heuristic"><code class="name">var <span class="ident">Heuristic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Id"><code class="name">var <span class="ident">Id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Interval"><code class="name">var <span class="ident">Interval</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Literal"><code class="name">var <span class="ident">Literal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Minimize"><code class="name">var <span class="ident">Minimize</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Pool"><code class="name">var <span class="ident">Pool</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Program"><code class="name">var <span class="ident">Program</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ProjectAtom"><code class="name">var <span class="ident">ProjectAtom</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ProjectSignature"><code class="name">var <span class="ident">ProjectSignature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Rule"><code class="name">var <span class="ident">Rule</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Script"><code class="name">var <span class="ident">Script</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ShowSignature"><code class="name">var <span class="ident">ShowSignature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.ShowTerm"><code class="name">var <span class="ident">ShowTerm</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.SymbolicAtom"><code class="name">var <span class="ident">SymbolicAtom</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.SymbolicTerm"><code class="name">var <span class="ident">SymbolicTerm</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryAtom"><code class="name">var <span class="ident">TheoryAtom</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryAtomDefinition"><code class="name">var <span class="ident">TheoryAtomDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryAtomElement"><code class="name">var <span class="ident">TheoryAtomElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryDefinition"><code class="name">var <span class="ident">TheoryDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryFunction"><code class="name">var <span class="ident">TheoryFunction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryGuard"><code class="name">var <span class="ident">TheoryGuard</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryGuardDefinition"><code class="name">var <span class="ident">TheoryGuardDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryOperatorDefinition"><code class="name">var <span class="ident">TheoryOperatorDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheorySequence"><code class="name">var <span class="ident">TheorySequence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryTermDefinition"><code class="name">var <span class="ident">TheoryTermDefinition</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryUnparsedTerm"><code class="name">var <span class="ident">TheoryUnparsedTerm</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.TheoryUnparsedTermElement"><code class="name">var <span class="ident">TheoryUnparsedTermElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.UnaryOperation"><code class="name">var <span class="ident">UnaryOperation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clingo.ast.ASTType.Variable"><code class="name">var <span class="ident">Variable</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.AggregateFunction"><code class="flex name class">
<span>class <span class="ident">AggregateFunction</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AggregateFunction(IntEnum):
    &#34;&#34;&#34;
    Enumeration of aggegate functions.
    &#34;&#34;&#34;

    Count = _lib.clingo_ast_aggregate_function_count
    &#34;&#34;&#34;
    The `#count` function.
    &#34;&#34;&#34;
    Max = _lib.clingo_ast_aggregate_function_max
    &#34;&#34;&#34;
    The `#max` function.
    &#34;&#34;&#34;
    Min = _lib.clingo_ast_aggregate_function_min
    &#34;&#34;&#34;
    The `#min` function.
    &#34;&#34;&#34;
    Sum = _lib.clingo_ast_aggregate_function_sum
    &#34;&#34;&#34;
    The `#sum` function.
    &#34;&#34;&#34;
    SumPlus = _lib.clingo_ast_aggregate_function_sump
    &#34;&#34;&#34;
    The `#sum+` function.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of aggegate functions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.AggregateFunction.Count"><code class="name">var <span class="ident">Count</span></code></dt>
<dd>
<div class="desc"><p>The <code>#count</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.Max"><code class="name">var <span class="ident">Max</span></code></dt>
<dd>
<div class="desc"><p>The <code>#max</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.Min"><code class="name">var <span class="ident">Min</span></code></dt>
<dd>
<div class="desc"><p>The <code>#min</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.Sum"><code class="name">var <span class="ident">Sum</span></code></dt>
<dd>
<div class="desc"><p>The <code>#sum</code> function.</p></div>
</dd>
<dt id="clingo.ast.AggregateFunction.SumPlus"><code class="name">var <span class="ident">SumPlus</span></code></dt>
<dd>
<div class="desc"><p>The <code>#sum+</code> function.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.BinaryOperator"><code class="flex name class">
<span>class <span class="ident">BinaryOperator</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryOperator(IntEnum):
    &#34;&#34;&#34;
    Enumeration of binary operators.
    &#34;&#34;&#34;

    And = _lib.clingo_ast_binary_operator_and
    &#34;&#34;&#34;
    For bitwise and.
    &#34;&#34;&#34;
    Division = _lib.clingo_ast_binary_operator_division
    &#34;&#34;&#34;
    For arithmetic division.
    &#34;&#34;&#34;
    Minus = _lib.clingo_ast_binary_operator_minus
    &#34;&#34;&#34;
    For arithmetic subtraction.
    &#34;&#34;&#34;
    Modulo = _lib.clingo_ast_binary_operator_modulo
    &#34;&#34;&#34;
    For arithmetic modulo.
    &#34;&#34;&#34;
    Multiplication = _lib.clingo_ast_binary_operator_multiplication
    &#34;&#34;&#34;
    For arithmetic multipilcation.
    &#34;&#34;&#34;
    Or = _lib.clingo_ast_binary_operator_or
    &#34;&#34;&#34;
    For bitwise or.
    &#34;&#34;&#34;
    Plus = _lib.clingo_ast_binary_operator_plus
    &#34;&#34;&#34;
    For arithmetic addition.
    &#34;&#34;&#34;
    Power = _lib.clingo_ast_binary_operator_power
    &#34;&#34;&#34;
    For arithmetic exponentiation.
    &#34;&#34;&#34;
    XOr = _lib.clingo_ast_binary_operator_xor
    &#34;&#34;&#34;
    For bitwise exclusive or.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of binary operators.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.BinaryOperator.And"><code class="name">var <span class="ident">And</span></code></dt>
<dd>
<div class="desc"><p>For bitwise and.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Division"><code class="name">var <span class="ident">Division</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic division.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Minus"><code class="name">var <span class="ident">Minus</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic subtraction.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Modulo"><code class="name">var <span class="ident">Modulo</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic modulo.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Multiplication"><code class="name">var <span class="ident">Multiplication</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic multipilcation.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Or"><code class="name">var <span class="ident">Or</span></code></dt>
<dd>
<div class="desc"><p>For bitwise or.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Plus"><code class="name">var <span class="ident">Plus</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic addition.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.Power"><code class="name">var <span class="ident">Power</span></code></dt>
<dd>
<div class="desc"><p>For arithmetic exponentiation.</p></div>
</dd>
<dt id="clingo.ast.BinaryOperator.XOr"><code class="name">var <span class="ident">XOr</span></code></dt>
<dd>
<div class="desc"><p>For bitwise exclusive or.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.CommentType"><code class="flex name class">
<span>class <span class="ident">CommentType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommentType(IntEnum):
    &#34;&#34;&#34;
    Enumeration of comment types.
    &#34;&#34;&#34;

    Line = _lib.clingo_comment_type_line
    &#34;&#34;&#34;
    Line comments starting with `%` ending at a newline.
    &#34;&#34;&#34;
    Block = _lib.clingo_comment_type_block
    &#34;&#34;&#34;
    Block comments enclosed in `%*` and  `*%`.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of comment types.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.CommentType.Block"><code class="name">var <span class="ident">Block</span></code></dt>
<dd>
<div class="desc"><p>Block comments enclosed in <code>%*</code> and
<code>*%</code>.</p></div>
</dd>
<dt id="clingo.ast.CommentType.Line"><code class="name">var <span class="ident">Line</span></code></dt>
<dd>
<div class="desc"><p>Line comments starting with <code>%</code> ending at a newline.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ComparisonOperator"><code class="flex name class">
<span>class <span class="ident">ComparisonOperator</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComparisonOperator(IntEnum):
    &#34;&#34;&#34;
    Enumeration of comparison operators.
    &#34;&#34;&#34;

    Equal = _lib.clingo_ast_comparison_operator_equal
    &#34;&#34;&#34;
    The `=` operator
    &#34;&#34;&#34;
    GreaterEqual = _lib.clingo_ast_comparison_operator_greater_equal
    &#34;&#34;&#34;
    The `&gt;=` operator.
    &#34;&#34;&#34;
    GreaterThan = _lib.clingo_ast_comparison_operator_greater_than
    &#34;&#34;&#34;
    The `&gt;` operator.
    &#34;&#34;&#34;
    LessEqual = _lib.clingo_ast_comparison_operator_less_equal
    &#34;&#34;&#34;
    The `&lt;=` operator.
    &#34;&#34;&#34;
    LessThan = _lib.clingo_ast_comparison_operator_less_than
    &#34;&#34;&#34;
    The `&lt;` operator.
    &#34;&#34;&#34;
    NotEqual = _lib.clingo_ast_comparison_operator_not_equal
    &#34;&#34;&#34;
    The `!=` operator.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of comparison operators.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.ComparisonOperator.Equal"><code class="name">var <span class="ident">Equal</span></code></dt>
<dd>
<div class="desc"><p>The <code>=</code> operator</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.GreaterEqual"><code class="name">var <span class="ident">GreaterEqual</span></code></dt>
<dd>
<div class="desc"><p>The <code>&gt;=</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.GreaterThan"><code class="name">var <span class="ident">GreaterThan</span></code></dt>
<dd>
<div class="desc"><p>The <code>&gt;</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.LessEqual"><code class="name">var <span class="ident">LessEqual</span></code></dt>
<dd>
<div class="desc"><p>The <code>&lt;=</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.LessThan"><code class="name">var <span class="ident">LessThan</span></code></dt>
<dd>
<div class="desc"><p>The <code>&lt;</code> operator.</p></div>
</dd>
<dt id="clingo.ast.ComparisonOperator.NotEqual"><code class="name">var <span class="ident">NotEqual</span></code></dt>
<dd>
<div class="desc"><p>The <code>!=</code> operator.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>begin: <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a>,<br>end: <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#34;&#34;&#34;
    Class to point to a range in a text file.
    &#34;&#34;&#34;

    begin: Position
    &#34;&#34;&#34;
    The beginning of the range.
    &#34;&#34;&#34;
    end: Position
    &#34;&#34;&#34;
    The end of the range.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Class to point to a range in a text file.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.ast.Location.begin"><code class="name">var <span class="ident">begin</span> : <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#34;&#34;&#34;
    Class to point to a range in a text file.
    &#34;&#34;&#34;

    begin: Position
    &#34;&#34;&#34;
    The beginning of the range.
    &#34;&#34;&#34;
    end: Position
    &#34;&#34;&#34;
    The end of the range.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>The beginning of the range.</p></div>
</dd>
<dt id="clingo.ast.Location.end"><code class="name">var <span class="ident">end</span> : <a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location(NamedTuple):
    &#34;&#34;&#34;
    Class to point to a range in a text file.
    &#34;&#34;&#34;

    begin: Position
    &#34;&#34;&#34;
    The beginning of the range.
    &#34;&#34;&#34;
    end: Position
    &#34;&#34;&#34;
    The end of the range.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>The end of the range.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Position"><code class="flex name class">
<span>class <span class="ident">Position</span></span>
<span>(</span><span>filename: str, line: int, column: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position(NamedTuple):
    &#34;&#34;&#34;
    Class to point to a position in a text file.
    &#34;&#34;&#34;

    filename: str
    &#34;&#34;&#34;
    The file name.
    &#34;&#34;&#34;
    line: int
    &#34;&#34;&#34;
    The line number in the file.
    &#34;&#34;&#34;
    column: int
    &#34;&#34;&#34;
    The column number in the line.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Class to point to a position in a text file.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingo.ast.Position.column"><code class="name">var <span class="ident">column</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position(NamedTuple):
    &#34;&#34;&#34;
    Class to point to a position in a text file.
    &#34;&#34;&#34;

    filename: str
    &#34;&#34;&#34;
    The file name.
    &#34;&#34;&#34;
    line: int
    &#34;&#34;&#34;
    The line number in the file.
    &#34;&#34;&#34;
    column: int
    &#34;&#34;&#34;
    The column number in the line.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>The column number in the line.</p></div>
</dd>
<dt id="clingo.ast.Position.filename"><code class="name">var <span class="ident">filename</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position(NamedTuple):
    &#34;&#34;&#34;
    Class to point to a position in a text file.
    &#34;&#34;&#34;

    filename: str
    &#34;&#34;&#34;
    The file name.
    &#34;&#34;&#34;
    line: int
    &#34;&#34;&#34;
    The line number in the file.
    &#34;&#34;&#34;
    column: int
    &#34;&#34;&#34;
    The column number in the line.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>The file name.</p></div>
</dd>
<dt id="clingo.ast.Position.line"><code class="name">var <span class="ident">line</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position(NamedTuple):
    &#34;&#34;&#34;
    Class to point to a position in a text file.
    &#34;&#34;&#34;

    filename: str
    &#34;&#34;&#34;
    The file name.
    &#34;&#34;&#34;
    line: int
    &#34;&#34;&#34;
    The line number in the file.
    &#34;&#34;&#34;
    column: int
    &#34;&#34;&#34;
    The column number in the line.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>The line number in the file.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.ProgramBuilder"><code class="flex name class">
<span>class <span class="ident">ProgramBuilder</span></span>
<span>(</span><span>control: <a title="clingo.control.Control" href="control.html#clingo.control.Control">Control</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgramBuilder(ContextManager[&#34;ProgramBuilder&#34;]):
    &#34;&#34;&#34;
    Object to build non-ground programs.

    Parameters
    ----------
    control
        The `clingo.control.Control` object to attach the builder to.

    See Also
    --------
    parse_string, parse_files

    Notes
    -----
    This class is a context manager and must be used with Python&#39;s `with`
    statement.
    &#34;&#34;&#34;

    def __init__(self, control: Control):
        self._rep = _c_call(
            &#34;clingo_program_builder_t*&#34;, _lib.clingo_program_builder_init, control._rep
        )

    def __enter__(self):
        _handle_error(_lib.clingo_program_builder_begin(self._rep))
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        _handle_error(_lib.clingo_program_builder_end(self._rep))
        return False

    def add(self, statement: AST) -&gt; None:
        &#34;&#34;&#34;
        Adds a statement in form of an `AST` node to the program.

        Parameters
        ----------
        statement
            The statement to add.
        &#34;&#34;&#34;
        _handle_error(_lib.clingo_program_builder_add(self._rep, statement._rep))</code></pre>
</details>
<div class="desc"><p>Object to build non-ground programs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>control</code></strong></dt>
<dd>The <code><a title="clingo.control.Control" href="control.html#clingo.control.Control">Control</a></code> object to attach the builder to.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingo.ast.parse_string" href="#clingo.ast.parse_string">parse_string()</a></code>, <code><a title="clingo.ast.parse_files" href="#clingo.ast.parse_files">parse_files()</a></code></p>
<h2 id="notes">Notes</h2>
<p>This class is a context manager and must be used with Python's <code>with</code>
statement.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>contextlib.AbstractContextManager</li>
<li>abc.ABC</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.ProgramBuilder.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, statement: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, statement: AST) -&gt; None:
    &#34;&#34;&#34;
    Adds a statement in form of an `AST` node to the program.

    Parameters
    ----------
    statement
        The statement to add.
    &#34;&#34;&#34;
    _handle_error(_lib.clingo_program_builder_add(self._rep, statement._rep))</code></pre>
</details>
<div class="desc"><p>Adds a statement in form of an <code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code> node to the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>statement</code></strong></dt>
<dd>The statement to add.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Sign"><code class="flex name class">
<span>class <span class="ident">Sign</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sign(IntEnum):
    &#34;&#34;&#34;
    Enumeration of signs for literals.
    &#34;&#34;&#34;

    DoubleNegation = _lib.clingo_ast_sign_double_negation
    &#34;&#34;&#34;
    For double negated literals (with prefix `not not`)
    &#34;&#34;&#34;
    Negation = _lib.clingo_ast_sign_negation
    &#34;&#34;&#34;
    For negative literals (with prefix `not`).
    &#34;&#34;&#34;
    NoSign = _lib.clingo_ast_sign_no_sign
    &#34;&#34;&#34;
    For positive literals.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of signs for literals.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.Sign.DoubleNegation"><code class="name">var <span class="ident">DoubleNegation</span></code></dt>
<dd>
<div class="desc"><p>For double negated literals (with prefix <code>not not</code>)</p></div>
</dd>
<dt id="clingo.ast.Sign.Negation"><code class="name">var <span class="ident">Negation</span></code></dt>
<dd>
<div class="desc"><p>For negative literals (with prefix <code>not</code>).</p></div>
</dd>
<dt id="clingo.ast.Sign.NoSign"><code class="name">var <span class="ident">NoSign</span></code></dt>
<dd>
<div class="desc"><p>For positive literals.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.StrSequence"><code class="flex name class">
<span>class <span class="ident">StrSequence</span></span>
<span>(</span><span>rep, attribute)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrSequence(abc.MutableSequence):
    &#34;&#34;&#34;
    A sequence holding strings.
    &#34;&#34;&#34;

    def __init__(self, rep, attribute):
        self._attribute = attribute
        self._rep = rep
        _lib.clingo_ast_acquire(self._rep)

    def __del__(self):
        _lib.clingo_ast_release(self._rep)

    def __len__(self) -&gt; int:
        return _c_call(
            &#34;size_t&#34;,
            _lib.clingo_ast_attribute_size_string_array,
            self._rep,
            self._attribute,
        )

    def __getitem__(self, index):
        if isinstance(index, slice):
            return SlicedMutableSequence(self, Slice(index))
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#34;invalid index&#34;)
        return _to_str(
            _c_call(
                &#34;char*&#34;,
                _lib.clingo_ast_attribute_get_string_at,
                self._rep,
                self._attribute,
                index,
            )
        )

    def __iter__(self):
        for index in range(len(self)):
            yield _to_str(
                _c_call(
                    &#34;char*&#34;,
                    _lib.clingo_ast_attribute_get_string_at,
                    self._rep,
                    self._attribute,
                    index,
                )
            )

    def __setitem__(self, index, value):
        if isinstance(index, slice):
            raise TypeError(&#34;slicing not implemented&#34;)
        _handle_error(
            _lib.clingo_str_attribute_set_string_at(
                self._rep, self._attribute, index, value.encode()
            )
        )

    def __delitem__(self, index):
        if isinstance(index, slice):
            raise TypeError(&#34;slicing not implemented&#34;)
        size = len(self)
        if index &lt; 0:
            index += size
        if index &lt; 0 or index &gt;= size:
            raise IndexError(&#34;invalid index&#34;)
        _handle_error(
            _lib.clingo_ast_attribute_delete_string_at(
                self._rep, self._attribute, index
            )
        )

    def insert(self, index, value):
        _handle_error(
            _lib.clingo_ast_attribute_insert_string_at(
                self._rep, self._attribute, index, value.encode()
            )
        )

    def clear(self):
        &#34;&#34;&#34;
        Remove all elements from the sequence.
        &#34;&#34;&#34;
        for i in range(len(self), 0, -1):
            del self[i - 1]

    def __str__(self):
        return str(list(self))

    def __repr__(self):
        return repr(list(self))</code></pre>
</details>
<div class="desc"><p>A sequence holding strings.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.StrSequence.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Remove all elements from the sequence.
    &#34;&#34;&#34;
    for i in range(len(self), 0, -1):
        del self[i - 1]</code></pre>
</details>
<div class="desc"><p>Remove all elements from the sequence.</p></div>
</dd>
<dt id="clingo.ast.StrSequence.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, index, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, index, value):
    _handle_error(
        _lib.clingo_ast_attribute_insert_string_at(
            self._rep, self._attribute, index, value.encode()
        )
    )</code></pre>
</details>
<div class="desc"><p>S.insert(index, value) &ndash; insert value before index</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.TheoryAtomType"><code class="flex name class">
<span>class <span class="ident">TheoryAtomType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryAtomType(IntEnum):
    &#34;&#34;&#34;
    Enumeration of theory atom types.
    &#34;&#34;&#34;

    Any = _lib.clingo_ast_theory_atom_definition_type_any
    &#34;&#34;&#34;
    For atoms that can occur anywhere in a rule.
    &#34;&#34;&#34;
    Body = _lib.clingo_ast_theory_atom_definition_type_body
    &#34;&#34;&#34;
    For atoms that can only occur in rule bodies.
    &#34;&#34;&#34;
    Directive = _lib.clingo_ast_theory_atom_definition_type_directive
    &#34;&#34;&#34;
    For atoms that can only occur in facts.
    &#34;&#34;&#34;
    Head = _lib.clingo_ast_theory_atom_definition_type_head
    &#34;&#34;&#34;
    For atoms that can only occur in rule heads.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of theory atom types.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.TheoryAtomType.Any"><code class="name">var <span class="ident">Any</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can occur anywhere in a rule.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomType.Body"><code class="name">var <span class="ident">Body</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can only occur in rule bodies.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomType.Directive"><code class="name">var <span class="ident">Directive</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can only occur in facts.</p></div>
</dd>
<dt id="clingo.ast.TheoryAtomType.Head"><code class="name">var <span class="ident">Head</span></code></dt>
<dd>
<div class="desc"><p>For atoms that can only occur in rule heads.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.TheoryOperatorType"><code class="flex name class">
<span>class <span class="ident">TheoryOperatorType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheoryOperatorType(IntEnum):
    &#34;&#34;&#34;
    Enumeration of operator types.
    &#34;&#34;&#34;

    BinaryLeft = _lib.clingo_ast_theory_operator_type_binary_left
    &#34;&#34;&#34;
    For binary left associative operators.
    &#34;&#34;&#34;
    BinaryRight = _lib.clingo_ast_theory_operator_type_binary_right
    &#34;&#34;&#34;
    For binary right associative operator.
    &#34;&#34;&#34;
    Unary = _lib.clingo_ast_theory_operator_type_unary
    &#34;&#34;&#34;
    For unary operators.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of operator types.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.TheoryOperatorType.BinaryLeft"><code class="name">var <span class="ident">BinaryLeft</span></code></dt>
<dd>
<div class="desc"><p>For binary left associative operators.</p></div>
</dd>
<dt id="clingo.ast.TheoryOperatorType.BinaryRight"><code class="name">var <span class="ident">BinaryRight</span></code></dt>
<dd>
<div class="desc"><p>For binary right associative operator.</p></div>
</dd>
<dt id="clingo.ast.TheoryOperatorType.Unary"><code class="name">var <span class="ident">Unary</span></code></dt>
<dd>
<div class="desc"><p>For unary operators.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.TheorySequenceType"><code class="flex name class">
<span>class <span class="ident">TheorySequenceType</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TheorySequenceType(IntEnum):
    &#34;&#34;&#34;
    Enumeration of theory term sequence types.
    &#34;&#34;&#34;

    List = _lib.clingo_ast_theory_sequence_type_list
    &#34;&#34;&#34;
    For sequences enclosed in brackets.
    &#34;&#34;&#34;
    Set = _lib.clingo_ast_theory_sequence_type_set
    &#34;&#34;&#34;
    For sequences enclosed in braces.
    &#34;&#34;&#34;
    Tuple = _lib.clingo_ast_theory_sequence_type_tuple
    &#34;&#34;&#34;
    For sequences enclosed in parenthesis.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of theory term sequence types.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.TheorySequenceType.List"><code class="name">var <span class="ident">List</span></code></dt>
<dd>
<div class="desc"><p>For sequences enclosed in brackets.</p></div>
</dd>
<dt id="clingo.ast.TheorySequenceType.Set"><code class="name">var <span class="ident">Set</span></code></dt>
<dd>
<div class="desc"><p>For sequences enclosed in braces.</p></div>
</dd>
<dt id="clingo.ast.TheorySequenceType.Tuple"><code class="name">var <span class="ident">Tuple</span></code></dt>
<dd>
<div class="desc"><p>For sequences enclosed in parenthesis.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.Transformer"><code class="flex name class">
<span>class <span class="ident">Transformer</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformer:
    &#34;&#34;&#34;
    Utility class to transform ASTs.

    Classes should inherit from this class and implement functions with name
    `visit_&lt;ast_type&gt;` where `&lt;ast_type&gt;` is the type of the ASTs to visit and
    modify. Such a function should return an updated AST or the same AST if no
    change is necessary. The transformer will take care to copy all parent ASTs
    involving a modified child. Note that the class works like a visitor if
    only self references are returned from such functions.

    Any extra arguments passed to the visit method are passed on to child ASTs.
    &#34;&#34;&#34;

    def visit(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
        &#34;&#34;&#34;
        Dispatch to a visit method in a base class or visit and transform the
        children of the given AST if it is missing.
        &#34;&#34;&#34;
        attr = &#34;visit_&#34; + str(ast.ast_type).replace(&#34;ASTType.&#34;, &#34;&#34;)
        if hasattr(self, attr):
            return getattr(self, attr)(ast, *args, **kwargs)
        return ast.update(**self.visit_children(ast, *args, **kwargs))

    def visit_children(
        self, ast: AST, *args: Any, **kwargs: Any
    ) -&gt; Dict[str, ASTUpdate]:
        &#34;&#34;&#34;
        Visit and transform the children of the given AST.

        Returns
        -------
        The functions returns a dictionary that can be passed to `AST.update`.
        It contains the attributes and values that have been transformed.
        &#34;&#34;&#34;
        update: Dict[str, ASTUpdate] = dict()
        for key in ast.child_keys:
            old = getattr(ast, key)
            new = self._dispatch(old, *args, **kwargs)
            if new is not old:
                update[key] = new
        return update

    def visit_sequence(
        self, sequence: ASTSequence, *args: Any, **kwargs: Any
    ) -&gt; MutableSequence[AST]:
        &#34;&#34;&#34;
        Transform a sequence of ASTs returning the same sequnce if there are no
        changes or a list of ASTs otherwise.
        &#34;&#34;&#34;
        ret: MutableSequence[AST]
        ret, lst = sequence, []
        for old in sequence:
            lst.append(self(old, *args, **kwargs))
            if lst[-1] is not old:
                ret = lst
        return ret

    def _dispatch(
        self, ast: Union[None, AST, ASTSequence], *args: Any, **kwargs: Any
    ) -&gt; Union[None, AST, MutableSequence[AST]]:
        &#34;&#34;&#34;
        Visit and transform an (optional) AST or a sequence of ASTs.
        &#34;&#34;&#34;
        if ast is None:
            return ast

        if isinstance(ast, AST):
            return self.visit(ast, *args, **kwargs)  # type: ignore

        if isinstance(ast, abc.Sequence):
            return self.visit_sequence(ast, *args, **kwargs)

        raise TypeError(&#34;unexpected type&#34;)

    def __call__(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
        &#34;&#34;&#34;
        Alternative way to call `Transformer.visit`.
        &#34;&#34;&#34;
        return self.visit(ast, *args, **kwargs)</code></pre>
</details>
<div class="desc"><p>Utility class to transform ASTs.</p>
<p>Classes should inherit from this class and implement functions with name
<code>visit_&lt;ast_type&gt;</code> where <code>&lt;ast_type&gt;</code> is the type of the ASTs to visit and
modify. Such a function should return an updated AST or the same AST if no
change is necessary. The transformer will take care to copy all parent ASTs
involving a modified child. Note that the class works like a visitor if
only self references are returned from such functions.</p>
<p>Any extra arguments passed to the visit method are passed on to child ASTs.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clingo.tests.test_ast.VariableRenamer" href="tests/test_ast.html#clingo.tests.test_ast.VariableRenamer">VariableRenamer</a></li>
<li><a title="clingox.ast.TheoryParser" href="../clingox/ast.html#clingox.ast.TheoryParser">TheoryParser</a></li>
<li><a title="clingox.ast.TheoryTermParser" href="../clingox/ast.html#clingox.ast.TheoryTermParser">TheoryTermParser</a></li>
<li>clingox.ast._NormalizeSymbolicTermTransformer</li>
<li>clingox.ast._SymbolicAtomTransformer</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingo.ast.Transformer.visit"><code class="name flex">
<span>def <span class="ident">visit</span></span>(<span>self,<br>ast: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>*args: Any,<br>**kwargs: Any) ‑> <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit(self, ast: AST, *args: Any, **kwargs: Any) -&gt; AST:
    &#34;&#34;&#34;
    Dispatch to a visit method in a base class or visit and transform the
    children of the given AST if it is missing.
    &#34;&#34;&#34;
    attr = &#34;visit_&#34; + str(ast.ast_type).replace(&#34;ASTType.&#34;, &#34;&#34;)
    if hasattr(self, attr):
        return getattr(self, attr)(ast, *args, **kwargs)
    return ast.update(**self.visit_children(ast, *args, **kwargs))</code></pre>
</details>
<div class="desc"><p>Dispatch to a visit method in a base class or visit and transform the
children of the given AST if it is missing.</p></div>
</dd>
<dt id="clingo.ast.Transformer.visit_children"><code class="name flex">
<span>def <span class="ident">visit_children</span></span>(<span>self,<br>ast: <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>,<br>*args: Any,<br>**kwargs: Any) ‑> Dict[str, str | int | <a title="clingo.symbol.Symbol" href="symbol.html#clingo.symbol.Symbol">Symbol</a> | <a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a> | <a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a> | Sequence[str] | Sequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_children(
    self, ast: AST, *args: Any, **kwargs: Any
) -&gt; Dict[str, ASTUpdate]:
    &#34;&#34;&#34;
    Visit and transform the children of the given AST.

    Returns
    -------
    The functions returns a dictionary that can be passed to `AST.update`.
    It contains the attributes and values that have been transformed.
    &#34;&#34;&#34;
    update: Dict[str, ASTUpdate] = dict()
    for key in ast.child_keys:
        old = getattr(ast, key)
        new = self._dispatch(old, *args, **kwargs)
        if new is not old:
            update[key] = new
    return update</code></pre>
</details>
<div class="desc"><p>Visit and transform the children of the given AST.</p>
<h2 id="returns">Returns</h2>
<p>The functions returns a dictionary that can be passed to <code><a title="clingo.ast.AST.update" href="#clingo.ast.AST.update">AST.update()</a></code>.
It contains the attributes and values that have been transformed.</p></div>
</dd>
<dt id="clingo.ast.Transformer.visit_sequence"><code class="name flex">
<span>def <span class="ident">visit_sequence</span></span>(<span>self,<br>sequence: <a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a>,<br>*args: Any,<br>**kwargs: Any) ‑> MutableSequence[<a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_sequence(
    self, sequence: ASTSequence, *args: Any, **kwargs: Any
) -&gt; MutableSequence[AST]:
    &#34;&#34;&#34;
    Transform a sequence of ASTs returning the same sequnce if there are no
    changes or a list of ASTs otherwise.
    &#34;&#34;&#34;
    ret: MutableSequence[AST]
    ret, lst = sequence, []
    for old in sequence:
        lst.append(self(old, *args, **kwargs))
        if lst[-1] is not old:
            ret = lst
    return ret</code></pre>
</details>
<div class="desc"><p>Transform a sequence of ASTs returning the same sequnce if there are no
changes or a list of ASTs otherwise.</p></div>
</dd>
</dl>
</dd>
<dt id="clingo.ast.UnaryOperator"><code class="flex name class">
<span>class <span class="ident">UnaryOperator</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnaryOperator(IntEnum):
    &#34;&#34;&#34;
    Enumeration of signs for literals.
    &#34;&#34;&#34;

    Absolute = _lib.clingo_ast_unary_operator_absolute
    &#34;&#34;&#34;
    For taking the absolute value.
    &#34;&#34;&#34;
    Minus = _lib.clingo_ast_unary_operator_minus
    &#34;&#34;&#34;
    For unary minus and classical negation.
    &#34;&#34;&#34;
    Negation = _lib.clingo_ast_unary_operator_negation
    &#34;&#34;&#34;
    For bitwise negation.
    &#34;&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Enumeration of signs for literals.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.ReprEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="clingo.ast.UnaryOperator.Absolute"><code class="name">var <span class="ident">Absolute</span></code></dt>
<dd>
<div class="desc"><p>For taking the absolute value.</p></div>
</dd>
<dt id="clingo.ast.UnaryOperator.Minus"><code class="name">var <span class="ident">Minus</span></code></dt>
<dd>
<div class="desc"><p>For unary minus and classical negation.</p></div>
</dd>
<dt id="clingo.ast.UnaryOperator.Negation"><code class="name">var <span class="ident">Negation</span></code></dt>
<dd>
<div class="desc"><p>For bitwise negation.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#grammar">Grammar</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clingo" href="index.html">clingo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clingo.ast.Aggregate" href="#clingo.ast.Aggregate">Aggregate</a></code></li>
<li><code><a title="clingo.ast.BinaryOperation" href="#clingo.ast.BinaryOperation">BinaryOperation</a></code></li>
<li><code><a title="clingo.ast.BodyAggregate" href="#clingo.ast.BodyAggregate">BodyAggregate</a></code></li>
<li><code><a title="clingo.ast.BodyAggregateElement" href="#clingo.ast.BodyAggregateElement">BodyAggregateElement</a></code></li>
<li><code><a title="clingo.ast.BooleanConstant" href="#clingo.ast.BooleanConstant">BooleanConstant</a></code></li>
<li><code><a title="clingo.ast.Comment" href="#clingo.ast.Comment">Comment</a></code></li>
<li><code><a title="clingo.ast.Comparison" href="#clingo.ast.Comparison">Comparison</a></code></li>
<li><code><a title="clingo.ast.ConditionalLiteral" href="#clingo.ast.ConditionalLiteral">ConditionalLiteral</a></code></li>
<li><code><a title="clingo.ast.Defined" href="#clingo.ast.Defined">Defined</a></code></li>
<li><code><a title="clingo.ast.Definition" href="#clingo.ast.Definition">Definition</a></code></li>
<li><code><a title="clingo.ast.Disjunction" href="#clingo.ast.Disjunction">Disjunction</a></code></li>
<li><code><a title="clingo.ast.Edge" href="#clingo.ast.Edge">Edge</a></code></li>
<li><code><a title="clingo.ast.External" href="#clingo.ast.External">External</a></code></li>
<li><code><a title="clingo.ast.Function" href="#clingo.ast.Function">Function</a></code></li>
<li><code><a title="clingo.ast.Guard" href="#clingo.ast.Guard">Guard</a></code></li>
<li><code><a title="clingo.ast.HeadAggregate" href="#clingo.ast.HeadAggregate">HeadAggregate</a></code></li>
<li><code><a title="clingo.ast.HeadAggregateElement" href="#clingo.ast.HeadAggregateElement">HeadAggregateElement</a></code></li>
<li><code><a title="clingo.ast.Heuristic" href="#clingo.ast.Heuristic">Heuristic</a></code></li>
<li><code><a title="clingo.ast.Id" href="#clingo.ast.Id">Id</a></code></li>
<li><code><a title="clingo.ast.Interval" href="#clingo.ast.Interval">Interval</a></code></li>
<li><code><a title="clingo.ast.Literal" href="#clingo.ast.Literal">Literal</a></code></li>
<li><code><a title="clingo.ast.Minimize" href="#clingo.ast.Minimize">Minimize</a></code></li>
<li><code><a title="clingo.ast.Pool" href="#clingo.ast.Pool">Pool</a></code></li>
<li><code><a title="clingo.ast.Program" href="#clingo.ast.Program">Program</a></code></li>
<li><code><a title="clingo.ast.ProjectAtom" href="#clingo.ast.ProjectAtom">ProjectAtom</a></code></li>
<li><code><a title="clingo.ast.ProjectSignature" href="#clingo.ast.ProjectSignature">ProjectSignature</a></code></li>
<li><code><a title="clingo.ast.Rule" href="#clingo.ast.Rule">Rule</a></code></li>
<li><code><a title="clingo.ast.Script" href="#clingo.ast.Script">Script</a></code></li>
<li><code><a title="clingo.ast.ShowSignature" href="#clingo.ast.ShowSignature">ShowSignature</a></code></li>
<li><code><a title="clingo.ast.ShowTerm" href="#clingo.ast.ShowTerm">ShowTerm</a></code></li>
<li><code><a title="clingo.ast.SymbolicAtom" href="#clingo.ast.SymbolicAtom">SymbolicAtom</a></code></li>
<li><code><a title="clingo.ast.SymbolicTerm" href="#clingo.ast.SymbolicTerm">SymbolicTerm</a></code></li>
<li><code><a title="clingo.ast.TheoryAtom" href="#clingo.ast.TheoryAtom">TheoryAtom</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomDefinition" href="#clingo.ast.TheoryAtomDefinition">TheoryAtomDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomElement" href="#clingo.ast.TheoryAtomElement">TheoryAtomElement</a></code></li>
<li><code><a title="clingo.ast.TheoryDefinition" href="#clingo.ast.TheoryDefinition">TheoryDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryFunction" href="#clingo.ast.TheoryFunction">TheoryFunction</a></code></li>
<li><code><a title="clingo.ast.TheoryGuard" href="#clingo.ast.TheoryGuard">TheoryGuard</a></code></li>
<li><code><a title="clingo.ast.TheoryGuardDefinition" href="#clingo.ast.TheoryGuardDefinition">TheoryGuardDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryOperatorDefinition" href="#clingo.ast.TheoryOperatorDefinition">TheoryOperatorDefinition</a></code></li>
<li><code><a title="clingo.ast.TheorySequence" href="#clingo.ast.TheorySequence">TheorySequence</a></code></li>
<li><code><a title="clingo.ast.TheoryTermDefinition" href="#clingo.ast.TheoryTermDefinition">TheoryTermDefinition</a></code></li>
<li><code><a title="clingo.ast.TheoryUnparsedTerm" href="#clingo.ast.TheoryUnparsedTerm">TheoryUnparsedTerm</a></code></li>
<li><code><a title="clingo.ast.TheoryUnparsedTermElement" href="#clingo.ast.TheoryUnparsedTermElement">TheoryUnparsedTermElement</a></code></li>
<li><code><a title="clingo.ast.UnaryOperation" href="#clingo.ast.UnaryOperation">UnaryOperation</a></code></li>
<li><code><a title="clingo.ast.Variable" href="#clingo.ast.Variable">Variable</a></code></li>
<li><code><a title="clingo.ast.parse_files" href="#clingo.ast.parse_files">parse_files</a></code></li>
<li><code><a title="clingo.ast.parse_string" href="#clingo.ast.parse_string">parse_string</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingo.ast.AST" href="#clingo.ast.AST">AST</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ast.AST.ast_type" href="#clingo.ast.AST.ast_type">ast_type</a></code></li>
<li><code><a title="clingo.ast.AST.child_keys" href="#clingo.ast.AST.child_keys">child_keys</a></code></li>
<li><code><a title="clingo.ast.AST.items" href="#clingo.ast.AST.items">items</a></code></li>
<li><code><a title="clingo.ast.AST.keys" href="#clingo.ast.AST.keys">keys</a></code></li>
<li><code><a title="clingo.ast.AST.unpool" href="#clingo.ast.AST.unpool">unpool</a></code></li>
<li><code><a title="clingo.ast.AST.update" href="#clingo.ast.AST.update">update</a></code></li>
<li><code><a title="clingo.ast.AST.values" href="#clingo.ast.AST.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ASTSequence" href="#clingo.ast.ASTSequence">ASTSequence</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.ASTSequence.clear" href="#clingo.ast.ASTSequence.clear">clear</a></code></li>
<li><code><a title="clingo.ast.ASTSequence.insert" href="#clingo.ast.ASTSequence.insert">insert</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ASTType" href="#clingo.ast.ASTType">ASTType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.ASTType.Aggregate" href="#clingo.ast.ASTType.Aggregate">Aggregate</a></code></li>
<li><code><a title="clingo.ast.ASTType.BinaryOperation" href="#clingo.ast.ASTType.BinaryOperation">BinaryOperation</a></code></li>
<li><code><a title="clingo.ast.ASTType.BodyAggregate" href="#clingo.ast.ASTType.BodyAggregate">BodyAggregate</a></code></li>
<li><code><a title="clingo.ast.ASTType.BodyAggregateElement" href="#clingo.ast.ASTType.BodyAggregateElement">BodyAggregateElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.BooleanConstant" href="#clingo.ast.ASTType.BooleanConstant">BooleanConstant</a></code></li>
<li><code><a title="clingo.ast.ASTType.Comment" href="#clingo.ast.ASTType.Comment">Comment</a></code></li>
<li><code><a title="clingo.ast.ASTType.Comparison" href="#clingo.ast.ASTType.Comparison">Comparison</a></code></li>
<li><code><a title="clingo.ast.ASTType.ConditionalLiteral" href="#clingo.ast.ASTType.ConditionalLiteral">ConditionalLiteral</a></code></li>
<li><code><a title="clingo.ast.ASTType.Defined" href="#clingo.ast.ASTType.Defined">Defined</a></code></li>
<li><code><a title="clingo.ast.ASTType.Definition" href="#clingo.ast.ASTType.Definition">Definition</a></code></li>
<li><code><a title="clingo.ast.ASTType.Disjunction" href="#clingo.ast.ASTType.Disjunction">Disjunction</a></code></li>
<li><code><a title="clingo.ast.ASTType.Edge" href="#clingo.ast.ASTType.Edge">Edge</a></code></li>
<li><code><a title="clingo.ast.ASTType.External" href="#clingo.ast.ASTType.External">External</a></code></li>
<li><code><a title="clingo.ast.ASTType.Function" href="#clingo.ast.ASTType.Function">Function</a></code></li>
<li><code><a title="clingo.ast.ASTType.Guard" href="#clingo.ast.ASTType.Guard">Guard</a></code></li>
<li><code><a title="clingo.ast.ASTType.HeadAggregate" href="#clingo.ast.ASTType.HeadAggregate">HeadAggregate</a></code></li>
<li><code><a title="clingo.ast.ASTType.HeadAggregateElement" href="#clingo.ast.ASTType.HeadAggregateElement">HeadAggregateElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.Heuristic" href="#clingo.ast.ASTType.Heuristic">Heuristic</a></code></li>
<li><code><a title="clingo.ast.ASTType.Id" href="#clingo.ast.ASTType.Id">Id</a></code></li>
<li><code><a title="clingo.ast.ASTType.Interval" href="#clingo.ast.ASTType.Interval">Interval</a></code></li>
<li><code><a title="clingo.ast.ASTType.Literal" href="#clingo.ast.ASTType.Literal">Literal</a></code></li>
<li><code><a title="clingo.ast.ASTType.Minimize" href="#clingo.ast.ASTType.Minimize">Minimize</a></code></li>
<li><code><a title="clingo.ast.ASTType.Pool" href="#clingo.ast.ASTType.Pool">Pool</a></code></li>
<li><code><a title="clingo.ast.ASTType.Program" href="#clingo.ast.ASTType.Program">Program</a></code></li>
<li><code><a title="clingo.ast.ASTType.ProjectAtom" href="#clingo.ast.ASTType.ProjectAtom">ProjectAtom</a></code></li>
<li><code><a title="clingo.ast.ASTType.ProjectSignature" href="#clingo.ast.ASTType.ProjectSignature">ProjectSignature</a></code></li>
<li><code><a title="clingo.ast.ASTType.Rule" href="#clingo.ast.ASTType.Rule">Rule</a></code></li>
<li><code><a title="clingo.ast.ASTType.Script" href="#clingo.ast.ASTType.Script">Script</a></code></li>
<li><code><a title="clingo.ast.ASTType.ShowSignature" href="#clingo.ast.ASTType.ShowSignature">ShowSignature</a></code></li>
<li><code><a title="clingo.ast.ASTType.ShowTerm" href="#clingo.ast.ASTType.ShowTerm">ShowTerm</a></code></li>
<li><code><a title="clingo.ast.ASTType.SymbolicAtom" href="#clingo.ast.ASTType.SymbolicAtom">SymbolicAtom</a></code></li>
<li><code><a title="clingo.ast.ASTType.SymbolicTerm" href="#clingo.ast.ASTType.SymbolicTerm">SymbolicTerm</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryAtom" href="#clingo.ast.ASTType.TheoryAtom">TheoryAtom</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryAtomDefinition" href="#clingo.ast.ASTType.TheoryAtomDefinition">TheoryAtomDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryAtomElement" href="#clingo.ast.ASTType.TheoryAtomElement">TheoryAtomElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryDefinition" href="#clingo.ast.ASTType.TheoryDefinition">TheoryDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryFunction" href="#clingo.ast.ASTType.TheoryFunction">TheoryFunction</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryGuard" href="#clingo.ast.ASTType.TheoryGuard">TheoryGuard</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryGuardDefinition" href="#clingo.ast.ASTType.TheoryGuardDefinition">TheoryGuardDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryOperatorDefinition" href="#clingo.ast.ASTType.TheoryOperatorDefinition">TheoryOperatorDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheorySequence" href="#clingo.ast.ASTType.TheorySequence">TheorySequence</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryTermDefinition" href="#clingo.ast.ASTType.TheoryTermDefinition">TheoryTermDefinition</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryUnparsedTerm" href="#clingo.ast.ASTType.TheoryUnparsedTerm">TheoryUnparsedTerm</a></code></li>
<li><code><a title="clingo.ast.ASTType.TheoryUnparsedTermElement" href="#clingo.ast.ASTType.TheoryUnparsedTermElement">TheoryUnparsedTermElement</a></code></li>
<li><code><a title="clingo.ast.ASTType.UnaryOperation" href="#clingo.ast.ASTType.UnaryOperation">UnaryOperation</a></code></li>
<li><code><a title="clingo.ast.ASTType.Variable" href="#clingo.ast.ASTType.Variable">Variable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.AggregateFunction" href="#clingo.ast.AggregateFunction">AggregateFunction</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.AggregateFunction.Count" href="#clingo.ast.AggregateFunction.Count">Count</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.Max" href="#clingo.ast.AggregateFunction.Max">Max</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.Min" href="#clingo.ast.AggregateFunction.Min">Min</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.Sum" href="#clingo.ast.AggregateFunction.Sum">Sum</a></code></li>
<li><code><a title="clingo.ast.AggregateFunction.SumPlus" href="#clingo.ast.AggregateFunction.SumPlus">SumPlus</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.BinaryOperator" href="#clingo.ast.BinaryOperator">BinaryOperator</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ast.BinaryOperator.And" href="#clingo.ast.BinaryOperator.And">And</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Division" href="#clingo.ast.BinaryOperator.Division">Division</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Minus" href="#clingo.ast.BinaryOperator.Minus">Minus</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Modulo" href="#clingo.ast.BinaryOperator.Modulo">Modulo</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Multiplication" href="#clingo.ast.BinaryOperator.Multiplication">Multiplication</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Or" href="#clingo.ast.BinaryOperator.Or">Or</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Plus" href="#clingo.ast.BinaryOperator.Plus">Plus</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.Power" href="#clingo.ast.BinaryOperator.Power">Power</a></code></li>
<li><code><a title="clingo.ast.BinaryOperator.XOr" href="#clingo.ast.BinaryOperator.XOr">XOr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.CommentType" href="#clingo.ast.CommentType">CommentType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.CommentType.Block" href="#clingo.ast.CommentType.Block">Block</a></code></li>
<li><code><a title="clingo.ast.CommentType.Line" href="#clingo.ast.CommentType.Line">Line</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ComparisonOperator" href="#clingo.ast.ComparisonOperator">ComparisonOperator</a></code></h4>
<ul class="two-column">
<li><code><a title="clingo.ast.ComparisonOperator.Equal" href="#clingo.ast.ComparisonOperator.Equal">Equal</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.GreaterEqual" href="#clingo.ast.ComparisonOperator.GreaterEqual">GreaterEqual</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.GreaterThan" href="#clingo.ast.ComparisonOperator.GreaterThan">GreaterThan</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.LessEqual" href="#clingo.ast.ComparisonOperator.LessEqual">LessEqual</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.LessThan" href="#clingo.ast.ComparisonOperator.LessThan">LessThan</a></code></li>
<li><code><a title="clingo.ast.ComparisonOperator.NotEqual" href="#clingo.ast.ComparisonOperator.NotEqual">NotEqual</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Location" href="#clingo.ast.Location">Location</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Location.begin" href="#clingo.ast.Location.begin">begin</a></code></li>
<li><code><a title="clingo.ast.Location.end" href="#clingo.ast.Location.end">end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Position" href="#clingo.ast.Position">Position</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Position.column" href="#clingo.ast.Position.column">column</a></code></li>
<li><code><a title="clingo.ast.Position.filename" href="#clingo.ast.Position.filename">filename</a></code></li>
<li><code><a title="clingo.ast.Position.line" href="#clingo.ast.Position.line">line</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.ProgramBuilder" href="#clingo.ast.ProgramBuilder">ProgramBuilder</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.ProgramBuilder.add" href="#clingo.ast.ProgramBuilder.add">add</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Sign" href="#clingo.ast.Sign">Sign</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Sign.DoubleNegation" href="#clingo.ast.Sign.DoubleNegation">DoubleNegation</a></code></li>
<li><code><a title="clingo.ast.Sign.Negation" href="#clingo.ast.Sign.Negation">Negation</a></code></li>
<li><code><a title="clingo.ast.Sign.NoSign" href="#clingo.ast.Sign.NoSign">NoSign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.StrSequence" href="#clingo.ast.StrSequence">StrSequence</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.StrSequence.clear" href="#clingo.ast.StrSequence.clear">clear</a></code></li>
<li><code><a title="clingo.ast.StrSequence.insert" href="#clingo.ast.StrSequence.insert">insert</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.TheoryAtomType" href="#clingo.ast.TheoryAtomType">TheoryAtomType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.TheoryAtomType.Any" href="#clingo.ast.TheoryAtomType.Any">Any</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomType.Body" href="#clingo.ast.TheoryAtomType.Body">Body</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomType.Directive" href="#clingo.ast.TheoryAtomType.Directive">Directive</a></code></li>
<li><code><a title="clingo.ast.TheoryAtomType.Head" href="#clingo.ast.TheoryAtomType.Head">Head</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.TheoryOperatorType" href="#clingo.ast.TheoryOperatorType">TheoryOperatorType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.TheoryOperatorType.BinaryLeft" href="#clingo.ast.TheoryOperatorType.BinaryLeft">BinaryLeft</a></code></li>
<li><code><a title="clingo.ast.TheoryOperatorType.BinaryRight" href="#clingo.ast.TheoryOperatorType.BinaryRight">BinaryRight</a></code></li>
<li><code><a title="clingo.ast.TheoryOperatorType.Unary" href="#clingo.ast.TheoryOperatorType.Unary">Unary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.TheorySequenceType" href="#clingo.ast.TheorySequenceType">TheorySequenceType</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.TheorySequenceType.List" href="#clingo.ast.TheorySequenceType.List">List</a></code></li>
<li><code><a title="clingo.ast.TheorySequenceType.Set" href="#clingo.ast.TheorySequenceType.Set">Set</a></code></li>
<li><code><a title="clingo.ast.TheorySequenceType.Tuple" href="#clingo.ast.TheorySequenceType.Tuple">Tuple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.Transformer" href="#clingo.ast.Transformer">Transformer</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.Transformer.visit" href="#clingo.ast.Transformer.visit">visit</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_children" href="#clingo.ast.Transformer.visit_children">visit_children</a></code></li>
<li><code><a title="clingo.ast.Transformer.visit_sequence" href="#clingo.ast.Transformer.visit_sequence">visit_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingo.ast.UnaryOperator" href="#clingo.ast.UnaryOperator">UnaryOperator</a></code></h4>
<ul class="">
<li><code><a title="clingo.ast.UnaryOperator.Absolute" href="#clingo.ast.UnaryOperator.Absolute">Absolute</a></code></li>
<li><code><a title="clingo.ast.UnaryOperator.Minus" href="#clingo.ast.UnaryOperator.Minus">Minus</a></code></li>
<li><code><a title="clingo.ast.UnaryOperator.Negation" href="#clingo.ast.UnaryOperator.Negation">Negation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>

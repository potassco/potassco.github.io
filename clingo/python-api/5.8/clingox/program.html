<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>clingox.program API documentation</title>
<meta name="description" content="This module provides functions to work with ground programs …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<nav class="http-server-breadcrumbs">
<a href="https://potassco.org/clingo/python-api/5.8/">All packages</a>
:: <a href="https://potassco.org/clingo/python-api/5.8/clingox/">clingox</a>
</nav>
<h1 class="title">Module <code>clingox.program</code></h1>
</header>
<section id="section-intro">
<p>This module provides functions to work with ground programs.</p>
<p>This includes constructing a ground representation using an observer, pretty
printing the ground representation, and adding ground program to control
objects via the backend.</p>
<h2 id="example">Example</h2>
<p>The following example shows how to:</p>
<ul>
<li>use the <code><a title="clingox.program.ProgramObserver" href="#clingox.program.ProgramObserver">ProgramObserver</a></code> to construct a <code><a title="clingox.program.Program" href="#clingox.program.Program">Program</a></code>, and</li>
<li>add it to another <code><a title="clingo.control.Control" href="../clingo/control.html#clingo.control.Control">Control</a></code> object.</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; from clingo.control import Control
&gt;&gt;&gt; from clingox.program import Program, ProgramObserver, Remapping
&gt;&gt;&gt;
&gt;&gt;&gt; prg = Program()
&gt;&gt;&gt; ctl_a = Control()
&gt;&gt;&gt; ctl_a.register_observer(ProgramObserver(prg))
&gt;&gt;&gt;
&gt;&gt;&gt; ctl_a.add('base', [], 'a. {b}. c :- b.')
&gt;&gt;&gt; ctl_a.ground([('base', [])])
&gt;&gt;&gt; print(prg)
a.
__x1.
c :- b.
{b}.
&gt;&gt;&gt;
&gt;&gt;&gt; ctl_b = Control(['0'])
&gt;&gt;&gt; with ctl_b.backend() as backend:
...     mapping = Remapping(backend, prg.output_atoms, prg.facts)
...     prg.add_to_backend(backend, mapping)
...
&gt;&gt;&gt; ctl_b.solve(on_model=print)
a
b c a
</code></pre>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clingox.program.add_to_backend"><code class="name flex">
<span>def <span class="ident">add_to_backend</span></span>(<span>stm,<br>backend: <a title="clingo.backend.Backend" href="../clingo/backend.html#clingo.backend.Backend">Backend</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@singledispatch
def add_to_backend(stm, backend: Backend):
    &#34;&#34;&#34;
    Add statements to the backend using the provided mapping to map literals.

    Parameters
    ----------
    stm
        The statement to add to the backend.
    backend
        The backend.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;</code></pre>
</details>
<div class="desc"><p>Add statements to the backend using the provided mapping to map literals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stm</code></strong></dt>
<dd>The statement to add to the backend.</dd>
<dt><strong><code>backend</code></strong></dt>
<dd>The backend.</dd>
</dl></div>
</dd>
<dt id="clingox.program.pretty_str"><code class="name flex">
<span>def <span class="ident">pretty_str</span></span>(<span>stm,<br>output_atoms: Mapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@singledispatch
def pretty_str(stm, output_atoms: OutputTable) -&gt; str:
    &#34;&#34;&#34;
    Pretty print statements.

    Parameters
    ----------
    stm
        The statement to convert to a string.
    output_atoms
        A mapping from program atoms to symbols.

    Returns
    -------
    The string representation of the statement.
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;</code></pre>
</details>
<div class="desc"><p>Pretty print statements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stm</code></strong></dt>
<dd>The statement to convert to a string.</dd>
<dt><strong><code>output_atoms</code></strong></dt>
<dd>A mapping from program atoms to symbols.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string representation of the statement.</p></div>
</dd>
<dt id="clingox.program.remap"><code class="name flex">
<span>def <span class="ident">remap</span></span>(<span>stm, mapping: Callable[[int], int])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@singledispatch
def remap(stm, mapping: AtomMap):
    &#34;&#34;&#34;
    Remap literals in the given statement with the provided mapping.

    Parameters
    ----------
    stm
        The statement to remap.
    mapping
        The mapping function to remap literals.

    Returns
    -------
    The updated statement.

    See Also
    --------
    Remapping
    &#34;&#34;&#34;
    # pylint: disable=unused-argument
    assert False, &#34;unexpected type&#34;</code></pre>
</details>
<div class="desc"><p>Remap literals in the given statement with the provided mapping.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stm</code></strong></dt>
<dd>The statement to remap.</dd>
<dt><strong><code>mapping</code></strong></dt>
<dd>The mapping function to remap literals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The updated statement.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.program.Remapping" href="#clingox.program.Remapping">Remapping</a></code></p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clingox.program.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
<span>(</span><span>u: int, v: int, condition: Sequence[int])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    u: int
    v: int
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Ground representation of a heuristic statement.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Edge.condition"><code class="name">var <span class="ident">condition</span> : Sequence[int]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    u: int
    v: int
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="clingox.program.Edge.u"><code class="name">var <span class="ident">u</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    u: int
    v: int
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.Edge.v"><code class="name">var <span class="ident">v</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    u: int
    v: int
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.External"><code class="flex name class">
<span>class <span class="ident">External</span></span>
<span>(</span><span>atom: int,<br>value: <a title="clingo.core.TruthValue" href="../clingo/core.html#clingo.core.TruthValue">TruthValue</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class External(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of external atoms.
    &#34;&#34;&#34;

    atom: Atom
    value: TruthValue</code></pre>
</details>
<div class="desc"><p>Ground representation of external atoms.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.External.atom"><code class="name">var <span class="ident">atom</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class External(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of external atoms.
    &#34;&#34;&#34;

    atom: Atom
    value: TruthValue</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.External.value"><code class="name">var <span class="ident">value</span> : <a title="clingo.core.TruthValue" href="../clingo/core.html#clingo.core.TruthValue">TruthValue</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class External(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of external atoms.
    &#34;&#34;&#34;

    atom: Atom
    value: TruthValue</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Fact"><code class="flex name class">
<span>class <span class="ident">Fact</span></span>
<span>(</span><span>symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fact(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a fact.
    &#34;&#34;&#34;

    symbol: Symbol</code></pre>
</details>
<div class="desc"><p>Ground representation of a fact.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Fact.symbol"><code class="name">var <span class="ident">symbol</span> : <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fact(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a fact.
    &#34;&#34;&#34;

    symbol: Symbol</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Heuristic"><code class="flex name class">
<span>class <span class="ident">Heuristic</span></span>
<span>(</span><span>atom: int,<br>type_: <a title="clingo.backend.HeuristicType" href="../clingo/backend.html#clingo.backend.HeuristicType">HeuristicType</a>,<br>bias: int,<br>priority: int,<br>condition: Sequence[int])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Ground representation of a heuristic statement.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Heuristic.atom"><code class="name">var <span class="ident">atom</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.Heuristic.bias"><code class="name">var <span class="ident">bias</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="clingox.program.Heuristic.condition"><code class="name">var <span class="ident">condition</span> : Sequence[int]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="clingox.program.Heuristic.priority"><code class="name">var <span class="ident">priority</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="clingox.program.Heuristic.type_"><code class="name">var <span class="ident">type_</span> : <a title="clingo.backend.HeuristicType" href="../clingo/backend.html#clingo.backend.HeuristicType">HeuristicType</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Heuristic(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a heuristic statement.
    &#34;&#34;&#34;

    atom: Atom
    type_: HeuristicType
    bias: Weight
    priority: Weight
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Minimize"><code class="flex name class">
<span>class <span class="ident">Minimize</span></span>
<span>(</span><span>priority: int, literals: Sequence[Tuple[int, int]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Minimize(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a minimize statement.
    &#34;&#34;&#34;

    priority: Weight
    literals: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Ground representation of a minimize statement.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Minimize.literals"><code class="name">var <span class="ident">literals</span> : Sequence[Tuple[int, int]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Minimize(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a minimize statement.
    &#34;&#34;&#34;

    priority: Weight
    literals: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="clingox.program.Minimize.priority"><code class="name">var <span class="ident">priority</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Minimize(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a minimize statement.
    &#34;&#34;&#34;

    priority: Weight
    literals: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Program"><code class="flex name class">
<span>class <span class="ident">Program</span></span>
<span>(</span><span>output_atoms: MutableMapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>] = &lt;factory&gt;,<br>shows: List[<a title="clingox.program.Show" href="#clingox.program.Show">Show</a>] = &lt;factory&gt;,<br>facts: List[<a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a>] = &lt;factory&gt;,<br>rules: List[<a title="clingox.program.Rule" href="#clingox.program.Rule">Rule</a>] = &lt;factory&gt;,<br>weight_rules: List[<a title="clingox.program.WeightRule" href="#clingox.program.WeightRule">WeightRule</a>] = &lt;factory&gt;,<br>heuristics: List[<a title="clingox.program.Heuristic" href="#clingox.program.Heuristic">Heuristic</a>] = &lt;factory&gt;,<br>edges: List[<a title="clingox.program.Edge" href="#clingox.program.Edge">Edge</a>] = &lt;factory&gt;,<br>minimizes: List[<a title="clingox.program.Minimize" href="#clingox.program.Minimize">Minimize</a>] = &lt;factory&gt;,<br>externals: List[<a title="clingox.program.External" href="#clingox.program.External">External</a>] = &lt;factory&gt;,<br>projects: List[<a title="clingox.program.Project" href="#clingox.program.Project">Project</a>] | None = None,<br>assumptions: List[int] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Program:  # pylint: disable=too-many-instance-attributes
    &#34;&#34;&#34;
    Ground program representation.

    Although inefficient, the string representation of this program is parsable
    by clingo.
    &#34;&#34;&#34;

    output_atoms: MutableMapping[Atom, Symbol] = field(default_factory=dict)
    &#34;&#34;&#34;
    A mapping from program atoms to symbols.
    &#34;&#34;&#34;
    shows: List[Show] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of show statements.
    &#34;&#34;&#34;
    facts: List[Fact] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of facts.
    &#34;&#34;&#34;
    rules: List[Rule] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of rules.
    &#34;&#34;&#34;
    weight_rules: List[WeightRule] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of weight rules.
    &#34;&#34;&#34;
    heuristics: List[Heuristic] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of heuristic statements.
    &#34;&#34;&#34;
    edges: List[Edge] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of edge statements.
    &#34;&#34;&#34;
    minimizes: List[Minimize] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of minimize statements.
    &#34;&#34;&#34;
    externals: List[External] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of external statements.
    &#34;&#34;&#34;
    projects: Optional[List[Project]] = None
    &#34;&#34;&#34;
    A list of project statements.
    &#34;&#34;&#34;
    assumptions: List[Literal] = field(default_factory=list)
    &#34;&#34;&#34;
    A list of assumptions in form of program literals.
    &#34;&#34;&#34;

    def _pretty_stms(self, arg: Iterable[Statement], sort: bool) -&gt; Iterable[str]:
        if sort:
            arg = sorted(arg)
        return (pretty_str(x, self.output_atoms) for x in arg)

    def _pretty_assumptions(self, sort: bool) -&gt; Iterable[str]:
        if not self.assumptions:
            return []
        arg = sorted(self.assumptions) if sort else self.assumptions
        assumptions = (_pretty_str_lit(lit, self.output_atoms) for lit in arg)
        return [f&#39;% assumptions: {&#34;, &#34;.join(assumptions)}&#39;]

    def _pretty_projects(self, sort: bool) -&gt; Iterable[str]:
        if self.projects is None:
            return []
        # This is to inform that there is an empty projection statement.
        # It might be worth to allow writing just #project.
        if not self.projects:
            return [&#34;#project x: #false.&#34;]
        arg = sorted(self.projects) if sort else self.projects
        return (pretty_str(project, self.output_atoms) for project in arg)

    def sort(self) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Sort the statements in the program inplace.

        Returns
        -------
        A reference to self.
        &#34;&#34;&#34;
        self.shows.sort()
        self.facts.sort()
        self.rules.sort()
        self.weight_rules.sort()
        self.heuristics.sort()
        self.edges.sort()
        self.minimizes.sort()
        self.externals.sort()
        if self.projects is not None:
            self.projects.sort()
        self.assumptions.sort()

        return self

    def remap(self, mapping: AtomMap) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Remap the literals in the program inplace.

        Parameters
        ----------
        mapping
            A function to remap program atoms.

        Returns
        -------
        A reference to self.

        See Also
        --------
        remap
        &#34;&#34;&#34;
        _remap_stms(self.shows, mapping)
        _remap_stms(self.facts, mapping)
        _remap_stms(self.rules, mapping)
        _remap_stms(self.weight_rules, mapping)
        _remap_stms(self.heuristics, mapping)
        _remap_stms(self.edges, mapping)
        _remap_stms(self.minimizes, mapping)
        _remap_stms(self.externals, mapping)
        if self.projects is not None:
            _remap_stms(self.projects, mapping)
        for i, lit in enumerate(self.assumptions):
            self.assumptions[i] = _remap_lit(lit, mapping)
        self.output_atoms = {
            mapping(lit): sym for lit, sym in self.output_atoms.items()
        }

        return self

    def add_to_backend(
        self, backend: Backend, mapping: Optional[AtomMap] = None
    ) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Add the program to the given backend with an optional mapping.

        Note that the output table cannot be added to the backend for technical
        reasons. This has to be taken care of by the user. See for example the
        `Remapping` class, which provides functionality for this.

        Parameters
        ----------
        backend
            The backend.
        mapping
            A mapping function to remap literals.

        Returns
        -------
        A reference to self.

        See Also
        --------
        add_to_backend
        &#34;&#34;&#34;

        _add_stms_to_backend(self.shows, backend, mapping)
        _add_stms_to_backend(self.facts, backend, mapping)
        _add_stms_to_backend(self.rules, backend, mapping)
        _add_stms_to_backend(self.weight_rules, backend, mapping)
        _add_stms_to_backend(self.heuristics, backend, mapping)
        _add_stms_to_backend(self.edges, backend, mapping)
        _add_stms_to_backend(self.minimizes, backend, mapping)
        _add_stms_to_backend(self.externals, backend, mapping)
        if self.projects is not None:
            if self.projects:
                _add_stms_to_backend(self.projects, backend, mapping)
            else:
                backend.add_project([])

        backend.add_assume(
            [_remap_lit(lit, mapping) if mapping else lit for lit in self.assumptions]
        )

        return self

    def pretty_str(self, sort: bool = True) -&gt; str:
        &#34;&#34;&#34;
        Return a readable string represenation of the program.

        Parameters
        ----------
        sort
            Whether to sort the statements in the program befor printing.

        Returns
        -------
        The string representation of the program.
        &#34;&#34;&#34;
        return &#34;\n&#34;.join(
            chain(
                self._pretty_stms(self.shows, sort),
                self._pretty_stms(self.facts, sort),
                self._pretty_stms(self.rules, sort),
                self._pretty_stms(self.weight_rules, sort),
                self._pretty_stms(self.heuristics, sort),
                self._pretty_stms(self.edges, sort),
                self._pretty_stms(self.minimizes, sort),
                self._pretty_stms(self.externals, sort),
                self._pretty_projects(sort),
                self._pretty_assumptions(sort),
            )
        )

    def copy(self) -&gt; &#34;Program&#34;:
        &#34;&#34;&#34;
        Return a shallow copy of the program copying all mutable state.

        Returns
        -------
        A shallow copy of the program.
        &#34;&#34;&#34;
        return copy(self)

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Return a readable string represenation of the program.
        &#34;&#34;&#34;
        return self.pretty_str()</code></pre>
</details>
<div class="desc"><p>Ground program representation.</p>
<p>Although inefficient, the string representation of this program is parsable
by clingo.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Program.assumptions"><code class="name">var <span class="ident">assumptions</span> : List[int]</code></dt>
<dd>
<div class="desc"><p>A list of assumptions in form of program literals.</p></div>
</dd>
<dt id="clingox.program.Program.edges"><code class="name">var <span class="ident">edges</span> : List[<a title="clingox.program.Edge" href="#clingox.program.Edge">Edge</a>]</code></dt>
<dd>
<div class="desc"><p>A list of edge statements.</p></div>
</dd>
<dt id="clingox.program.Program.externals"><code class="name">var <span class="ident">externals</span> : List[<a title="clingox.program.External" href="#clingox.program.External">External</a>]</code></dt>
<dd>
<div class="desc"><p>A list of external statements.</p></div>
</dd>
<dt id="clingox.program.Program.facts"><code class="name">var <span class="ident">facts</span> : List[<a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a>]</code></dt>
<dd>
<div class="desc"><p>A list of facts.</p></div>
</dd>
<dt id="clingox.program.Program.heuristics"><code class="name">var <span class="ident">heuristics</span> : List[<a title="clingox.program.Heuristic" href="#clingox.program.Heuristic">Heuristic</a>]</code></dt>
<dd>
<div class="desc"><p>A list of heuristic statements.</p></div>
</dd>
<dt id="clingox.program.Program.minimizes"><code class="name">var <span class="ident">minimizes</span> : List[<a title="clingox.program.Minimize" href="#clingox.program.Minimize">Minimize</a>]</code></dt>
<dd>
<div class="desc"><p>A list of minimize statements.</p></div>
</dd>
<dt id="clingox.program.Program.output_atoms"><code class="name">var <span class="ident">output_atoms</span> : MutableMapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>]</code></dt>
<dd>
<div class="desc"><p>A mapping from program atoms to symbols.</p></div>
</dd>
<dt id="clingox.program.Program.projects"><code class="name">var <span class="ident">projects</span> : List[<a title="clingox.program.Project" href="#clingox.program.Project">Project</a>] | None</code></dt>
<dd>
<div class="desc"><p>A list of project statements.</p></div>
</dd>
<dt id="clingox.program.Program.rules"><code class="name">var <span class="ident">rules</span> : List[<a title="clingox.program.Rule" href="#clingox.program.Rule">Rule</a>]</code></dt>
<dd>
<div class="desc"><p>A list of rules.</p></div>
</dd>
<dt id="clingox.program.Program.shows"><code class="name">var <span class="ident">shows</span> : List[<a title="clingox.program.Show" href="#clingox.program.Show">Show</a>]</code></dt>
<dd>
<div class="desc"><p>A list of show statements.</p></div>
</dd>
<dt id="clingox.program.Program.weight_rules"><code class="name">var <span class="ident">weight_rules</span> : List[<a title="clingox.program.WeightRule" href="#clingox.program.WeightRule">WeightRule</a>]</code></dt>
<dd>
<div class="desc"><p>A list of weight rules.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clingox.program.Program.add_to_backend"><code class="name flex">
<span>def <span class="ident">add_to_backend</span></span>(<span>self,<br>backend: <a title="clingo.backend.Backend" href="../clingo/backend.html#clingo.backend.Backend">Backend</a>,<br>mapping: Callable[[int], int] | None = None) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_backend(
    self, backend: Backend, mapping: Optional[AtomMap] = None
) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Add the program to the given backend with an optional mapping.

    Note that the output table cannot be added to the backend for technical
    reasons. This has to be taken care of by the user. See for example the
    `Remapping` class, which provides functionality for this.

    Parameters
    ----------
    backend
        The backend.
    mapping
        A mapping function to remap literals.

    Returns
    -------
    A reference to self.

    See Also
    --------
    add_to_backend
    &#34;&#34;&#34;

    _add_stms_to_backend(self.shows, backend, mapping)
    _add_stms_to_backend(self.facts, backend, mapping)
    _add_stms_to_backend(self.rules, backend, mapping)
    _add_stms_to_backend(self.weight_rules, backend, mapping)
    _add_stms_to_backend(self.heuristics, backend, mapping)
    _add_stms_to_backend(self.edges, backend, mapping)
    _add_stms_to_backend(self.minimizes, backend, mapping)
    _add_stms_to_backend(self.externals, backend, mapping)
    if self.projects is not None:
        if self.projects:
            _add_stms_to_backend(self.projects, backend, mapping)
        else:
            backend.add_project([])

    backend.add_assume(
        [_remap_lit(lit, mapping) if mapping else lit for lit in self.assumptions]
    )

    return self</code></pre>
</details>
<div class="desc"><p>Add the program to the given backend with an optional mapping.</p>
<p>Note that the output table cannot be added to the backend for technical
reasons. This has to be taken care of by the user. See for example the
<code><a title="clingox.program.Remapping" href="#clingox.program.Remapping">Remapping</a></code> class, which provides functionality for this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong></dt>
<dd>The backend.</dd>
<dt><strong><code>mapping</code></strong></dt>
<dd>A mapping function to remap literals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A reference to self.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.program.add_to_backend" href="#clingox.program.add_to_backend">add_to_backend()</a></code></p></div>
</dd>
<dt id="clingox.program.Program.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Return a shallow copy of the program copying all mutable state.

    Returns
    -------
    A shallow copy of the program.
    &#34;&#34;&#34;
    return copy(self)</code></pre>
</details>
<div class="desc"><p>Return a shallow copy of the program copying all mutable state.</p>
<h2 id="returns">Returns</h2>
<p>A shallow copy of the program.</p></div>
</dd>
<dt id="clingox.program.Program.pretty_str"><code class="name flex">
<span>def <span class="ident">pretty_str</span></span>(<span>self, sort: bool = True) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_str(self, sort: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Return a readable string represenation of the program.

    Parameters
    ----------
    sort
        Whether to sort the statements in the program befor printing.

    Returns
    -------
    The string representation of the program.
    &#34;&#34;&#34;
    return &#34;\n&#34;.join(
        chain(
            self._pretty_stms(self.shows, sort),
            self._pretty_stms(self.facts, sort),
            self._pretty_stms(self.rules, sort),
            self._pretty_stms(self.weight_rules, sort),
            self._pretty_stms(self.heuristics, sort),
            self._pretty_stms(self.edges, sort),
            self._pretty_stms(self.minimizes, sort),
            self._pretty_stms(self.externals, sort),
            self._pretty_projects(sort),
            self._pretty_assumptions(sort),
        )
    )</code></pre>
</details>
<div class="desc"><p>Return a readable string represenation of the program.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sort</code></strong></dt>
<dd>Whether to sort the statements in the program befor printing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string representation of the program.</p></div>
</dd>
<dt id="clingox.program.Program.remap"><code class="name flex">
<span>def <span class="ident">remap</span></span>(<span>self, mapping: Callable[[int], int]) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remap(self, mapping: AtomMap) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Remap the literals in the program inplace.

    Parameters
    ----------
    mapping
        A function to remap program atoms.

    Returns
    -------
    A reference to self.

    See Also
    --------
    remap
    &#34;&#34;&#34;
    _remap_stms(self.shows, mapping)
    _remap_stms(self.facts, mapping)
    _remap_stms(self.rules, mapping)
    _remap_stms(self.weight_rules, mapping)
    _remap_stms(self.heuristics, mapping)
    _remap_stms(self.edges, mapping)
    _remap_stms(self.minimizes, mapping)
    _remap_stms(self.externals, mapping)
    if self.projects is not None:
        _remap_stms(self.projects, mapping)
    for i, lit in enumerate(self.assumptions):
        self.assumptions[i] = _remap_lit(lit, mapping)
    self.output_atoms = {
        mapping(lit): sym for lit, sym in self.output_atoms.items()
    }

    return self</code></pre>
</details>
<div class="desc"><p>Remap the literals in the program inplace.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mapping</code></strong></dt>
<dd>A function to remap program atoms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A reference to self.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="clingox.program.remap" href="#clingox.program.remap">remap()</a></code></p></div>
</dd>
<dt id="clingox.program.Program.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self) ‑> <a title="clingox.program.Program" href="#clingox.program.Program">Program</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self) -&gt; &#34;Program&#34;:
    &#34;&#34;&#34;
    Sort the statements in the program inplace.

    Returns
    -------
    A reference to self.
    &#34;&#34;&#34;
    self.shows.sort()
    self.facts.sort()
    self.rules.sort()
    self.weight_rules.sort()
    self.heuristics.sort()
    self.edges.sort()
    self.minimizes.sort()
    self.externals.sort()
    if self.projects is not None:
        self.projects.sort()
    self.assumptions.sort()

    return self</code></pre>
</details>
<div class="desc"><p>Sort the statements in the program inplace.</p>
<h2 id="returns">Returns</h2>
<p>A reference to self.</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.ProgramObserver"><code class="flex name class">
<span>class <span class="ident">ProgramObserver</span></span>
<span>(</span><span>program: <a title="clingox.program.Program" href="#clingox.program.Program">Program</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgramObserver(Observer):
    &#34;&#34;&#34;
    Program observer to build a ground program representation while grounding.

    This class explicitly ignores theory atoms because they already have a
    ground representation.

    Parameters
    ----------
    program
        The program to add statements to.
    &#34;&#34;&#34;

    _program: Program

    def __init__(self, program: Program):
        self._program = program

    def begin_step(self) -&gt; None:
        &#34;&#34;&#34;
        Resets the assumptions.
        &#34;&#34;&#34;
        self._program.assumptions.clear()

    def output_atom(self, symbol: Symbol, atom: Atom) -&gt; None:
        &#34;&#34;&#34;
        Add the given atom to the list of facts or output table.
        &#34;&#34;&#34;
        if atom != 0:
            self._program.output_atoms[atom] = symbol
        else:
            self._program.facts.append(Fact(symbol))

    def output_term(self, symbol: Symbol, condition: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add a term to the output table.
        &#34;&#34;&#34;
        self._program.shows.append(Show(symbol, condition))

    def rule(self, choice: bool, head: Sequence[Atom], body: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add a rule to the ground representation.

        Parameters
        ----------
        choice
            Determines if the head is a choice or a disjunction.
        head
            List of program atoms forming the rule head.
        body
            List of program literals forming the rule body.
        &#34;&#34;&#34;
        self._program.rules.append(Rule(choice, head, body))

    def weight_rule(
        self,
        choice: bool,
        head: Sequence[Atom],
        lower_bound: Weight,
        body: Sequence[Tuple[Literal, Weight]],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a weight rule to the ground representation.

        Parameters
        ----------
        choice
            Determines if the head is a choice or a disjunction.
        head
            List of program atoms forming the head of the rule.
        lower_bound
            The lower bound of the weight constraint in the rule body.
        body
            List of weighted literals (pairs of literal and weight) forming the
            elements of the weight constraint.
        &#34;&#34;&#34;
        self._program.weight_rules.append(WeightRule(choice, head, lower_bound, body))

    def project(self, atoms: Sequence[Atom]) -&gt; None:
        &#34;&#34;&#34;
        Add a project statement to the ground representation.

        Parameters
        ----------
        atoms
            The program atoms to project on.
        &#34;&#34;&#34;
        if self._program.projects is None:
            self._program.projects = []
        self._program.projects.extend(Project(atom) for atom in atoms)

    def external(self, atom: Atom, value: TruthValue) -&gt; None:
        &#34;&#34;&#34;
        Add an external statement to the ground representation.

        Parameters
        ----------
        atom
            The external atom in form of a program literal.
        value
            The truth value of the external statement.
        &#34;&#34;&#34;
        self._program.externals.append(External(atom, value))

    def assume(self, literals: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Extend the program with the given assumptions.

        Parameters
        ----------
        literals
            The program literals to assume (positive literals are true and
            negative literals false for the next solve call).
        &#34;&#34;&#34;
        self._program.assumptions.extend(literals)

    def minimize(
        self, priority: Weight, literals: Sequence[Tuple[Literal, Weight]]
    ) -&gt; None:
        &#34;&#34;&#34;
        Add a minimize statement to the ground representation.

        Parameters
        ----------
        priority
            The priority of the directive.
        literals
            List of weighted literals whose sum to minimize (pairs of literal
            and weight).
        &#34;&#34;&#34;
        self._program.minimizes.append(Minimize(priority, literals))

    def acyc_edge(self, node_u: int, node_v: int, condition: Sequence[Literal]) -&gt; None:
        &#34;&#34;&#34;
        Add an edge statement to the gronud representation.

        Parameters
        ----------
        node_u
            The start vertex of the edge (in form of an integer).
        node_v
            Тhe end vertex of the edge (in form of an integer).
        condition
            The list of program literals forming th condition under which to
            add the edge.
        &#34;&#34;&#34;
        self._program.edges.append(Edge(node_u, node_v, condition))

    def heuristic(
        self,
        atom: Atom,
        type_: HeuristicType,
        bias: Weight,
        priority: Weight,
        condition: Sequence[Literal],
    ) -&gt; None:
        &#34;&#34;&#34;
        Add heurisitic statement to the gronud representation.

        Parameters
        ----------
        atom
            The program atom heuristically modified.
        type_
            The type of the modification.
        bias
            A signed integer.
        priority
            An unsigned integer.
        condition
            List of program literals.
        &#34;&#34;&#34;
        self._program.heuristics.append(
            Heuristic(atom, type_, bias, priority, condition)
        )</code></pre>
</details>
<div class="desc"><p>Program observer to build a ground program representation while grounding.</p>
<p>This class explicitly ignores theory atoms because they already have a
ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>program</code></strong></dt>
<dd>The program to add statements to.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clingo.backend.Observer" href="../clingo/backend.html#clingo.backend.Observer">Observer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clingox.program.ProgramObserver.acyc_edge"><code class="name flex">
<span>def <span class="ident">acyc_edge</span></span>(<span>self, node_u: int, node_v: int, condition: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acyc_edge(self, node_u: int, node_v: int, condition: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Add an edge statement to the gronud representation.

    Parameters
    ----------
    node_u
        The start vertex of the edge (in form of an integer).
    node_v
        Тhe end vertex of the edge (in form of an integer).
    condition
        The list of program literals forming th condition under which to
        add the edge.
    &#34;&#34;&#34;
    self._program.edges.append(Edge(node_u, node_v, condition))</code></pre>
</details>
<div class="desc"><p>Add an edge statement to the gronud representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_u</code></strong></dt>
<dd>The start vertex of the edge (in form of an integer).</dd>
<dt><strong><code>node_v</code></strong></dt>
<dd>Тhe end vertex of the edge (in form of an integer).</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>The list of program literals forming th condition under which to
add the edge.</dd>
</dl></div>
</dd>
<dt id="clingox.program.ProgramObserver.assume"><code class="name flex">
<span>def <span class="ident">assume</span></span>(<span>self, literals: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assume(self, literals: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Extend the program with the given assumptions.

    Parameters
    ----------
    literals
        The program literals to assume (positive literals are true and
        negative literals false for the next solve call).
    &#34;&#34;&#34;
    self._program.assumptions.extend(literals)</code></pre>
</details>
<div class="desc"><p>Extend the program with the given assumptions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>literals</code></strong></dt>
<dd>The program literals to assume (positive literals are true and
negative literals false for the next solve call).</dd>
</dl></div>
</dd>
<dt id="clingox.program.ProgramObserver.begin_step"><code class="name flex">
<span>def <span class="ident">begin_step</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_step(self) -&gt; None:
    &#34;&#34;&#34;
    Resets the assumptions.
    &#34;&#34;&#34;
    self._program.assumptions.clear()</code></pre>
</details>
<div class="desc"><p>Resets the assumptions.</p></div>
</dd>
<dt id="clingox.program.ProgramObserver.external"><code class="name flex">
<span>def <span class="ident">external</span></span>(<span>self,<br>atom: int,<br>value: <a title="clingo.core.TruthValue" href="../clingo/core.html#clingo.core.TruthValue">TruthValue</a>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def external(self, atom: Atom, value: TruthValue) -&gt; None:
    &#34;&#34;&#34;
    Add an external statement to the ground representation.

    Parameters
    ----------
    atom
        The external atom in form of a program literal.
    value
        The truth value of the external statement.
    &#34;&#34;&#34;
    self._program.externals.append(External(atom, value))</code></pre>
</details>
<div class="desc"><p>Add an external statement to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong></dt>
<dd>The external atom in form of a program literal.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The truth value of the external statement.</dd>
</dl></div>
</dd>
<dt id="clingox.program.ProgramObserver.heuristic"><code class="name flex">
<span>def <span class="ident">heuristic</span></span>(<span>self,<br>atom: int,<br>type_: <a title="clingo.backend.HeuristicType" href="../clingo/backend.html#clingo.backend.HeuristicType">HeuristicType</a>,<br>bias: int,<br>priority: int,<br>condition: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heuristic(
    self,
    atom: Atom,
    type_: HeuristicType,
    bias: Weight,
    priority: Weight,
    condition: Sequence[Literal],
) -&gt; None:
    &#34;&#34;&#34;
    Add heurisitic statement to the gronud representation.

    Parameters
    ----------
    atom
        The program atom heuristically modified.
    type_
        The type of the modification.
    bias
        A signed integer.
    priority
        An unsigned integer.
    condition
        List of program literals.
    &#34;&#34;&#34;
    self._program.heuristics.append(
        Heuristic(atom, type_, bias, priority, condition)
    )</code></pre>
</details>
<div class="desc"><p>Add heurisitic statement to the gronud representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong></dt>
<dd>The program atom heuristically modified.</dd>
<dt><strong><code>type_</code></strong></dt>
<dd>The type of the modification.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>A signed integer.</dd>
<dt><strong><code>priority</code></strong></dt>
<dd>An unsigned integer.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>List of program literals.</dd>
</dl></div>
</dd>
<dt id="clingox.program.ProgramObserver.minimize"><code class="name flex">
<span>def <span class="ident">minimize</span></span>(<span>self, priority: int, literals: Sequence[Tuple[int, int]]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimize(
    self, priority: Weight, literals: Sequence[Tuple[Literal, Weight]]
) -&gt; None:
    &#34;&#34;&#34;
    Add a minimize statement to the ground representation.

    Parameters
    ----------
    priority
        The priority of the directive.
    literals
        List of weighted literals whose sum to minimize (pairs of literal
        and weight).
    &#34;&#34;&#34;
    self._program.minimizes.append(Minimize(priority, literals))</code></pre>
</details>
<div class="desc"><p>Add a minimize statement to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>priority</code></strong></dt>
<dd>The priority of the directive.</dd>
<dt><strong><code>literals</code></strong></dt>
<dd>List of weighted literals whose sum to minimize (pairs of literal
and weight).</dd>
</dl></div>
</dd>
<dt id="clingox.program.ProgramObserver.output_atom"><code class="name flex">
<span>def <span class="ident">output_atom</span></span>(<span>self,<br>symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>,<br>atom: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_atom(self, symbol: Symbol, atom: Atom) -&gt; None:
    &#34;&#34;&#34;
    Add the given atom to the list of facts or output table.
    &#34;&#34;&#34;
    if atom != 0:
        self._program.output_atoms[atom] = symbol
    else:
        self._program.facts.append(Fact(symbol))</code></pre>
</details>
<div class="desc"><p>Add the given atom to the list of facts or output table.</p></div>
</dd>
<dt id="clingox.program.ProgramObserver.output_term"><code class="name flex">
<span>def <span class="ident">output_term</span></span>(<span>self,<br>symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>,<br>condition: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_term(self, symbol: Symbol, condition: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Add a term to the output table.
    &#34;&#34;&#34;
    self._program.shows.append(Show(symbol, condition))</code></pre>
</details>
<div class="desc"><p>Add a term to the output table.</p></div>
</dd>
<dt id="clingox.program.ProgramObserver.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, atoms: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, atoms: Sequence[Atom]) -&gt; None:
    &#34;&#34;&#34;
    Add a project statement to the ground representation.

    Parameters
    ----------
    atoms
        The program atoms to project on.
    &#34;&#34;&#34;
    if self._program.projects is None:
        self._program.projects = []
    self._program.projects.extend(Project(atom) for atom in atoms)</code></pre>
</details>
<div class="desc"><p>Add a project statement to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atoms</code></strong></dt>
<dd>The program atoms to project on.</dd>
</dl></div>
</dd>
<dt id="clingox.program.ProgramObserver.rule"><code class="name flex">
<span>def <span class="ident">rule</span></span>(<span>self, choice: bool, head: Sequence[int], body: Sequence[int]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rule(self, choice: bool, head: Sequence[Atom], body: Sequence[Literal]) -&gt; None:
    &#34;&#34;&#34;
    Add a rule to the ground representation.

    Parameters
    ----------
    choice
        Determines if the head is a choice or a disjunction.
    head
        List of program atoms forming the rule head.
    body
        List of program literals forming the rule body.
    &#34;&#34;&#34;
    self._program.rules.append(Rule(choice, head, body))</code></pre>
</details>
<div class="desc"><p>Add a rule to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>choice</code></strong></dt>
<dd>Determines if the head is a choice or a disjunction.</dd>
<dt><strong><code>head</code></strong></dt>
<dd>List of program atoms forming the rule head.</dd>
<dt><strong><code>body</code></strong></dt>
<dd>List of program literals forming the rule body.</dd>
</dl></div>
</dd>
<dt id="clingox.program.ProgramObserver.weight_rule"><code class="name flex">
<span>def <span class="ident">weight_rule</span></span>(<span>self,<br>choice: bool,<br>head: Sequence[int],<br>lower_bound: int,<br>body: Sequence[Tuple[int, int]]) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_rule(
    self,
    choice: bool,
    head: Sequence[Atom],
    lower_bound: Weight,
    body: Sequence[Tuple[Literal, Weight]],
) -&gt; None:
    &#34;&#34;&#34;
    Add a weight rule to the ground representation.

    Parameters
    ----------
    choice
        Determines if the head is a choice or a disjunction.
    head
        List of program atoms forming the head of the rule.
    lower_bound
        The lower bound of the weight constraint in the rule body.
    body
        List of weighted literals (pairs of literal and weight) forming the
        elements of the weight constraint.
    &#34;&#34;&#34;
    self._program.weight_rules.append(WeightRule(choice, head, lower_bound, body))</code></pre>
</details>
<div class="desc"><p>Add a weight rule to the ground representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>choice</code></strong></dt>
<dd>Determines if the head is a choice or a disjunction.</dd>
<dt><strong><code>head</code></strong></dt>
<dd>List of program atoms forming the head of the rule.</dd>
<dt><strong><code>lower_bound</code></strong></dt>
<dd>The lower bound of the weight constraint in the rule body.</dd>
<dt><strong><code>body</code></strong></dt>
<dd>List of weighted literals (pairs of literal and weight) forming the
elements of the weight constraint.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clingo.backend.Observer" href="../clingo/backend.html#clingo.backend.Observer">Observer</a></b></code>:
<ul class="hlist">
<li><code><a title="clingo.backend.Observer.end_step" href="../clingo/backend.html#clingo.backend.Observer.end_step">end_step</a></code></li>
<li><code><a title="clingo.backend.Observer.init_program" href="../clingo/backend.html#clingo.backend.Observer.init_program">init_program</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_atom" href="../clingo/backend.html#clingo.backend.Observer.theory_atom">theory_atom</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_atom_with_guard" href="../clingo/backend.html#clingo.backend.Observer.theory_atom_with_guard">theory_atom_with_guard</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_element" href="../clingo/backend.html#clingo.backend.Observer.theory_element">theory_element</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_compound" href="../clingo/backend.html#clingo.backend.Observer.theory_term_compound">theory_term_compound</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_number" href="../clingo/backend.html#clingo.backend.Observer.theory_term_number">theory_term_number</a></code></li>
<li><code><a title="clingo.backend.Observer.theory_term_string" href="../clingo/backend.html#clingo.backend.Observer.theory_term_string">theory_term_string</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clingox.program.Project"><code class="flex name class">
<span>class <span class="ident">Project</span></span>
<span>(</span><span>atom: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Project(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of project statements.
    &#34;&#34;&#34;

    atom: Atom</code></pre>
</details>
<div class="desc"><p>Ground representation of project statements.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Project.atom"><code class="name">var <span class="ident">atom</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Project(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of project statements.
    &#34;&#34;&#34;

    atom: Atom</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Remapping"><code class="flex name class">
<span>class <span class="ident">Remapping</span></span>
<span>(</span><span>backend: <a title="clingo.backend.Backend" href="../clingo/backend.html#clingo.backend.Backend">Backend</a>,<br>output_atoms: Mapping[int, <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>],<br>facts: Iterable[<a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a>] = ())</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Remapping:
    &#34;&#34;&#34;
    This class maps existing literals to fresh literals as created by the
    backend.

    Parameters
    ----------
    backend
        The backend used to introduce fresh atoms.
    output_atoms
        The output table to initialize the mapping with.
    facts
        A list of facts each of which will receive a fresh program atom.
    &#34;&#34;&#34;

    _backend: Backend
    _map: MutableMapping[Atom, Atom]

    def __init__(
        self, backend: Backend, output_atoms: OutputTable, facts: Iterable[Fact] = ()
    ):
        self._backend = backend
        self._map = {}
        for atom, sym in output_atoms.items():
            assert atom not in self._map
            self._map[atom] = self._backend.add_atom(sym)
        for fact in facts:
            backend.add_rule([backend.add_atom(fact.symbol)])

    def __call__(self, atom: Atom) -&gt; Atom:
        &#34;&#34;&#34;
        Map the given program atom to the corresponding atom in the backend.

        If the literal was not mapped during initialization, a new literal is
        associated with it.

        Parameters
        ----------
        atom
            The atom to remap.

        Returns
        -------
        The remapped program atom.
        &#34;&#34;&#34;
        if atom not in self._map:
            self._map[atom] = self._backend.add_atom()

        return self._map[atom]</code></pre>
</details>
<div class="desc"><p>This class maps existing literals to fresh literals as created by the
backend.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong></dt>
<dd>The backend used to introduce fresh atoms.</dd>
<dt><strong><code>output_atoms</code></strong></dt>
<dd>The output table to initialize the mapping with.</dd>
<dt><strong><code>facts</code></strong></dt>
<dd>A list of facts each of which will receive a fresh program atom.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="clingox.program.Remapping.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, atom: int) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, atom: Atom) -&gt; Atom:
    &#34;&#34;&#34;
    Map the given program atom to the corresponding atom in the backend.

    If the literal was not mapped during initialization, a new literal is
    associated with it.

    Parameters
    ----------
    atom
        The atom to remap.

    Returns
    -------
    The remapped program atom.
    &#34;&#34;&#34;
    if atom not in self._map:
        self._map[atom] = self._backend.add_atom()

    return self._map[atom]</code></pre>
</details>
<div class="desc"><p>Map the given program atom to the corresponding atom in the backend.</p>
<p>If the literal was not mapped during initialization, a new literal is
associated with it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong></dt>
<dd>The atom to remap.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The remapped program atom.</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Rule"><code class="flex name class">
<span>class <span class="ident">Rule</span></span>
<span>(</span><span>choice: bool, head: Sequence[int], body: Sequence[int])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of disjunctive and choice rules.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    body: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Ground representation of disjunctive and choice rules.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Rule.body"><code class="name">var <span class="ident">body</span> : Sequence[int]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of disjunctive and choice rules.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    body: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="clingox.program.Rule.choice"><code class="name">var <span class="ident">choice</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of disjunctive and choice rules.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    body: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.Rule.head"><code class="name">var <span class="ident">head</span> : Sequence[int]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of disjunctive and choice rules.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    body: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.Show"><code class="flex name class">
<span>class <span class="ident">Show</span></span>
<span>(</span><span>symbol: <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a>,<br>condition: Sequence[int])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Show(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a show statements.
    &#34;&#34;&#34;

    symbol: Symbol
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Ground representation of a show statements.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.Show.condition"><code class="name">var <span class="ident">condition</span> : Sequence[int]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Show(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a show statements.
    &#34;&#34;&#34;

    symbol: Symbol
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="clingox.program.Show.symbol"><code class="name">var <span class="ident">symbol</span> : <a title="clingo.symbol.Symbol" href="../clingo/symbol.html#clingo.symbol.Symbol">Symbol</a></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Show(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of a show statements.
    &#34;&#34;&#34;

    symbol: Symbol
    condition: Sequence[Literal]</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
<dt id="clingox.program.WeightRule"><code class="flex name class">
<span>class <span class="ident">WeightRule</span></span>
<span>(</span><span>choice: bool,<br>head: Sequence[int],<br>lower_bound: int,<br>body: Sequence[Tuple[int, int]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightRule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of rules with a weight constraint in the body.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    lower_bound: Weight
    body: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Ground representation of rules with a weight constraint in the body.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clingox.program.WeightRule.body"><code class="name">var <span class="ident">body</span> : Sequence[Tuple[int, int]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightRule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of rules with a weight constraint in the body.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    lower_bound: Weight
    body: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="clingox.program.WeightRule.choice"><code class="name">var <span class="ident">choice</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightRule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of rules with a weight constraint in the body.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    lower_bound: Weight
    body: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="clingox.program.WeightRule.head"><code class="name">var <span class="ident">head</span> : Sequence[int]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightRule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of rules with a weight constraint in the body.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    lower_bound: Weight
    body: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="clingox.program.WeightRule.lower_bound"><code class="name">var <span class="ident">lower_bound</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightRule(NamedTuple):
    &#34;&#34;&#34;
    Ground representation of rules with a weight constraint in the body.
    &#34;&#34;&#34;

    choice: bool
    head: Sequence[Atom]
    lower_bound: Weight
    body: Sequence[Tuple[Literal, Weight]]</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#example">Example</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clingox" href="index.html">clingox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clingox.program.add_to_backend" href="#clingox.program.add_to_backend">add_to_backend</a></code></li>
<li><code><a title="clingox.program.pretty_str" href="#clingox.program.pretty_str">pretty_str</a></code></li>
<li><code><a title="clingox.program.remap" href="#clingox.program.remap">remap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clingox.program.Edge" href="#clingox.program.Edge">Edge</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Edge.condition" href="#clingox.program.Edge.condition">condition</a></code></li>
<li><code><a title="clingox.program.Edge.u" href="#clingox.program.Edge.u">u</a></code></li>
<li><code><a title="clingox.program.Edge.v" href="#clingox.program.Edge.v">v</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.External" href="#clingox.program.External">External</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.External.atom" href="#clingox.program.External.atom">atom</a></code></li>
<li><code><a title="clingox.program.External.value" href="#clingox.program.External.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Fact" href="#clingox.program.Fact">Fact</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Fact.symbol" href="#clingox.program.Fact.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Heuristic" href="#clingox.program.Heuristic">Heuristic</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Heuristic.atom" href="#clingox.program.Heuristic.atom">atom</a></code></li>
<li><code><a title="clingox.program.Heuristic.bias" href="#clingox.program.Heuristic.bias">bias</a></code></li>
<li><code><a title="clingox.program.Heuristic.condition" href="#clingox.program.Heuristic.condition">condition</a></code></li>
<li><code><a title="clingox.program.Heuristic.priority" href="#clingox.program.Heuristic.priority">priority</a></code></li>
<li><code><a title="clingox.program.Heuristic.type_" href="#clingox.program.Heuristic.type_">type_</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Minimize" href="#clingox.program.Minimize">Minimize</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Minimize.literals" href="#clingox.program.Minimize.literals">literals</a></code></li>
<li><code><a title="clingox.program.Minimize.priority" href="#clingox.program.Minimize.priority">priority</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Program" href="#clingox.program.Program">Program</a></code></h4>
<ul class="two-column">
<li><code><a title="clingox.program.Program.add_to_backend" href="#clingox.program.Program.add_to_backend">add_to_backend</a></code></li>
<li><code><a title="clingox.program.Program.assumptions" href="#clingox.program.Program.assumptions">assumptions</a></code></li>
<li><code><a title="clingox.program.Program.copy" href="#clingox.program.Program.copy">copy</a></code></li>
<li><code><a title="clingox.program.Program.edges" href="#clingox.program.Program.edges">edges</a></code></li>
<li><code><a title="clingox.program.Program.externals" href="#clingox.program.Program.externals">externals</a></code></li>
<li><code><a title="clingox.program.Program.facts" href="#clingox.program.Program.facts">facts</a></code></li>
<li><code><a title="clingox.program.Program.heuristics" href="#clingox.program.Program.heuristics">heuristics</a></code></li>
<li><code><a title="clingox.program.Program.minimizes" href="#clingox.program.Program.minimizes">minimizes</a></code></li>
<li><code><a title="clingox.program.Program.output_atoms" href="#clingox.program.Program.output_atoms">output_atoms</a></code></li>
<li><code><a title="clingox.program.Program.pretty_str" href="#clingox.program.Program.pretty_str">pretty_str</a></code></li>
<li><code><a title="clingox.program.Program.projects" href="#clingox.program.Program.projects">projects</a></code></li>
<li><code><a title="clingox.program.Program.remap" href="#clingox.program.Program.remap">remap</a></code></li>
<li><code><a title="clingox.program.Program.rules" href="#clingox.program.Program.rules">rules</a></code></li>
<li><code><a title="clingox.program.Program.shows" href="#clingox.program.Program.shows">shows</a></code></li>
<li><code><a title="clingox.program.Program.sort" href="#clingox.program.Program.sort">sort</a></code></li>
<li><code><a title="clingox.program.Program.weight_rules" href="#clingox.program.Program.weight_rules">weight_rules</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.ProgramObserver" href="#clingox.program.ProgramObserver">ProgramObserver</a></code></h4>
<ul class="two-column">
<li><code><a title="clingox.program.ProgramObserver.acyc_edge" href="#clingox.program.ProgramObserver.acyc_edge">acyc_edge</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.assume" href="#clingox.program.ProgramObserver.assume">assume</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.begin_step" href="#clingox.program.ProgramObserver.begin_step">begin_step</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.external" href="#clingox.program.ProgramObserver.external">external</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.heuristic" href="#clingox.program.ProgramObserver.heuristic">heuristic</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.minimize" href="#clingox.program.ProgramObserver.minimize">minimize</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.output_atom" href="#clingox.program.ProgramObserver.output_atom">output_atom</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.output_term" href="#clingox.program.ProgramObserver.output_term">output_term</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.project" href="#clingox.program.ProgramObserver.project">project</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.rule" href="#clingox.program.ProgramObserver.rule">rule</a></code></li>
<li><code><a title="clingox.program.ProgramObserver.weight_rule" href="#clingox.program.ProgramObserver.weight_rule">weight_rule</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Project" href="#clingox.program.Project">Project</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Project.atom" href="#clingox.program.Project.atom">atom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Remapping" href="#clingox.program.Remapping">Remapping</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Remapping.__call__" href="#clingox.program.Remapping.__call__">__call__</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Rule" href="#clingox.program.Rule">Rule</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Rule.body" href="#clingox.program.Rule.body">body</a></code></li>
<li><code><a title="clingox.program.Rule.choice" href="#clingox.program.Rule.choice">choice</a></code></li>
<li><code><a title="clingox.program.Rule.head" href="#clingox.program.Rule.head">head</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.Show" href="#clingox.program.Show">Show</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.Show.condition" href="#clingox.program.Show.condition">condition</a></code></li>
<li><code><a title="clingox.program.Show.symbol" href="#clingox.program.Show.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clingox.program.WeightRule" href="#clingox.program.WeightRule">WeightRule</a></code></h4>
<ul class="">
<li><code><a title="clingox.program.WeightRule.body" href="#clingox.program.WeightRule.body">body</a></code></li>
<li><code><a title="clingox.program.WeightRule.choice" href="#clingox.program.WeightRule.choice">choice</a></code></li>
<li><code><a title="clingox.program.WeightRule.head" href="#clingox.program.WeightRule.head">head</a></code></li>
<li><code><a title="clingox.program.WeightRule.lower_bound" href="#clingox.program.WeightRule.lower_bound">lower_bound</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
